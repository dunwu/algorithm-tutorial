(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{371:function(t,_,v){"use strict";v.r(_);var s=v(15),r=Object(s.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"栈和队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列"}},[t._v("#")]),t._v(" 栈和队列")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("队列")]),t._v("和"),_("strong",[t._v("栈")]),t._v("都是"),_("strong",[t._v("操作受限")]),t._v("的"),_("strong",[t._v("线性表")]),t._v("：前者先进先出，后者先进后出。")])]),t._v(" "),_("h2",{attrs:{id:"栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈")]),t._v(" "),_("h3",{attrs:{id:"栈是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈是什么"}},[t._v("#")]),t._v(" 栈是什么")]),t._v(" "),_("p",[t._v("在 "),_("strong",[t._v("LIFO(后进先出)")]),t._v(" 数据结构中，将首先处理添加到队列中的最新元素。")]),t._v(" "),_("p",[_("strong",[t._v("栈是一个 LIFO(后进先出) 数据结构")]),t._v("。"),_("strong",[t._v("栈是一种“操作受限”的线性表")]),t._v("，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220320200148.png",alt:"img"}})]),t._v(" "),_("p",[_("strong",[t._v("当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构")]),t._v("。")]),t._v(" "),_("p",[t._v("从栈的定义可以看出，栈只支持两个基本操作："),_("strong",[t._v("入栈 "),_("code",[t._v("push()")])]),t._v(" 和 "),_("strong",[t._v("出栈 "),_("code",[t._v("pop()")])]),t._v(" ，也就是在栈顶插入一个数据和从栈顶删除一个数据。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 "),_("code",[t._v("O(1)")]),t._v("。")]),t._v(" "),_("p",[t._v("栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作"),_("strong",[t._v("顺序栈")]),t._v("，用链表实现的栈，我们叫作"),_("strong",[t._v("链式栈")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"为什么需要栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要栈"}},[t._v("#")]),t._v(" 为什么需要栈")]),t._v(" "),_("p",[t._v("相比数组和链表，栈只是对操作进行了限制，似乎并没有任何优势。为什么不直接使用数组或者链表？为什么还要用这个“操作受限”的“栈”呢？")]),t._v(" "),_("p",[t._v("特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。")]),t._v(" "),_("h3",{attrs:{id:"栈的应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈的应用场景"}},[t._v("#")]),t._v(" 栈的应用场景")]),t._v(" "),_("p",[t._v("（1）"),_("strong",[t._v("函数调用栈")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220310091000.jpg",alt:"img"}})]),t._v(" "),_("p",[t._v("（2）"),_("strong",[t._v("表达式求值")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220310091100.jpg",alt:"img"}})]),t._v(" "),_("p",[t._v("（3）"),_("strong",[t._v("表达式匹配")])]),t._v(" "),_("p",[t._v("可以借助栈来检查表达式中的括号是否匹配")]),t._v(" "),_("h2",{attrs:{id:"队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),_("p",[t._v("在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。")]),t._v(" "),_("p",[t._v("队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。")]),t._v(" "),_("h3",{attrs:{id:"什么是队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是队列"}},[t._v("#")]),t._v(" 什么是队列")]),t._v(" "),_("p",[_("strong",[t._v("队列：先进先出的线性表")]),t._v("。")]),t._v(" "),_("p",[_("strong",[t._v("队列是一种“操作受限”的线性表")]),t._v("，只允许在一端插入数据，在另一端删除数据。")]),t._v(" "),_("p",[t._v("队列的最基本操作："),_("strong",[t._v("入队 "),_("code",[t._v("enqueue()")])]),t._v("，放一个数据到队列尾部；"),_("strong",[t._v("出队 "),_("code",[t._v("dequeue()")])]),t._v("，从队列头部取一个元素。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220320200213.png",alt:"img"}})]),t._v(" "),_("p",[t._v("队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作"),_("strong",[t._v("顺序队列")]),t._v("，用链表实现的队列叫作"),_("strong",[t._v("链式队列")]),t._v("。")]),t._v(" "),_("p",[t._v("队满的判断条件是 "),_("code",[t._v("tail == n")]),t._v("，队空的判断条件是 "),_("code",[t._v("head == tail")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"循环队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#循环队列"}},[t._v("#")]),t._v(" 循环队列")]),t._v(" "),_("p",[t._v("循环队列是一种较为特殊的队列。")]),t._v(" "),_("p",[t._v("循环队列的要点是确定好 "),_("strong",[t._v("队空和队满的判定条件")]),t._v("。")]),t._v(" "),_("p",[t._v("在用数组实现的非循环队列中，队满的判断条件是 "),_("code",[t._v("(tail+1) % n == head")]),t._v("，队空的判断条件是 "),_("code",[t._v("head == tail")]),t._v("。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220322214822.png",alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"为什么需要队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要队列"}},[t._v("#")]),t._v(" 为什么需要队列")]),t._v(" "),_("p",[t._v("为什么需要队列和为什么需要栈，是同样的道理，参考 为什么需要栈")]),t._v(" "),_("h3",{attrs:{id:"队列的应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#队列的应用场景"}},[t._v("#")]),t._v(" 队列的应用场景")]),t._v(" "),_("p",[t._v("（1）"),_("strong",[t._v("阻塞队列")])]),t._v(" "),_("p",[_("strong",[t._v("阻塞队列")]),t._v("其实就是在队列基础上增加了阻塞操作。简单来说，就是：")]),t._v(" "),_("ul",[_("li",[t._v("在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；")]),t._v(" "),_("li",[t._v("如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220310092908.jpg",alt:"img"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/master/snap/20220310093026.jpg",alt:"img"}})]),t._v(" "),_("p",[t._v("（2）"),_("strong",[t._v("并发队列")])]),t._v(" "),_("p",[t._v("线程安全的队列我们叫作"),_("strong",[t._v("并发队列")]),t._v("。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。")]),t._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://time.geekbang.org/column/intro/100017301",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构与算法之美"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://leetcode-cn.com/leetbook/detail/queue-stack/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Leetcode：栈和队列"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=r.exports}}]);