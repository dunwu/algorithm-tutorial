(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,a,s=e[0],l=e[1],c=e[2],p=0,d=[];p<s.length;p++)a=s[p],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&d.push(i[a][0]),i[a]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);d.length;)d.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(o.splice(e--,1),n=a(a.s=t[0]))}return n}var r={},i={1:0},o=[];function a(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+"assets/js/"+({}[n]||n)+"."+{2:"0614414d",3:"5558a6e1",4:"299b66ae",5:"c0f5e5bd",6:"52313dd5",7:"6bcf88b6",8:"c3badfe5",9:"4e16acd2",10:"83aa862c",11:"338bb79e",12:"56ce2750",13:"043e7917",14:"f2d0eef3",15:"c790cdea",16:"f41ae058",17:"ec4bacb3",18:"a2608068",19:"06955b8f",20:"d11394fe",21:"a1cdab79",22:"77cfef6d",23:"eadc2bc9",24:"b224f2fa",25:"3c1a5d5f",26:"af40ca72",27:"9e7a59b6"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},a.m=n,a.c=r,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)a.d(t,r,function(e){return n[e]}.bind(null,r));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="/algorithm-tutorial/",a.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;o.push([129,0]),t()}([function(n,e,t){"use strict";var r=function(n){return n&&n.Math===Math&&n};n.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var r="object"==typeof document&&document.all;n.exports=void 0===r&&void 0!==r?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var r=t(11),i=t(0),o=t(144),a=t(4),s=t(2),l=t(87),c=t(126),u=t(146),p=t(1),d=t(10),f=t(17),h=t(88).IteratorPrototype,v=t(6),m=t(24),g=f("toStringTag"),y=TypeError,b=i.Iterator,x=m||!s(b)||b.prototype!==h||!p((function(){b({})})),_=function(){if(o(this,h),l(this)===h)throw new y("Abstract class Iterator not directly constructable")},w=function(n,e){v?c(h,n,{configurable:!0,get:function(){return e},set:function(e){if(a(this),this===h)throw new y("You can't redefine this property");d(this,n)?this[n]=e:u(this,n,e)}}):h[n]=e};d(h,g)||w(g,"Iterator"),!x&&d(h,"constructor")&&h.constructor!==Object||w("constructor",_),_.prototype=h,r({global:!0,constructor:!0,forced:x},{Iterator:_})},function(n,e,t){"use strict";var r=t(9),i=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw new o(i(n)+" is not an object")}},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,o=i.call,a=r&&i.bind.bind(o,o);n.exports=r?a:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";var r=t(1);n.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){"use strict";var r=t(34),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){"use strict";var r=t(2),i=t(50),o=TypeError;n.exports=function(n){if(r(n))return n;throw new o(i(n)+" is not a function")}},function(n,e,t){"use strict";var r=t(2);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){"use strict";var r=t(5),i=t(32),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(i(n),e)}},function(n,e,t){"use strict";var r=t(0),i=t(70).f,o=t(25),a=t(46),s=t(52),l=t(84),c=t(143);n.exports=function(n,e){var t,u,p,d,f,h=n.target,v=n.global,m=n.stat;if(t=v?r:m?r[h]||s(h,{}):r[h]&&r[h].prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(f=i(t,u))&&f.value:t[u],!c(v?u:h+(m?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;l(d,p)}(n.sham||p&&p.sham)&&o(d,"sham",!0),a(t,u,d,n)}}},function(n,e,t){"use strict";var r=t(7),i=t(4),o=t(39);n.exports=function(n,e,t){var a,s;i(n);try{if(!(a=o(n,"return"))){if("throw"===e)throw t;return t}a=r(a,n)}catch(n){s=!0,a=n}if("throw"===e)throw t;if(s)throw a;return i(a),t}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(98),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,i,o,a,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),a?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(11),i=t(7),o=t(8),a=t(4),s=t(26),l=t(89),c=t(90),u=t(24),p=t(12),d=t(91),f=t(27),h=!u&&!d("filter",(function(){})),v=!u&&!h&&f("filter",TypeError),m=u||h||v,g=l((function(){for(var n,e,t=this.iterator,r=this.predicate,o=this.next;;){if(n=a(i(o,t)),this.done=!!n.done)return;if(e=n.value,c(t,r,[e,this.counter++],!0))return e}}));r({target:"Iterator",proto:!0,real:!0,forced:m},{filter:function(n){a(this);try{o(n)}catch(n){p(this,"throw",n)}return v?i(v,this,n):new g(s(this),{predicate:n})}})},function(n,e,t){"use strict";var r=t(0),i=t(77),o=t(10),a=t(78),s=t(74),l=t(73),c=r.Symbol,u=i("wks"),p=l?c.for||c:c&&c.withoutSetter||a;n.exports=function(n){return o(u,n)||(u[n]=s&&o(c,n)?c[n]:p("Symbol."+n)),u[n]}},function(n,e,t){"use strict";var r=t(11),i=t(7),o=t(47),a=t(8),s=t(4),l=t(26),c=t(12),u=t(27)("forEach",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:u},{forEach:function(n){s(this);try{a(n)}catch(n){c(this,"throw",n)}if(u)return i(u,this,n);var e=l(this),t=0;o(e,(function(e){n(e,t++)}),{IS_RECORD:!0})}})},function(n,e,t){"use strict";var r=t(6),i=t(79),o=t(81),a=t(4),s=t(71),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(a(n),e=s(e),a(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(a(n),e=s(e),a(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(196),i=t(199);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return a})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return m})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return y})),t.d(e,"a",(function(){return x}));t(31),t(3),t(16),t(18),t(22);const r=/#.*$/,i=/\.(md|html)$/,o=/\/$/,a=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return a.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",i=s(n);return o.test(i)?n:i+".html"+t}function d(n,e){const t=n.hash,i=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(i&&t!==i)return!1;return s(n.path)===s(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:i,themeConfig:o}=t,a=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||a.sidebar||o.sidebar))return v(n);const s=a.sidebar||o.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?v(n):r?r.map(n=>function n(e,t,r,i=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,r,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function v(n){const e=m(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function m(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function y(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return b(e)-b(n)}},function(n,e,t){"use strict";var r=t(11),i=t(7),o=t(8),a=t(4),s=t(26),l=t(89),c=t(90),u=t(12),p=t(91),d=t(27),f=t(24),h=!f&&!p("map",(function(){})),v=!f&&!h&&d("map",TypeError),m=f||h||v,g=l((function(){var n=this.iterator,e=a(i(this.next,n));if(!(this.done=!!e.done))return c(n,this.mapper,[e.value,this.counter++],!0)}));r({target:"Iterator",proto:!0,real:!0,forced:m},{map:function(n){a(this);try{o(n)}catch(n){u(this,"throw",n)}return v?i(v,this,n):new g(s(this),{mapper:n})}})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var r=t(6),i=t(19),o=t(35);n.exports=r?function(n,e,t){return i.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";n.exports=function(n){return{iterator:n,next:n.next,done:!1}}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n,e){var t=r.Iterator,i=t&&t.prototype,o=i&&i[n],a=!1;if(o)try{o.call({next:function(){return{done:!0}},return:function(){a=!0}},-1)}catch(n){n instanceof e||(a=!1)}if(!a)return o}},function(n,e,t){var r=t(30),i=t(181),o=t(182),a=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?i(n):o(n)}},function(n,e,t){"use strict";var r=t(5),i=r({}.toString),o=r("".slice);n.exports=function(n){return o(i(n),8,-1)}},function(n,e,t){var r=t(14).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(11),i=t(32),o=t(33),a=t(175),s=t(177);r({target:"Array",proto:!0,arity:1,forced:t(1)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=i(this),t=o(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return a(e,t),t}})},function(n,e,t){"use strict";var r=t(48),i=Object;n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var r=t(141);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(1);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var r=t(66),i=t(48);n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var r=t(0),i=t(2),o=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(5);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(8),i=t(49);n.exports=function(n,e){var t=n[e];return i(t)?void 0:r(t)}},function(n,e,t){var r=t(186),i=t(187),o=t(188),a=t(189),s=t(190);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(100);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(20)(Object,"create");n.exports=r},function(n,e,t){var r=t(208);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(63);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,p=r.easing;return l.offsetWidth,a((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,i}(n,u,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,a=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),u=document.querySelector(r.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&d(i),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,o=arguments;if(2==o.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=p(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(2),i=t(19),o=t(82),a=t(52);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&o(t,c,s),s.global)l?n[e]=t:a(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var r=t(127),i=t(7),o=t(4),a=t(50),s=t(159),l=t(33),c=t(38),u=t(160),p=t(93),d=t(12),f=TypeError,h=function(n,e){this.stopped=n,this.result=e},v=h.prototype;n.exports=function(n,e,t){var m,g,y,b,x,_,w,k=t&&t.that,E=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_RECORD),O=!(!t||!t.IS_ITERATOR),j=!(!t||!t.INTERRUPTED),S=r(e,k),C=function(n){return m&&d(m,"normal"),new h(!0,n)},I=function(n){return E?(o(n),j?S(n[0],n[1],C):S(n[0],n[1])):j?S(n,C):S(n)};if(T)m=n.iterator;else if(O)m=n;else{if(!(g=p(n)))throw new f(a(n)+" is not iterable");if(s(g)){for(y=0,b=l(n);b>y;y++)if((x=I(n[y]))&&c(v,x))return x;return new h(!1)}m=u(n,g)}for(_=T?n.next:m.next;!(w=i(_,m)).done;){try{x=I(w.value)}catch(n){d(m,"throw",n)}if("object"==typeof x&&x&&c(v,x))return x}return new h(!1)}},function(n,e,t){"use strict";var r=t(49),i=TypeError;n.exports=function(n){if(r(n))throw new i("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var r=String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var r=t(24),i=t(0),o=t(52),a=n.exports=i["__core-js_shared__"]||o("__core-js_shared__",{});(a.versions||(a.versions=[])).push({version:"3.46.0",mode:r?"pure":"global",copyright:"© 2014-2025 Denis Pushkarev (zloirock.ru), 2025 CoreJS Company (core-js.io)",license:"https://github.com/zloirock/core-js/blob/v3.46.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var r=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){"use strict";var r=t(77),i=t(78),o=r("keys");n.exports=function(n){return o[n]||(o[n]=i(n))}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(180),i=t(23),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&a.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(20)(t(14),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(200),i=t(207),o=t(209),a=t(210),s=t(211);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(13),i=t(63),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(a.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(28),i=t(23);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(11),i=t(7),o=t(47),a=t(8),s=t(4),l=t(26),c=t(12),u=t(27)("some",TypeError);r({target:"Iterator",proto:!0,real:!0,forced:u},{some:function(n){s(this);try{a(n)}catch(n){c(this,"throw",n)}if(u)return i(u,this,n);var e=l(this),t=0;return o(e,(function(e,r){if(n(e,t++))return r()}),{IS_RECORD:!0,INTERRUPTED:!0}).stopped}})},function(n,e,t){"use strict";var r=t(5),i=t(1),o=t(29),a=Object,s=r("".split);n.exports=i((function(){return!a("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):a(n)}:a},function(n,e,t){"use strict";var r,i=t(4),o=t(147),a=t(55),s=t(54),l=t(149),c=t(80),u=t(53),p=u("IE_PROTO"),d=function(){},f=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e},v=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;v="undefined"!=typeof document?document.domain&&r?h(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F):h(r);for(var t=a.length;t--;)delete v.prototype[a[t]];return v()};s[p]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(d.prototype=i(n),t=new d,d.prototype=null,t[p]=n):t=v(),void 0===e?t:o.f(t,e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function v(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||o.test(n)?a(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,o,a,s,l,c=0,u=!1,m=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,o=i;return r=i=void 0,c=e,a=n.apply(o,t)}function b(n){return c=n,s=setTimeout(_,e),u?y(n):a}function x(n){var t=n-l;return void 0===l||t>=e||t<0||m&&n-c>=o}function _(){var n=f();if(x(n))return w(n);s=setTimeout(_,function(n){var t=e-(n-l);return m?d(t,o-(n-c)):t}(n))}function w(n){return s=void 0,g&&r?y(n):(r=i=void 0,a)}function k(){var n=f(),t=x(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return b(l);if(m)return s=setTimeout(_,e),y(l)}return void 0===s&&(s=setTimeout(_,e)),a}return e=v(e)||0,h(t)&&(u=!!t.leading,o=(m="maxWait"in t)?p(v(t.maxWait)||0,e):o,g="trailing"in t?!!t.trailing:g),k.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},k.flush=function(){return void 0===s?a:w(f())},k}},function(n,e,t){"use strict";var r=t(6),i=t(7),o=t(130),a=t(35),s=t(36),l=t(71),c=t(10),u=t(79),p=Object.getOwnPropertyDescriptor;e.f=r?p:function(n,e){if(n=s(n),e=l(e),u)try{return p(n,e)}catch(n){}if(c(n,e))return a(!i(o.f,n,e),n[e])}},function(n,e,t){"use strict";var r=t(131),i=t(72);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){"use strict";var r=t(37),i=t(2),o=t(38),a=t(73),s=Object;n.exports=a?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return i(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var r=t(74);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var r=t(75),i=t(1),o=t(0).String;n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){"use strict";var r,i,o=t(0),a=t(76),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&a&&(!(r=a.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=a.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){"use strict";var r=t(0).navigator,i=r&&r.userAgent;n.exports=i?String(i):""},function(n,e,t){"use strict";var r=t(51);n.exports=function(n,e){return r[n]||(r[n]=e||{})}},function(n,e,t){"use strict";var r=t(5),i=0,o=Math.random(),a=r(1.1.toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++i+o,36)}},function(n,e,t){"use strict";var r=t(6),i=t(1),o=t(80);n.exports=!r&&!i((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var r=t(0),i=t(9),o=r.document,a=i(o)&&i(o.createElement);n.exports=function(n){return a?o.createElement(n):{}}},function(n,e,t){"use strict";var r=t(6),i=t(1);n.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var r=t(5),i=t(1),o=t(2),a=t(10),s=t(6),l=t(133).CONFIGURABLE,c=t(134),u=t(83),p=u.enforce,d=u.get,f=String,h=Object.defineProperty,v=r("".slice),m=r("".replace),g=r([].join),y=s&&!i((function(){return 8!==h((function(){}),"length",{value:8}).length})),b=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===v(f(e),0,7)&&(e="["+m(f(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),y&&t&&a(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return a(r,"source")||(r.source=g(b,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return o(this)&&d(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var r,i,o,a=t(135),s=t(0),l=t(9),c=t(25),u=t(10),p=t(51),d=t(53),f=t(54),h=s.TypeError,v=s.WeakMap;if(a||p.state){var m=p.state||(p.state=new v);m.get=m.get,m.has=m.has,m.set=m.set,r=function(n,e){if(m.has(n))throw new h("Object already initialized");return e.facade=n,m.set(n,e),e},i=function(n){return m.get(n)||{}},o=function(n){return m.has(n)}}else{var g=d("state");f[g]=!0,r=function(n,e){if(u(n,g))throw new h("Object already initialized");return e.facade=n,c(n,g,e),e},i=function(n){return u(n,g)?n[g]:{}},o=function(n){return u(n,g)}}n.exports={set:r,get:i,has:o,enforce:function(n){return o(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var r=t(10),i=t(136),o=t(70),a=t(19);n.exports=function(n,e,t){for(var s=i(e),l=a.f,c=o.f,u=0;u<s.length;u++){var p=s[u];r(n,p)||t&&r(t,p)||l(n,p,c(e,p))}}},function(n,e,t){"use strict";var r=t(5),i=t(10),o=t(36),a=t(138).indexOf,s=t(54),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,u=[];for(t in r)!i(s,t)&&i(r,t)&&l(u,t);for(;e.length>c;)i(r,t=e[c++])&&(~a(u,t)||l(u,t));return u}},function(n,e,t){"use strict";var r=t(140);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){"use strict";var r=t(10),i=t(2),o=t(32),a=t(53),s=t(145),l=a("IE_PROTO"),c=Object,u=c.prototype;n.exports=s?c.getPrototypeOf:function(n){var e=o(n);if(r(e,l))return e[l];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof c?u:null}},function(n,e,t){"use strict";var r,i,o,a=t(1),s=t(2),l=t(9),c=t(67),u=t(87),p=t(46),d=t(17),f=t(24),h=d("iterator"),v=!1;[].keys&&("next"in(o=[].keys())?(i=u(u(o)))!==Object.prototype&&(r=i):v=!0),!l(r)||a((function(){var n={};return r[h].call(n)!==n}))?r={}:f&&(r=c(r)),s(r[h])||p(r,h,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:v}},function(n,e,t){"use strict";var r=t(7),i=t(67),o=t(25),a=t(150),s=t(17),l=t(83),c=t(39),u=t(88).IteratorPrototype,p=t(151),d=t(12),f=t(152),h=s("toStringTag"),v=l.set,m=function(n){var e=l.getterFor(n?"WrapForValidIterator":"IteratorHelper");return a(i(u),{next:function(){var t=e(this);if(n)return t.nextHandler();if(t.done)return p(void 0,!0);try{var r=t.nextHandler();return t.returnHandlerResult?r:p(r,t.done)}catch(n){throw t.done=!0,n}},return:function(){var t=e(this),i=t.iterator;if(t.done=!0,n){var o=c(i,"return");return o?r(o,i):p(void 0,!0)}if(t.inner)try{d(t.inner.iterator,"normal")}catch(n){return d(i,"throw",n)}if(t.openIters)try{f(t.openIters,"normal")}catch(n){return d(i,"throw",n)}return i&&d(i,"normal"),p(void 0,!0)}})},g=m(!0),y=m(!1);o(y,h,"Iterator Helper"),n.exports=function(n,e,t){var r=function(r,i){i?(i.iterator=r.iterator,i.next=r.next):i=r,i.type=e?"WrapForValidIterator":"IteratorHelper",i.returnHandlerResult=!!t,i.nextHandler=n,i.counter=0,i.done=!1,v(this,i)};return r.prototype=e?g:y,r}},function(n,e,t){"use strict";var r=t(4),i=t(12);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";n.exports=function(n,e){var t="function"==typeof Iterator&&Iterator.prototype[n];if(t)try{t.call({next:null},e).next()}catch(n){return!0}}},function(n,e,t){"use strict";n.exports={}},function(n,e,t){"use strict";var r=t(94),i=t(39),o=t(49),a=t(92),s=t(17)("iterator");n.exports=function(n){if(!o(n))return i(n,s)||i(n,"@@iterator")||a[r(n)]}},function(n,e,t){"use strict";var r=t(161),i=t(2),o=t(29),a=t(17)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),a))?t:l?o(e):"Object"===(r=o(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){"use strict";var r=t(34),i=Function.prototype,o=i.apply,a=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?a.bind(o):function(){return a.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(165),i=t(9),o=t(48),a=t(166);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),a(r),i(t)?(e?n(t,r):t.__proto__=r,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(40),i=t(191),o=t(192),a=t(193),s=t(194),l=t(195);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(28),i=t(58);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(212),i=t(23);n.exports=function n(e,t,o,a,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,o,a,n,s))}},function(n,e,t){var r=t(105),i=t(215),o=t(106);n.exports=function(n,e,t,a,s,l){var c=1&t,u=n.length,p=e.length;if(u!=p&&!(c&&p>u))return!1;var d=l.get(n),f=l.get(e);if(d&&f)return d==e&&f==n;var h=-1,v=!0,m=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var g=n[h],y=e[h];if(a)var b=c?a(y,g,h,e,n,l):a(g,y,h,n,e,l);if(void 0!==b){if(b)continue;v=!1;break}if(m){if(!i(e,(function(n,e){if(!o(m,e)&&(g===n||s(g,n,t,a,l)))return m.push(e)}))){v=!1;break}}else if(g!==y&&!s(g,y,t,a,l)){v=!1;break}}return l.delete(n),l.delete(e),v}},function(n,e,t){var r=t(59),i=t(213),o=t(214);function a(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}a.prototype.add=a.prototype.push=i,a.prototype.has=o,n.exports=a},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(225),i=t(231),o=t(111);n.exports=function(n){return o(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(14),i=t(227),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(68)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(228),i=t(229),o=t(230),a=o&&o.isTypedArray,s=a?i(a):r;n.exports=s},function(n,e,t){var r=t(101),i=t(61);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(20)(t(14),"Set");n.exports=r},function(n,e,t){var r=t(58);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(116),i=t(44);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[i(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(13),i=t(62),o=t(242),a=t(245);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:o(a(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(178),i=t(183),o=t(254),a=t(262),s=t(271),l=t(128),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),a(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var o="",a=0,s=0;for(a=i.index;a<t.length;a++){switch(t.charCodeAt(a)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==a&&(o+=t.substring(s,a)),s=a+1,o+=e}return s!==a?o+t.substring(s,a):o}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(274),t(15)),o=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);t(3),t(16),t(18),t(22);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(275),t(15)),o=Object(i.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var r=t(94),i=String;n.exports=function(n){if("Symbol"===r(n))throw new TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){"use strict";var r=t(82),i=t(19);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){"use strict";var r=t(158),i=t(8),o=t(34),a=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:o?a(n,e):function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(280)},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!r.call({1:2},1);e.f=o?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){"use strict";var r=t(7),i=t(9),o=t(72),a=t(39),s=t(132),l=t(17),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!i(n)||o(n))return n;var t,l=a(n,u);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!i(t)||o(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";var r=t(7),i=t(2),o=t(9),a=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&i(t=n.toString)&&!o(s=r(t,n)))return s;if(i(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&i(t=n.toString)&&!o(s=r(t,n)))return s;throw new a("Can't convert object to primitive value")}},function(n,e,t){"use strict";var r=t(6),i=t(10),o=Function.prototype,a=r&&Object.getOwnPropertyDescriptor,s=i(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&a(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var r=t(5),i=t(2),o=t(51),a=r(Function.toString);i(o.inspectSource)||(o.inspectSource=function(n){return a(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var r=t(0),i=t(2),o=r.WeakMap;n.exports=i(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var r=t(37),i=t(5),o=t(137),a=t(142),s=t(4),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=a.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r=t(85),i=t(55).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(36),i=t(139),o=t(33),a=function(n){return function(e,t,a){var s=r(e),l=o(s);if(0===l)return!n&&-1;var c,u=i(a,l);if(n&&t!=t){for(;l>u;)if((c=s[u++])!=c)return!0}else for(;l>u;u++)if((n||u in s)&&s[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,e,t){"use strict";var r=t(86),i=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):o(t,e)}},function(n,e,t){"use strict";var r=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:r)(e)}},function(n,e,t){"use strict";var r=t(86),i=Math.min;n.exports=function(n){var e=r(n);return e>0?i(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var r=t(1),i=t(2),o=/#|\.prototype\./,a=function(n,e){var t=l[s(n)];return t===u||t!==c&&(i(e)?r(e):!!e)},s=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=a.data={},c=a.NATIVE="N",u=a.POLYFILL="P";n.exports=a},function(n,e,t){"use strict";var r=t(38),i=TypeError;n.exports=function(n,e){if(r(e,n))return n;throw new i("Incorrect invocation")}},function(n,e,t){"use strict";var r=t(1);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var r=t(6),i=t(19),o=t(35);n.exports=function(n,e,t){r?i.f(n,e,o(0,t)):n[e]=t}},function(n,e,t){"use strict";var r=t(6),i=t(81),o=t(19),a=t(4),s=t(36),l=t(148);e.f=r&&!i?Object.defineProperties:function(n,e){a(n);for(var t,r=s(e),i=l(e),c=i.length,u=0;c>u;)o.f(n,t=i[u++],r[t]);return n}},function(n,e,t){"use strict";var r=t(85),i=t(55);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){"use strict";var r=t(37);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(46);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e,t){"use strict";n.exports=function(n,e){return{value:n,done:e}}},function(n,e,t){"use strict";var r=t(12);n.exports=function(n,e,t){for(var i=n.length-1;i>=0;i--)if(void 0!==n[i])try{t=r(n[i].iterator,e,t)}catch(n){e="throw",t=n}if("throw"===e)throw t;return t}},function(n,e,t){"use strict";var r=t(11),i=t(154).left,o=t(155),a=t(75);r({target:"Array",proto:!0,forced:!t(156)&&a>79&&a<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(8),i=t(32),o=t(66),a=t(33),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,u){var p=i(e),d=o(p),f=a(p);if(r(t),0===f&&c<2)throw new s(l);var h=n?f-1:0,v=n?-1:1;if(c<2)for(;;){if(h in d){u=d[h],h+=v;break}if(h+=v,n?h<0:f<=h)throw new s(l)}for(;n?h>=0:f>h;h+=v)h in d&&(u=t(u,d[h],h,p));return u}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r=t(1);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(157);n.exports="NODE"===r},function(n,e,t){"use strict";var r=t(0),i=t(76),o=t(29),a=function(n){return i.slice(0,n.length)===n};n.exports=a("Bun/")?"BUN":a("Cloudflare-Workers")?"CLOUDFLARE":a("Deno/")?"DENO":a("Node.js/")?"NODE":r.Bun&&"string"==typeof Bun.version?"BUN":r.Deno&&"object"==typeof Deno.version?"DENO":"process"===o(r.process)?"NODE":r.window&&r.document?"BROWSER":"REST"},function(n,e,t){"use strict";var r=t(29),i=t(5);n.exports=function(n){if("Function"===r(n))return i(n)}},function(n,e,t){"use strict";var r=t(17),i=t(92),o=r("iterator"),a=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||a[o]===n)}},function(n,e,t){"use strict";var r=t(7),i=t(8),o=t(4),a=t(50),s=t(93),l=TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return o(r(t,n));throw new l(a(n)+" is not iterable")}},function(n,e,t){"use strict";var r={};r[t(17)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){"use strict";var r=t(11),i=t(47),o=t(8),a=t(4),s=t(26),l=t(12),c=t(27),u=t(95),p=t(1),d=TypeError,f=p((function(){[].keys().reduce((function(){}),void 0)})),h=!f&&c("reduce",d);r({target:"Iterator",proto:!0,real:!0,forced:f||h},{reduce:function(n){a(this);try{o(n)}catch(n){l(this,"throw",n)}var e=arguments.length<2,t=e?void 0:arguments[1];if(h)return u(h,this,e?[n]:[n,t]);var r=s(this),c=0;if(i(r,(function(r){e?(e=!1,t=r):t=n(t,r,c),c++}),{IS_RECORD:!0}),e)throw new d("Reduce of empty iterator with no initial value");return t}})},function(n,e,t){"use strict";var r=t(11),i=t(0),o=t(95),a=t(164),s=i.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=a(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=a("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var r=t(37),i=t(10),o=t(25),a=t(38),s=t(96),l=t(84),c=t(168),u=t(169),p=t(170),d=t(171),f=t(172),h=t(6),v=t(24);n.exports=function(n,e,t,m){var g=m?2:1,y=n.split("."),b=y[y.length-1],x=r.apply(null,y);if(x){var _=x.prototype;if(!v&&i(_,"cause")&&delete _.cause,!t)return x;var w=r("Error"),k=e((function(n,e){var t=p(m?e:n,void 0),r=m?new x(n):new x;return void 0!==t&&o(r,"message",t),f(r,k,r.stack,2),this&&a(_,this)&&u(r,this,k),arguments.length>g&&d(r,arguments[g]),r}));if(k.prototype=_,"Error"!==b?s?s(k,w):l(k,w,{name:!0}):h&&"stackTraceLimit"in x&&(c(k,x,"stackTraceLimit"),c(k,x,"prepareStackTrace")),l(k,x),!v)try{_.name!==b&&o(_,"name",b),_.constructor=k}catch(n){}return k}}},function(n,e,t){"use strict";var r=t(5),i=t(8);n.exports=function(n,e,t){try{return r(i(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var r=t(167),i=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw new o("Can't set "+i(n)+" as a prototype")}},function(n,e,t){"use strict";var r=t(9);n.exports=function(n){return r(n)||null===n}},function(n,e,t){"use strict";var r=t(19).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(2),i=t(9),o=t(96);n.exports=function(n,e,t){var a,s;return o&&r(a=e.constructor)&&a!==t&&i(s=a.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var r=t(125);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(9),i=t(25);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){"use strict";var r=t(25),i=t(173),o=t(174),a=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(a?a(n,e):r(n,"stack",i(t,s)))}},function(n,e,t){"use strict";var r=t(5),i=Error,o=r("".replace),a=String(new i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(a);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var r=t(1),i=t(35);n.exports=!r((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(6),i=t(176),o=TypeError,a=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(i(n)&&!a(n,"length").writable)throw new o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var r=t(29);n.exports=Array.isArray||function(n){return"Array"===r(n)}},function(n,e,t){"use strict";var r=TypeError;n.exports=function(n){if(n>9007199254740991)throw r("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(97),i=t(179);n.exports=function n(e,t,o,a,s){var l=-1,c=e.length;for(o||(o=i),s||(s=[]);++l<c;){var u=e[l];t>0&&o(u)?t>1?n(u,t-1,o,a,s):r(s,u):a||(s[s.length]=u)}return s}},function(n,e,t){var r=t(30),i=t(56),o=t(13),a=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||i(n)||!!(a&&n&&n[a])}},function(n,e,t){var r=t(28),i=t(23);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(30),i=Object.prototype,o=i.hasOwnProperty,a=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=a.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(184),i=t(240),o=t(64),a=t(13),s=t(251);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?a(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(185),i=t(239),o=t(114);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(99),i=t(103);n.exports=function(n,e,t,o){var a=t.length,s=a,l=!o;if(null==n)return!s;for(n=Object(n);a--;){var c=t[a];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++a<s;){var u=(c=t[a])[0],p=n[u],d=c[1];if(l&&c[2]){if(void 0===p&&!(u in n))return!1}else{var f=new r;if(o)var h=o(p,d,u,n,e,f);if(!(void 0===h?i(d,p,3,o,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(41),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(41);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(41);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(41);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(40);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(40),i=t(57),o=t(59);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var a=t.__data__;if(!i||a.length<199)return a.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(a)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(101),i=t(197),o=t(58),a=t(102),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,p=c.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||i(n))&&(r(n)?d:s).test(a(n))}},function(n,e,t){var r,i=t(198),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(14)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(201),i=t(40),o=t(57);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(n,e,t){var r=t(202),i=t(203),o=t(204),a=t(205),s=t(206);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(42);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(42),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(42);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(43);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(43);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(43);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(99),i=t(104),o=t(216),a=t(219),s=t(235),l=t(13),c=t(108),u=t(110),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,v){var m=l(n),g=l(e),y=m?"[object Array]":s(n),b=g?"[object Array]":s(e),x=(y="[object Arguments]"==y?p:y)==p,_=(b="[object Arguments]"==b?p:b)==p,w=y==b;if(w&&c(n)){if(!c(e))return!1;m=!0,x=!1}if(w&&!x)return v||(v=new r),m||u(n)?i(n,e,t,f,h,v):o(n,e,y,t,f,h,v);if(!(1&t)){var k=x&&d.call(n,"__wrapped__"),E=_&&d.call(e,"__wrapped__");if(k||E){var T=k?n.value():n,O=E?e.value():e;return v||(v=new r),h(T,O,t,f,v)}}return!!w&&(v||(v=new r),a(n,e,t,f,h,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(30),i=t(217),o=t(100),a=t(104),s=t(218),l=t(60),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var v=d.get(n);if(v)return v==e;r|=2,d.set(n,e);var m=a(f(n),f(e),r,c,p,d);return d.delete(n),m;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(14).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(220),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,a,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var p=u;p--;){var d=c[p];if(!(l?d in e:i.call(e,d)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var v=!0;s.set(n,e),s.set(e,n);for(var m=l;++p<u;){var g=n[d=c[p]],y=e[d];if(o)var b=l?o(y,g,d,e,n,s):o(g,y,d,n,e,s);if(!(void 0===b?g===y||a(g,y,t,o,s):b)){v=!1;break}m||(m="constructor"==d)}if(v&&!m){var x=n.constructor,_=e.constructor;x==_||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof _&&_ instanceof _||(v=!1)}return s.delete(n),s.delete(e),v}},function(n,e,t){var r=t(221),i=t(222),o=t(107);n.exports=function(n){return r(n,o,i)}},function(n,e,t){var r=t(97),i=t(13);n.exports=function(n,e,t){var o=e(n);return i(n)?o:r(o,t(n))}},function(n,e,t){var r=t(223),i=t(224),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(n){return null==n?[]:(n=Object(n),r(a(n),(function(e){return o.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,o=[];++t<r;){var a=n[t];e(a,t,n)&&(o[i++]=a)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(226),i=t(56),o=t(13),a=t(108),s=t(109),l=t(110),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),u=!t&&i(n),p=!t&&!u&&a(n),d=!t&&!u&&!p&&l(n),f=t||u||p||d,h=f?r(n.length,String):[],v=h.length;for(var m in n)!e&&!c.call(n,m)||f&&("length"==m||p&&("offset"==m||"parent"==m)||d&&("buffer"==m||"byteLength"==m||"byteOffset"==m)||s(m,v))||h.push(m);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(28),i=t(61),o=t(23),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&i(n.length)&&!!a[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(98),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,a=o&&o.exports===i&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=s}).call(this,t(68)(n))},function(n,e,t){var r=t(232),i=t(233),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(234)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(236),i=t(57),o=t(237),a=t(112),s=t(238),l=t(28),c=t(102),u=c(r),p=c(i),d=c(o),f=c(a),h=c(s),v=l;(r&&"[object DataView]"!=v(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=v(new i)||o&&"[object Promise]"!=v(o.resolve())||a&&"[object Set]"!=v(new a)||s&&"[object WeakMap]"!=v(new s))&&(v=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var r=t(20)(t(14),"DataView");n.exports=r},function(n,e,t){var r=t(20)(t(14),"Promise");n.exports=r},function(n,e,t){var r=t(20)(t(14),"WeakMap");n.exports=r},function(n,e,t){var r=t(113),i=t(107);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var o=e[t],a=n[o];e[t]=[o,a,r(a)]}return e}},function(n,e,t){var r=t(103),i=t(241),o=t(248),a=t(62),s=t(113),l=t(114),c=t(44);n.exports=function(n,e){return a(n)&&s(e)?l(c(n),e):function(t){var a=i(t,n);return void 0===a&&a===e?o(t,n):r(e,a,3)}}},function(n,e,t){var r=t(115);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(243),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(o,"$1"):t||n)})),e}));n.exports=a},function(n,e,t){var r=t(244);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(59);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],o=t.cache;if(o.has(i))return o.get(i);var a=n.apply(this,r);return t.cache=o.set(i,a)||o,a};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(246);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(30),i=t(247),o=t(13),a=t(63),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return i(e,n)+"";if(a(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(249),i=t(250);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(116),i=t(56),o=t(13),a=t(109),s=t(61),l=t(44);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,p=!1;++c<u;){var d=l(e[c]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++c!=u?p:!!(u=null==n?0:n.length)&&s(u)&&a(d,u)&&(o(n)||i(n))}},function(n,e,t){var r=t(252),i=t(253),o=t(62),a=t(44);n.exports=function(n){return o(n)?r(a(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(115);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(64),i=t(255),o=t(257);n.exports=function(n,e){return o(i(n,e,r),n+"")}},function(n,e,t){var r=t(256),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var o=arguments,a=-1,s=i(o.length-e,0),l=Array(s);++a<s;)l[a]=o[e+a];a=-1;for(var c=Array(e+1);++a<e;)c[a]=o[a];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(258),i=t(261)(r);n.exports=i},function(n,e,t){var r=t(259),i=t(260),o=t(64),a=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=a},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(20),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),o=16-(i-r);if(r=i,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(105),i=t(263),o=t(268),a=t(106),s=t(269),l=t(60);n.exports=function(n,e,t){var c=-1,u=i,p=n.length,d=!0,f=[],h=f;if(t)d=!1,u=o;else if(p>=200){var v=e?null:s(n);if(v)return l(v);d=!1,u=a,h=new r}else h=e?[]:f;n:for(;++c<p;){var m=n[c],g=e?e(m):m;if(m=t||0!==m?m:0,d&&g==g){for(var y=h.length;y--;)if(h[y]===g)continue n;e&&h.push(g),f.push(m)}else u(h,g,t)||(h!==f&&h.push(g),f.push(m))}return f}},function(n,e,t){var r=t(264);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(265),i=t(266),o=t(267);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,o=t+(r?1:-1);r?o--:++o<i;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(112),i=t(270),o=t(60),a=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=a},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(111),i=t(23);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(117)},function(n,e,t){"use strict";t(118)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(119)},function(n,e,t){"use strict";t(120)},function(n,e,t){"use strict";t.r(e);t(3),t(16),t(22);var r=Object.freeze({}),i=Array.isArray;function o(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function f(n){return"[object RegExp]"===p.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function v(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function m(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,g,2):String(n)}function g(n,e){return e&&e.__v_isRef?e.value:e}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var x=b("key,ref,slot,slot-scope,is");function _(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,O=E((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),j=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,C=E((function(n){return n.replace(S,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function z(n,e){for(var t in e)n[t]=e[t];return n}function $(n){for(var e={},t=0;t<n.length;t++)n[t]&&z(e,n[t]);return e}function L(n,e,t){}var P=function(n,e,t){return!1},B=function(n){return n};function N(n,e){if(n===e)return!0;var t=u(n),r=u(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),o=Array.isArray(e);if(i&&o)return n.length===e.length&&n.every((function(n,t){return N(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||o)return!1;var a=Object.keys(n),s=Object.keys(e);return a.length===s.length&&a.every((function(t){return N(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(N(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function M(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:L,parsePlatformTagName:B,mustUseProp:P,async:!0,_lifecycleHooks:F},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function G(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var W=new RegExp("[^".concat(H.source,".$_\\d]"));var K="__proto__"in{},Y="undefined"!=typeof window,J=Y&&window.navigator.userAgent.toLowerCase(),X=J&&/msie|trident/.test(J),Z=J&&J.indexOf("msie 9.0")>0,Q=J&&J.indexOf("edge/")>0;J&&J.indexOf("android");var nn=J&&/iphone|ipad|ipod|ios/.test(J);J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J);var en,tn=J&&J.match(/firefox\/(\d+)/),rn={}.watch,on=!1;if(Y)try{var an={};Object.defineProperty(an,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===en&&(en=!Y&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=Y&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var un,pn="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);un="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function fn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,i,o,a,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),vn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function mn(n){return new hn(void 0,void 0,void 0,String(n))}function gn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var yn=0,bn=[],xn=function(){function n(){this._pending=!1,this.id=yn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var _n=[];function wn(n){_n.push(n),xn.target=n}function kn(){_n.pop(),xn.target=_n[_n.length-1]}var En=Array.prototype,Tn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];G(Tn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,o=e.apply(this,t),a=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o}))}));var On=Object.getOwnPropertyNames(Tn),jn={},Sn=!0;function Cn(n){Sn=n}var In={notify:L,depend:L,addSub:L,removeSub:L},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new xn,this.vmCount=0,G(n,"__ob__",this),i(n)){if(!t)if(K)n.__proto__=Tn;else for(var r=0,o=On.length;r<o;r++){G(n,s=On[r],Tn[s])}e||this.observeArray(n)}else{var a=Object.keys(n);for(r=0;r<a.length;r++){var s;$n(n,s=a[r],jn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)zn(n[e],!1,this.mock)},n}();function zn(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!Sn||!t&&sn()||!i(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Mn(n)||n instanceof hn?void 0:new An(n,e,t)}function $n(n,e,t,r,o,a,s){void 0===s&&(s=!1);var l=new xn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var u=c&&c.get,p=c&&c.set;u&&!p||t!==jn&&2!==arguments.length||(t=n[e]);var d=o?t&&t.__ob__:zn(t,!1,a);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=u?u.call(n):t;return xn.target&&(l.depend(),d&&(d.dep.depend(),i(e)&&Bn(e))),Mn(e)&&!o?e.value:e},set:function(e){var r=u?u.call(n):t;if(M(r,e)){if(p)p.call(n,e);else{if(u)return;if(!o&&Mn(r)&&!Mn(e))return void(r.value=e);t=e}d=o?e&&e.__ob__:zn(e,!1,a),l.notify()}}}),l}}function Ln(n,e,t){if(!Dn(n)){var r=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&zn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?($n(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Pn(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Bn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Bn(e)}function Nn(n){return Rn(n,!0),G(n,"__v_isShallow",!0),n}function Rn(n,e){if(!Dn(n)){zn(n,e,sn());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Mn(n){return!(!n||!0!==n.__v_isRef)}function Un(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Mn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Mn(r)&&!Mn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var qn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Hn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function Gn(n,e){function t(){var n=t.fns;if(!i(n))return Se(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)Se(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Wn(n,e,t,r,i,a){var l,c,u,p;for(l in n)c=n[l],u=e[l],p=Vn(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=Gn(c,a)),s(p.once)&&(c=n[l]=i(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&r((p=Vn(l)).name,e[l],p.capture)}function Kn(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),_(r.fns,l)}o(i)?r=Gn([l]):a(i.fns)&&s(i.merged)?(r=i).fns.push(l):r=Gn([i,l]),r.merged=!0,n[e]=r}function Yn(n,e,t,r,i){if(a(e)){if(k(e,t))return n[t]=e[t],i||delete e[t],!0;if(k(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function Jn(n){return l(n)?[mn(n)]:i(n)?function n(e,t){var r,c,u,p,d=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(u=d.length-1,p=d[u],i(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Xn(p)&&(d[u]=mn(p.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Xn(p)?d[u]=mn(p.text+c):""!==c&&d.push(mn(c)):Xn(c)&&Xn(p)?d[u]=mn(p.text+c.text):(s(e._isVList)&&a(c.tag)&&o(c.key)&&a(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Xn(n){return a(n)&&a(n.text)&&!1===n.isComment}function Zn(n,e){var t,r,o,s,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)l.push(e(p.value,l.length)),p=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],l[t]=e(n[s],s,t);return a(l)||(l=[]),l._isVList=!0,l}function Qn(n,e,t,r){var i,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=z(z({},r),t)),i=o(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var a=t&&t.slot;return a?this.$createElement("template",{slot:a},i):i}function ne(n){return At(this.$options,"filters",n,!0)||B}function ee(n,e){return i(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,r,i){var o=q.keyCodes[e]||t;return i&&r&&!q.keyCodes[e]?ee(i,r):o?ee(o,n):r?C(r)!==e:void 0===n}function re(n,e,t,r,o){if(t)if(u(t)){i(t)&&(t=$(t));var a=void 0,s=function(i){if("class"===i||"style"===i||x(i))a=n;else{var s=n.attrs&&n.attrs.type;a=r||q.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=O(i),c=C(i);l in a||c in a||(a[i]=t[i],o&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)s(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function oe(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(i(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(d(e)){var t=n.on=n.on?z({},n.on):{};for(var r in e){var i=t[r],o=e[r];t[r]=i?[].concat(i,o):o}}else;return n}function ce(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];i(a)?ce(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=oe,n._n=y,n._s=m,n._l=Zn,n._t=Qn,n._q=N,n._i=R,n._m=ie,n._f=ne,n._k=te,n._b=re,n._v=mn,n._e=vn,n._u=ce,n._g=le,n._d=ue,n._p=pe}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var o=n[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==e&&o.fnContext!==e||!a||null==a.slot)(t.default||(t.default=[])).push(o);else{var s=a.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function me(n,e,t,i){var o,a=Object.keys(t).length>0,s=e?!!e.$stable:!a,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&i&&i!==r&&l===i.$key&&!a&&!i.$hasNormal)return i;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ge(n,t,c,e[c]))}else o={};for(var u in t)u in o||(o[u]=ye(t,u));return e&&Object.isExtensible(e)&&(e._normalized=o),G(o,"$stable",s),G(o,"$key",l),G(o,"$hasNormal",a),o}function ge(n,e,t,r){var o=function(){var e=dn;fn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!i(t)?[t]:Jn(t))&&t[0];return fn(e),t&&(!o||1===t.length&&o.isComment&&!ve(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ye(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};G(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Un(n,e,t)}))}}}function xe(n,e,t,r,i){var o=!1;for(var a in e)a in n?e[a]!==t[a]&&(o=!0):(o=!0,_e(n,a,r,i));for(var a in n)a in e||(o=!0,delete n[a]);return o}function _e(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function Ee(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Te(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||ve(t)))return t}}function Oe(n,e,t,r,p,d){return(i(t)||l(t))&&(p=r,r=t,t=void 0),s(d)&&(p=2),function(n,e,t,r,l){if(a(t)&&a(t.__ob__))return vn();a(t)&&a(t.is)&&(e=t.is);if(!e)return vn();0;i(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Jn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var p,d;if("string"==typeof e){var f=void 0;d=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),p=q.isReservedTag(e)?new hn(q.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!a(f=At(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):_t(f,t,n,r,e)}else p=_t(e,t,n,r);return i(p)?p:a(p)?(a(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(a(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];a(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(p,d),a(t)&&function(n){u(n.style)&&qe(n.style);u(n.class)&&qe(n.class)}(t),p):vn()}(n,e,t,r,p)}function je(n,e,t){wn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,n,e,t))return}catch(n){Ce(n,r,"errorCaptured hook")}}Ce(n,e,t)}finally{kn()}}function Se(n,e,t,r,i){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&v(o)&&!o._handled&&(o.catch((function(n){return je(n,r,i+" (Promise/async)")})),o._handled=!0)}catch(n){je(n,r,i)}return o}function Ce(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!Y||"undefined"==typeof console)throw n;console.error(n)}var Ae,ze=!1,$e=[],Le=!1;function Pe(){Le=!1;var n=$e.slice(0);$e.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Be=Promise.resolve();Ae=function(){Be.then(Pe),nn&&setTimeout(L)},ze=!0}else if(X||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Pe)}:function(){setTimeout(Pe,0)};else{var Ne=1,Re=new MutationObserver(Pe),De=document.createTextNode(String(Ne));Re.observe(De,{characterData:!0}),Ae=function(){Ne=(Ne+1)%2,De.data=String(Ne)},ze=!0}function Me(n,e){var t;if($e.push((function(){if(n)try{n.call(e)}catch(n){je(n,e,"nextTick")}else t&&t(e)})),Le||(Le=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ue(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=jt(r[e],t)}(t,n,e)}}Ue("beforeMount"),Ue("mounted"),Ue("beforeUpdate"),Ue("updated"),Ue("beforeDestroy"),Ue("destroyed"),Ue("activated"),Ue("deactivated"),Ue("serverPrefetch"),Ue("renderTracked"),Ue("renderTriggered"),Ue("errorCaptured");var Fe=new un;function qe(n){return function n(e,t){var r,o,a=i(e);if(!a&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(a)for(r=e.length;r--;)n(e[r],t);else if(Mn(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,Fe),Fe.clear(),n}var He,Ve=0,Ge=function(){function n(n,e,t,r,i){var o,a;o=this,void 0===(a=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(a=Fn),a&&a.active&&a.effects.push(o),(this.vm=n)&&i&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new un,this.newDepIds=new un,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!W.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;je(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ft(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Se(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&_(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function We(n,e){He.$on(n,e)}function Ke(n,e){He.$off(n,e)}function Ye(n,e){var t=He;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Je(n,e,t){He=n,Wn(e,t||{},We,Ke,Ye,n),He=void 0}var Xe=null;function Ze(n){var e=Xe;return Xe=n,function(){Xe=e}}function Qe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Qe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,r){void 0===r&&(r=!0),wn();var i=dn,o=Fn;r&&fn(n);var a=n.$options[e],s="".concat(e," hook");if(a)for(var l=0,c=a.length;l<c;l++)Se(a[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&(fn(i),o&&o.on()),kn()}var tt=[],rt=[],it={},ot=!1,at=!1,st=0;var lt=0,ct=Date.now;if(Y&&!X){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(lt=ct(),at=!0,tt.sort(pt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,it={},ot=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),ln&&q.devtools&&ln.emit("flush")}function ft(n){var e=n.id;if(null==it[e]&&(n!==xn.target||!n.noRecurse)){if(it[e]=!0,at){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);ot||(ot=!0,Me(dt))}}function ht(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){var a=n[o].from;if(a in e._provided)t[o]=e._provided[a];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function vt(n,e,t,o,a){var l,c=this,u=a.options;k(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var p=s(u._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=ht(u.inject,o),this.slots=function(){return c.$slots||me(o,n.scopedSlots,c.$slots=fe(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return me(o,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=me(o,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,r){var a=Oe(l,n,e,t,r,d);return a&&!i(a)&&(a.fnScopeId=u._scopeId,a.fnContext=o),a}:this._c=function(n,e,t,r){return Oe(l,n,e,t,r,d)}}function mt(n,e,t,r,i){var o=gn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function gt(n,e){for(var t in e)n[O(t)]=e[t]}function yt(n){return n.name||n.__name||n._componentTag}de(vt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;a(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,o){var a=i.data.scopedSlots,s=n.$scopedSlots,l=!!(a&&!a.$stable||s!==r&&!s.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=o;var p=i.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,p,u.data&&u.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=p,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Je(n,t,d),e&&n.$options.props){Cn(!1);for(var f=n._props,h=n.$options._propKeys||[],v=0;v<h.length;v++){var m=h[v],g=n.$options.props;f[m]=zt(m,g,e,n)}Cn(!0),n.$options.propsData=e}c&&(n.$slots=fe(o,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Qe(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(bt);function _t(n,e,t,l,c){if(!o(n)){var p=t.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=ke;if(t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var r=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return _(r,t)}));var p=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=D((function(t){n.resolved=Ee(t,e),i?r.length=0:p(!0)})),f=D((function(e){a(n.errorComp)&&(n.error=!0,p(!0))})),h=n(d,f);return u(h)&&(v(h)?o(n.resolved)&&h.then(d,f):v(h.component)&&(h.component.then(d,f),a(h.error)&&(n.errorComp=Ee(h.error,e)),a(h.loading)&&(n.loadingComp=Ee(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),h.delay||200)),a(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&f(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,r,i){var o=vn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:i},o}(d,e,t,l,c);e=e||{},Gt(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],l=e.model.callback;a(s)?(i(s)?-1===s.indexOf(l):s!==l)&&(o[r]=[l].concat(s)):o[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!o(r)){var i={},s=n.attrs,l=n.props;if(a(s)||a(l))for(var c in r){var u=C(c);Yn(i,l,c,u,!0)||Yn(i,s,c,u,!1)}return i}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},u=l.props;if(a(u))for(var p in u)c[p]=zt(p,u,e||r);else a(t.attrs)&&gt(c,t.attrs),a(t.props)&&gt(c,t.props);var d=new vt(t,c,s,o,n),f=l.render.call(null,d._c,d);if(f instanceof hn)return mt(f,t,d.parent,l,d);if(i(f)){for(var h=Jn(f)||[],v=new Array(h.length),m=0;m<h.length;m++)v[m]=mt(h[m],t,d.parent,l,d);return v}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],i=e[r],o=bt[r];i===o||i&&i._merged||(e[r]=i?wt(o,i):o)}}(e);var g=yt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:c,children:l},d)}}}function wt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var kt=L,Et=q.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,i,o,a=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(r=a[s])&&(i=n[r],o=e[r],t&&k(n,r)?i!==o&&d(i)&&d(o)&&Tt(i,o):Ln(n,r,o));return n}function Ot(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return r?Tt(r,i):i}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function jt(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,r){var i=Object.create(n||null);return e?z(i,e):i}Et.data=function(n,e,t){return t?Ot(n,e,t):e&&"function"!=typeof e?n:Ot(n,e)},F.forEach((function(n){Et[n]=jt})),U.forEach((function(n){Et[n+"s"]=St})),Et.watch=function(n,e,t,r){if(n===rn&&(n=void 0),e===rn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in z(o,n),e){var s=o[a],l=e[a];s&&!i(s)&&(s=[s]),o[a]=s?s.concat(l):i(l)?l:[l]}return o},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return z(i,n),e&&z(i,e),i},Et.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,a={};if(i(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(a[O(o)]={type:null});else if(d(t))for(var s in t)o=t[s],a[O(s)]=d(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(i(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var a in t){var s=t[a];r[a]=d(s)?z({from:a},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=It(n,e.mixins[r],t);var a,s={};for(a in n)l(a);for(a in e)k(n,a)||l(a);function l(r){var i=Et[r]||Ct;s[r]=i(n[r],e[r],t,r)}return s}function At(n,e,t,r){if("string"==typeof t){var i=n[e];if(k(i,t))return i[t];var o=O(t);if(k(i,o))return i[o];var a=j(o);return k(i,a)?i[a]:i[t]||i[o]||i[a]}}function zt(n,e,t,r){var i=e[n],o=!k(t,n),a=t[n],s=Bt(Boolean,i.type);if(s>-1)if(o&&!k(i,"default"))a=!1;else if(""===a||a===C(n)){var l=Bt(String,i.type);(l<0||s<l)&&(a=!0)}if(void 0===a){a=function(n,e,t){if(!k(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Lt(e.type)?r.call(n):r}(r,i,n);var u=Sn;Cn(!0),zn(a),Cn(u)}return a}var $t=/^\s*function (\w+)/;function Lt(n){var e=n&&n.toString().match($t);return e?e[1]:""}function Pt(n,e){return Lt(n)===Lt(e)}function Bt(n,e){if(!i(e))return Pt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Pt(e[t],n))return t;return-1}var Nt={enumerable:!0,configurable:!0,get:L,set:L};function Rt(n,e,t){Nt.get=function(){return this[e][t]},Nt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Nt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Nn({}),i=n.$options._propKeys=[];n.$parent&&Cn(!1);var o=function(o){i.push(o);var a=zt(o,e,t,n);$n(r,o,a,void 0,!0),o in n||Rt(n,"_props",o)};for(var a in e)o(a);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);fn(n),wn();var i=Se(t,null,[n._props||Nn({}),r],n,"setup");if(kn(),fn(),c(i))e.render=i;else if(u(i))if(n._setupState=i,i.__sfc){var o=n._setupProxy={};for(var a in i)"__sfc"!==a&&Un(o,i,a)}else for(var a in i)V(a)||Un(n,i,a);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return je(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var o=t[i];0,r&&k(r,o)||V(o)||Rt(n,"_data",o)}var a=zn(e);a&&a.vmCount++}(n);else{var t=zn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=sn();for(var i in e){var o=e[i],a=c(o)?o:o.get;0,r||(t[i]=new Ge(n,a||L,L,Mt)),i in n||Ut(n,i,o)}}(n,e.computed),e.watch&&e.watch!==rn&&function(n,e){for(var t in e){var r=e[t];if(i(r))for(var o=0;o<r.length;o++)Ht(n,t,r[o]);else Ht(n,t,r)}}(n,e.watch)}var Mt={lazy:!0};function Ut(n,e,t){var r=!sn();c(t)?(Nt.get=r?Ft(e):qt(t),Nt.set=L):(Nt.get=t.get?r&&!1!==t.cache?Ft(e):qt(t.get):L,Nt.set=t.set||L),Object.defineProperty(n,e,Nt)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Ht(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function Gt(n){var e=n.options;if(n.super){var t=Gt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&z(n.extendOptions,r),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Wt(n){this._init(n)}function Kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var o=yt(n)||yt(t.options);var a=function(n){this._init(n)};return(a.prototype=Object.create(t.prototype)).constructor=a,a.cid=e++,a.options=It(t.options,n),a.super=t,a.options.props&&function(n){var e=n.options.props;for(var t in e)Rt(n.prototype,"_props",t)}(a),a.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ut(n.prototype,t,e[t])}(a),a.extend=t.extend,a.mixin=t.mixin,a.use=t.use,U.forEach((function(n){a[n]=t[n]})),o&&(a.options.components[o]=a),a.superOptions=t.options,a.extendOptions=n,a.sealedOptions=z({},a.options),i[r]=a,a}}function Yt(n){return n&&(yt(n.Ctor.options)||n.tag)}function Jt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Xt(n,e){var t=n.cache,r=n.keys,i=n._vnode,o=n.$vnode;for(var a in t){var s=t[a];if(s){var l=s.name;l&&!e(l)&&Zt(t,a,r,i)}}o.componentOptions.children=void 0}function Zt(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,_(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Gt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Je(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=fe(e._renderChildren,i),n.$scopedSlots=t?me(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,i){return Oe(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Oe(n,e,t,r,i,!0)};var o=t&&t.data;$n(n,"$attrs",o&&o.attrs||r,null,!0),$n(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){$n(n,t,e[t])})),Cn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var r=Hn(n),i=pn?Reflect.ownKeys(t):Object.keys(t),o=0;o<i.length;o++){var a=i[o];Object.defineProperty(r,a,Object.getOwnPropertyDescriptor(t,a))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Wt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Ln,n.prototype.$delete=Pn,n.prototype.$watch=function(n,e,t){if(d(e))return Ht(this,n,e,t);(t=t||{}).user=!0;var r=new Ge(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');wn(),Se(e,this,[r.value],this,i),kn()}return function(){r.teardown()}}}(Wt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(i(n))for(var o=0,a=n.length;o<a;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var a,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((a=s[l])===e||a.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),i='event handler for "'.concat(n,'"'),o=0,a=t.length;o<a;o++)Se(t[o],e,r,e,i)}return e}}(Wt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,o=Ze(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var a=t;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||_(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Wt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return Me(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,r=e._parentVnode;r&&n._isMounted&&(n.$scopedSlots=me(n.$parent,r.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&we(n._slotsProxy,n.$scopedSlots)),n.$vnode=r;var o,a=dn,s=ke;try{fn(n),ke=n,o=t.call(n._renderProxy,n.$createElement)}catch(e){je(e,n,"render"),o=n._vnode}finally{ke=s,fn(a)}return i(o)&&1===o.length&&(o=o[0]),o instanceof hn||(o=vn()),o.parent=r,o}}(Wt);var Qt=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Qt,exclude:Qt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,o=t.componentInstance,a=t.componentOptions;n[r]={name:Yt(a),tag:i,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Jt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Jt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var r=Yt(t),i=this.include,o=this.exclude;if(i&&(!r||!Jt(i,r))||o&&r&&Jt(o,r))return e;var a=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;a[l]?(e.componentInstance=a[l].componentInstance,_(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:z,mergeOptions:It,defineReactive:$n},n.set=Ln,n.delete=Pn,n.nextTick=Me,n.observable=function(n){return zn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,z(n.options.components,nr),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),Kt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Wt),Object.defineProperty(Wt.prototype,"$isServer",{get:sn}),Object.defineProperty(Wt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Wt,"FunctionalRenderContext",{value:vt}),Wt.version="2.7.16";var er=b("style,class"),tr=b("input,textarea,option,select,progress"),rr=b("contenteditable,draggable,spellcheck"),ir=b("events,caret,typing,plaintext-only"),or=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ar="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},lr=function(n){return sr(n)?n.slice(6,n.length):""},cr=function(n){return null==n||!1===n};function ur(n){for(var e=n.data,t=n,r=n;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;a(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(a(n)||a(e))return dr(n,fr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:dr(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function dr(n,e){return n?e?n+" "+e:n:e||""}function fr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)a(e=fr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},vr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),mr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gr=function(n){return vr(n)||mr(n)};var yr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),_r={create:function(n,e){wr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wr(n,!0),wr(e))},destroy:function(n){wr(n,!0)}};function wr(n,e){var t=n.data.ref;if(a(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Se(t,r,[s],r,"template ref function");else{var u=n.data.refInFor,p="string"==typeof t||"number"==typeof t,d=Mn(t),f=r.$refs;if(p||d)if(u){var h=p?f[t]:t.value;e?i(h)&&_(h,o):i(h)?h.includes(o)||h.push(o):p?(f[t]=[o],kr(r,t,f[t])):t.value=[o]}else if(p){if(e&&f[t]!==o)return;f[t]=l,kr(r,t,s)}else if(d){if(e&&t.value!==o)return;t.value=s}else 0}}}function kr(n,e,t){var r=n._setupState;r&&k(r,e)&&(Mn(r[e])?r[e].value=t:r[e]=t)}var Er=new hn("",{},[]),Tr=["create","activate","update","remove","destroy"];function Or(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=a(t=n.data)&&a(t=t.attrs)&&t.type,i=a(t=e.data)&&a(t=t.attrs)&&t.type;return r===i||br(r)&&br(i)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function jr(n,e,t){var r,i,o={};for(r=e;r<=t;++r)a(i=n[r].key)&&(o[i]=r);return o}var Sr={create:Cr,update:Cr,destroy:function(n){Cr(n,Er)}};function Cr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,o=n===Er,a=e===Er,s=Ar(n.data.directives,n.context),l=Ar(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,$r(i,"update",e,n),i.def&&i.def.componentUpdated&&u.push(i)):($r(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var p=function(){for(var t=0;t<c.length;t++)$r(c[t],"inserted",e,n)};o?Kn(e,"insert",p):p()}u.length&&Kn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)$r(u[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||$r(s[t],"unbind",n,n,a)}(n,e)}var Ir=Object.create(null);function Ar(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Ir),i[zr(r)]=r,e._setupState&&e._setupState.__sfc){var o=r.def||At(e,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||At(e.$options,"directives",r.name)}return i}function zr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function $r(n,e,t,r,i){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,i)}catch(r){je(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Lr=[_r,Sr];function Pr(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,i,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(r in(a(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=z({},u)),u)i=u[r],c[r]!==i&&Br(l,r,i,e.data.pre);for(r in(X||Q)&&u.value!==c.value&&Br(l,"value",u.value),c)o(u[r])&&(sr(r)?l.removeAttributeNS(ar,lr(r)):rr(r)||l.removeAttribute(r))}}function Br(n,e,t,r){r||n.tagName.indexOf("-")>-1?Nr(n,e,t):or(e)?cr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):rr(e)?n.setAttribute(e,function(n,e){return cr(e)||"false"===e?"false":"contenteditable"===n&&ir(e)?e:"true"}(e,t)):sr(e)?cr(t)?n.removeAttributeNS(ar,lr(e)):n.setAttributeNS(ar,e,t):Nr(n,e,t)}function Nr(n,e,t){if(cr(t))n.removeAttribute(e);else{if(X&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Rr={create:Pr,update:Pr};function Dr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var s=ur(e),l=t._transitionClasses;a(l)&&(s=dr(s,fr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Mr,Ur={create:Dr,update:Dr};function Fr(n,e,t){var r=Mr;return function i(){var o=e.apply(null,arguments);null!==o&&Vr(n,i,t,r)}}var qr=ze&&!(tn&&Number(tn[1])<=53);function Hr(n,e,t,r){if(qr){var i=lt,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Mr.addEventListener(n,e,on?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||Mr).removeEventListener(n,e._wrapper||e,t)}function Gr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Mr=e.elm||n.elm,function(n){if(a(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Wn(t,r,Hr,Vr,Fr,e.context),Mr=void 0}}var Wr,Kr={create:Gr,update:Gr,destroy:function(n){return Gr(n,Er)}};function Yr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(a(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=z({},c)),l)t in c||(i[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var u=o(r)?"":String(r);Jr(i,u)&&(i.value=u)}else if("innerHTML"===t&&mr(i.tagName)&&o(i.innerHTML)){(Wr=Wr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var p=Wr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;p.firstChild;)i.appendChild(p.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(a(r)){if(r.number)return y(t)!==y(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xr={create:Yr,update:Yr},Zr=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Qr(n){var e=ni(n.style);return n.staticStyle?z(n.staticStyle,e):e}function ni(n){return Array.isArray(n)?$(n):"string"==typeof n?Zr(n):n}var ei,ti=/^--/,ri=/\s*!important$/,ii=function(n,e,t){if(ti.test(e))n.style.setProperty(e,t);else if(ri.test(t))n.style.setProperty(C(e),t.replace(ri,""),"important");else{var r=ai(e);if(Array.isArray(t))for(var i=0,o=t.length;i<o;i++)n.style[r]=t[i];else n.style[r]=t}},oi=["Webkit","Moz","ms"],ai=E((function(n){if(ei=ei||document.createElement("div").style,"filter"!==(n=O(n))&&n in ei)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<oi.length;t++){var r=oi[t]+e;if(r in ei)return r}}));function si(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var i,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},p=c||u,d=ni(e.data.style)||{};e.data.normalizedStyle=a(d.__ob__)?z({},d):d;var f=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Qr(i.data))&&z(r,t);(t=Qr(n.data))&&z(r,t);for(var o=n;o=o.parent;)o.data&&(t=Qr(o.data))&&z(r,t);return r}(e,!0);for(s in p)o(f[s])&&ii(l,s,"");for(s in f)i=f[s],ii(l,s,null==i?"":i)}}var li={create:si,update:si},ci=/\s+/;function ui(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ci).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function di(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&z(e,fi(n.name||"v")),z(e,n),e}return"string"==typeof n?fi(n):void 0}}var fi=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hi=Y&&!Z,vi="transition",mi="transitionend",gi="animation",yi="animationend";hi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(vi="WebkitTransition",mi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gi="WebkitAnimation",yi="webkitAnimationEnd"));var bi=Y?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xi(n){bi((function(){bi(n)}))}function _i(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ui(n,e))}function wi(n,e){n._transitionClasses&&_(n._transitionClasses,e),pi(n,e)}function ki(n,e,t){var r=Ti(n,e),i=r.type,o=r.timeout,a=r.propCount;if(!i)return t();var s="transition"===i?mi:yi,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=a&&c()};setTimeout((function(){l<a&&c()}),o+1),n.addEventListener(s,u)}var Ei=/\b(transform|all)(,|$)/;function Ti(n,e){var t,r=window.getComputedStyle(n),i=(r[vi+"Delay"]||"").split(", "),o=(r[vi+"Duration"]||"").split(", "),a=Oi(i,o),s=(r[gi+"Delay"]||"").split(", "),l=(r[gi+"Duration"]||"").split(", "),c=Oi(s,l),u=0,p=0;return"transition"===e?a>0&&(t="transition",u=a,p=o.length):"animation"===e?c>0&&(t="animation",u=c,p=l.length):p=(t=(u=Math.max(a,c))>0?a>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&Ei.test(r[vi+"Property"])}}function Oi(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ji(e)+ji(n[t])})))}function ji(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Si(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=di(n.data.transition);if(!o(r)&&!a(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,l=r.enterClass,p=r.enterToClass,d=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,v=r.appearActiveClass,m=r.beforeEnter,g=r.enter,b=r.afterEnter,x=r.enterCancelled,_=r.beforeAppear,w=r.appear,k=r.afterAppear,E=r.appearCancelled,T=r.duration,O=Xe,j=Xe.$vnode;j&&j.parent;)O=j.context,j=j.parent;var S=!O._isMounted||!n.isRootInsert;if(!S||w||""===w){var C=S&&f?f:l,I=S&&v?v:d,A=S&&h?h:p,z=S&&_||m,$=S&&c(w)?w:g,L=S&&k||b,P=S&&E||x,B=y(u(T)?T.enter:T);0;var N=!1!==i&&!Z,R=Ai($),M=t._enterCb=D((function(){N&&(wi(t,A),wi(t,I)),M.cancelled?(N&&wi(t,C),P&&P(t)):L&&L(t),t._enterCb=null}));n.data.show||Kn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),$&&$(t,M)})),z&&z(t),N&&(_i(t,C),_i(t,I),xi((function(){wi(t,C),M.cancelled||(_i(t,A),R||(Ii(B)?setTimeout(M,B):ki(t,s,M)))}))),n.data.show&&(e&&e(),$&&$(t,M)),N||R||M()}}}function Ci(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=di(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var i=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,p=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,v=r.leaveCancelled,m=r.delayLeave,g=r.duration,b=!1!==i&&!Z,x=Ai(f),_=y(u(g)?g.leave:g);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(wi(t,c),wi(t,p)),w.cancelled?(b&&wi(t,l),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));m?m(k):k()}function k(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),b&&(_i(t,l),_i(t,p),xi((function(){wi(t,l),w.cancelled||(_i(t,c),x||(Ii(_)?setTimeout(w,_):ki(t,s,w)))}))),f&&f(t,w),b||x||w())}}function Ii(n){return"number"==typeof n&&!isNaN(n)}function Ai(n){if(o(n))return!1;var e=n.fns;return a(e)?Ai(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function zi(n,e){!0!==e.data.show&&Si(e)}var $i=function(n){var e,t,r={},c=n.modules,u=n.nodeOps;for(e=0;e<Tr.length;++e)for(r[Tr[e]]=[],t=0;t<c.length;++t)a(c[t][Tr[e]])&&r[Tr[e]].push(c[t][Tr[e]]);function p(n){var e=u.parentNode(n);a(e)&&u.removeChild(e,n)}function d(n,e,t,i,o,l,c){if(a(n.elm)&&a(l)&&(n=l[c]=gn(n)),n.isRootInsert=!o,!function(n,e,t,i){var o=n.data;if(a(o)){var l=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return f(n,e),h(t,n.elm,i),s(l)&&function(n,e,t,i){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](Er,s);e.push(s);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var p=n.data,d=n.children,m=n.tag;a(m)?(n.elm=n.ns?u.createElementNS(n.ns,m):u.createElement(m,n),y(n),v(n,d,e),a(p)&&g(n,e),h(t,n.elm,i)):s(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,i)):(n.elm=u.createTextNode(n.text),h(t,n.elm,i))}}function f(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,m(n)?(g(n,e),y(n)):(wr(n),e.push(n))}function h(n,e,t){a(n)&&(a(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function v(n,e,t){if(i(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function m(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function g(n,t){for(var i=0;i<r.create.length;++i)r.create[i](Er,n);a(e=n.data.hook)&&(a(e.create)&&e.create(Er,n),a(e.insert)&&t.push(n))}function y(n){var e;if(a(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;a(e=Xe)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,r,i,o){for(;r<=i;++r)d(t[r],o,n,e,!1,t,r)}function _(n){var e,t,i=n.data;if(a(i))for(a(e=i.hook)&&a(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)_(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];a(r)&&(a(r.tag)?(k(r),_(r)):p(r.elm))}}function k(n,e){if(a(e)||a(n.data)){var t,i=r.remove.length+1;for(a(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,i),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else p(n.elm)}function E(n,e,t,r){for(var i=t;i<r;i++){var o=e[i];if(a(o)&&Or(n,o))return i}}function T(n,e,t,i,l,c){if(n!==e){a(e.elm)&&a(i)&&(e=i[l]=gn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;a(h)&&a(f=h.hook)&&a(f=f.prepatch)&&f(n,e);var v=n.children,g=e.children;if(a(h)&&m(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);a(f=h.hook)&&a(f=f.update)&&f(n,e)}o(e.text)?a(v)&&a(g)?v!==g&&function(n,e,t,r,i){var s,l,c,p=0,f=0,h=e.length-1,v=e[0],m=e[h],g=t.length-1,y=t[0],b=t[g],_=!i;for(0;p<=h&&f<=g;)o(v)?v=e[++p]:o(m)?m=e[--h]:Or(v,y)?(T(v,y,r,t,f),v=e[++p],y=t[++f]):Or(m,b)?(T(m,b,r,t,g),m=e[--h],b=t[--g]):Or(v,b)?(T(v,b,r,t,g),_&&u.insertBefore(n,v.elm,u.nextSibling(m.elm)),v=e[++p],b=t[--g]):Or(m,y)?(T(m,y,r,t,f),_&&u.insertBefore(n,m.elm,v.elm),m=e[--h],y=t[++f]):(o(s)&&(s=jr(e,p,h)),o(l=a(y.key)?s[y.key]:E(y,e,p,h))?d(y,r,n,v.elm,!1,t,f):Or(c=e[l],y)?(T(c,y,r,t,f),e[l]=void 0,_&&u.insertBefore(n,c.elm,v.elm)):d(y,r,n,v.elm,!1,t,f),y=t[++f]);p>h?x(n,o(t[g+1])?null:t[g+1].elm,t,f,g,r):f>g&&w(e,p,h)}(p,v,g,t,c):a(g)?(a(n.text)&&u.setTextContent(p,""),x(p,null,g,0,g.length-1,t)):a(v)?w(v,0,v.length-1):a(n.text)&&u.setTextContent(p,""):n.text!==e.text&&u.setTextContent(p,e.text),a(h)&&a(f=h.hook)&&a(f=f.postpatch)&&f(n,e)}}}function O(n,e,t){if(s(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var j=b("attrs,class,staticClass,staticStyle,key");function S(n,e,t,r){var i,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(i=l.hook)&&a(i=i.init)&&i(e,!0),a(i=e.componentInstance)))return f(e,t),!0;if(a(o)){if(a(c))if(n.hasChildNodes())if(a(i=l)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<c.length;d++){if(!p||!S(p,c[d],t,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else v(e,c,t);if(a(l)){var h=!1;for(var m in l)if(!j(m)){h=!0,g(e,t);break}!h&&l.class&&qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!o(e)){var l,c=!1,p=[];if(o(n))c=!0,d(e,p);else{var f=a(n.nodeType);if(!f&&Or(n,e))T(n,e,p,null,null,i);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,p))return O(e,p,!0),n;l=n,n=new hn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,v=u.parentNode(h);if(d(e,p,h._leaveCb?null:v,u.nextSibling(h)),a(e.parent))for(var g=e.parent,y=m(e);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=e.elm,y){for(var x=0;x<r.create.length;++x)r.create[x](Er,g);var k=g.data.hook.insert;if(k.merged)for(var E=k.fns.slice(1),j=0;j<E.length;j++)E[j]()}else wr(g);g=g.parent}a(v)?w([n],0,0):a(n.tag)&&_(n)}}return O(e,p,c),e.elm}a(n)&&_(n)}}({nodeOps:xr,modules:[Rr,Ur,Kr,Xr,li,Y?{create:zi,activate:zi,remove:function(n,e){!0!==n.data.show?Ci(n,e):e()}}:{}].concat(Lr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ui(n,"input")}));var Li={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Kn(t,"postpatch",(function(){Li.componentUpdated(n,e,t)})):Pi(n,e,t.context),n._vOptions=[].map.call(n.options,Ri)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Di),n.addEventListener("compositionend",Mi),n.addEventListener("change",Mi),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,Ri);if(i.some((function(n,e){return!N(n,r[e])})))(n.multiple?e.value.some((function(n){return Ni(n,i)})):e.value!==e.oldValue&&Ni(e.value,i))&&Ui(n,"change")}}};function Pi(n,e,t){Bi(n,e,t),(X||Q)&&setTimeout((function(){Bi(n,e,t)}),0)}function Bi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,l=n.options.length;s<l;s++)if(a=n.options[s],i)o=R(r,Ri(a))>-1,a.selected!==o&&(a.selected=o);else if(N(Ri(a),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function Ni(n,e){return e.every((function(e){return!N(e,n)}))}function Ri(n){return"_value"in n?n._value:n.value}function Di(n){n.target.composing=!0}function Mi(n){n.target.composing&&(n.target.composing=!1,Ui(n.target,"input"))}function Ui(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fi(n){return!n.componentInstance||n.data&&n.data.transition?n:Fi(n.componentInstance._vnode)}var qi={model:Li,show:{bind:function(n,e,t){var r=e.value,i=(t=Fi(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,Si(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Fi(t)).data&&t.data.transition?(t.data.show=!0,r?Si(t,(function(){n.style.display=n.__vOriginalDisplay})):Ci(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Hi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vi(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Vi(Te(e.children)):n}function Gi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var r in i)e[O(r)]=i[r];return e}function Wi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ki=function(n){return n.tag||ve(n)},Yi=function(n){return"show"===n.name},Ji={name:"transition",props:Hi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ki)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var o=Vi(i);if(!o)return i;if(this._leaving)return Wi(n,i);var a="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?a+"comment":a+o.tag:l(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Gi(this),c=this._vnode,u=Vi(c);if(o.data.directives&&o.data.directives.some(Yi)&&(o.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,u)&&!ve(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=z({},s);if("out-in"===r)return this._leaving=!0,Kn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wi(n,i);if("in-out"===r){if(ve(o))return c;var d,f=function(){d()};Kn(s,"afterEnter",f),Kn(s,"enterCancelled",f),Kn(p,"delayLeave",(function(n){d=n}))}}return i}}},Xi=z({tag:String,moveClass:String},Hi);function Zi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Qi(n){n.data.newPos=n.elm.getBoundingClientRect()}function no(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),o.transitionDuration="0s"}}delete Xi.mode;var eo={Transition:Ji,TransitionGroup:{props:Xi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Gi(this),s=0;s<i.length;s++){if((u=i[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),t[u.key]=u,(u.data||(u.data={})).transition=a;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=a,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Zi),n.forEach(Qi),n.forEach(no),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;_i(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(mi,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(mi,n),t._moveCb=null,wi(t,e))})}})))},methods:{hasMove:function(n,e){if(!hi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pi(t,n)})),ui(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ti(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function to(n,e){for(var t in e)n[t]=e[t];return n}Wt.config.mustUseProp=function(n,e,t){return"value"===t&&tr(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Wt.config.isReservedTag=gr,Wt.config.isReservedAttr=er,Wt.config.getTagNamespace=function(n){return mr(n)?"svg":"math"===n?"math":void 0},Wt.config.isUnknownElement=function(n){if(!Y)return!0;if(gr(n))return!1;if(n=n.toLowerCase(),null!=yr[n])return yr[n];var e=document.createElement(n);return n.indexOf("-")>-1?yr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:yr[n]=/HTMLUnknownElement/.test(e.toString())},z(Wt.options.directives,qi),z(Wt.options.components,eo),Wt.prototype.__patch__=Y?$i:L,Wt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=vn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Ge(n,r,L,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var o=0;o<i.length;o++)i[o].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&Y?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Y&&setTimeout((function(){q.devtools&&ln&&ln.emit("init",Wt)}),0);var ro=/[!'()*]/g,io=function(n){return"%"+n.charCodeAt(0).toString(16)},oo=/%2C/g,ao=function(n){return encodeURIComponent(n).replace(ro,io).replace(oo,",")};function so(n){try{return decodeURIComponent(n)}catch(n){0}return n}var lo=function(n){return null==n||"object"==typeof n?n:String(n)};function co(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=so(t.shift()),i=t.length>0?so(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function uo(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ao(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(ao(e)):r.push(ao(e)+"="+ao(n)))})),r.join("&")}return ao(e)+"="+ao(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var po=/\/?$/;function fo(n,e,t,r){var i=r&&r.options.stringifyQuery,o=e.query||{};try{o=ho(o)}catch(n){}var a={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:go(e,i),matched:n?mo(n):[]};return t&&(a.redirectedFrom=go(t,i)),Object.freeze(a)}function ho(n){if(Array.isArray(n))return n.map(ho);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ho(n[t]);return e}return n}var vo=fo(null,{path:"/"});function mo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function go(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||uo)(r)+i}function yo(n,e,t){return e===vo?n===e:!!e&&(n.path&&e.path?n.path.replace(po,"")===e.path.replace(po,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var o=n[t];if(r[i]!==t)return!1;var a=e[t];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?bo(o,a):String(o)===String(a)}))}function xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],o=t.enteredCbs[r];if(i&&o){delete t.enteredCbs[r];for(var a=0;a<o.length;a++)i._isBeingDestroyed||o[a](i)}}}}var _o={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,o=e.data;o.routerView=!0;for(var a=i.$createElement,s=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),u=0,p=!1;i&&i._routerRoot!==i;){var d=i.$vnode?i.$vnode.data:{};d.routerView&&u++,d.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(o.routerViewDepth=u,p){var f=c[s],h=f&&f.component;return h?(f.configProps&&wo(h,o,f.route,f.configProps),a(h,o,r)):a()}var v=l.matched[u],m=v&&v.components[s];if(!v||!m)return c[s]=null,a();c[s]={component:m},o.registerRouteInstance=function(n,e){var t=v.instances[s];(e&&t!==n||!e&&t===n)&&(v.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){v.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[s]&&(v.instances[s]=n.componentInstance),xo(l)};var g=v.props&&v.props[s];return g&&(to(c[s],{route:l,configProps:g}),wo(m,o,l,g)),a(m,o,r)}};function wo(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=to({},i);var o=e.attrs=e.attrs||{};for(var a in i)n.props&&a in n.props||(o[a]=i[a],delete i[a])}}function ko(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function Eo(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var To=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Oo=Mo,jo=zo,So=function(n,e){return Lo(zo(n,e),e)},Co=Lo,Io=Do,Ao=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function zo(n,e){for(var t,r=[],i=0,o=0,a="",s=e&&e.delimiter||"/";null!=(t=Ao.exec(n));){var l=t[0],c=t[1],u=t.index;if(a+=n.slice(o,u),o=u+l.length,c)a+=c[1];else{var p=n[o],d=t[2],f=t[3],h=t[4],v=t[5],m=t[6],g=t[7];a&&(r.push(a),a="");var y=null!=d&&null!=p&&p!==d,b="+"===m||"*"===m,x="?"===m||"*"===m,_=t[2]||s,w=h||v;r.push({name:f||i++,prefix:d||"",delimiter:_,optional:x,repeat:b,partial:y,asterisk:!!g,pattern:w?Bo(w):g?".*":"[^"+Po(_)+"]+?"})}}return o<n.length&&(a+=n.substr(o)),a&&r.push(a),r}function $o(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Lo(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Ro(e)));return function(e,r){for(var i="",o=e||{},a=(r||{}).pretty?$o:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=o[l.name];if(null==u){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(To(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(c=a(u[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function Po(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Bo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function No(n,e){return n.keys=e,n}function Ro(n){return n&&n.sensitive?"":"i"}function Do(n,e,t){To(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,o="",a=0;a<n.length;a++){var s=n[a];if("string"==typeof s)o+=Po(s);else{var l=Po(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Po(t.delimiter||"/"),p=o.slice(-u.length)===u;return r||(o=(p?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=i?"$":r&&p?"":"(?="+u+"|$)",No(new RegExp("^"+o,Ro(t)),e)}function Mo(n,e,t){return To(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return No(n,e)}(n,e):To(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(Mo(n[i],e,t).source);return No(new RegExp("(?:"+r.join("|")+")",Ro(t)),e)}(n,e,t):function(n,e,t){return Do(zo(n,t),e,t)}(n,e,t)}Oo.parse=jo,Oo.compile=So,Oo.tokensToFunction=Co,Oo.tokensToRegExp=Io;var Uo=Object.create(null);function Fo(n,e,t){e=e||{};try{var r=Uo[n]||(Uo[n]=Oo.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function qo(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var o=(i=to({},n)).params;return o&&"object"==typeof o&&(i.params=to({},o)),i}if(!i.path&&i.params&&e){(i=to({},i))._normalized=!0;var a=to(to({},e.params),i.params);if(e.name)i.name=e.name,i.params=a;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=Fo(s,a,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",u=l.path?ko(l.path,c,t||i.append):c,p=function(n,e,t){void 0===e&&(e={});var r,i=t||co;try{r=i(n||"")}catch(n){r={}}for(var o in e){var a=e[o];r[o]=Array.isArray(a)?a.map(lo):lo(a)}return r}(l.query,i.query,r&&r.options.parseQuery),d=i.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var Ho,Vo=function(){},Go={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),o=i.location,a=i.route,s=i.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,d=null==u?"router-link-exact-active":u,f=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,v=a.redirectedFrom?fo(null,qo(a.redirectedFrom),null,t):a;l[h]=yo(r,v,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(po,"/").indexOf(e.path.replace(po,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,v);var m=l[h]?this.ariaCurrentValue:null,g=function(n){Wo(n)&&(e.replace?t.replace(o,Vo):t.push(o,Vo))},y={click:Wo};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=g})):y[this.event]=g;var b={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:g,isActive:l[f],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":m};else{var _=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(_){_.isStatic=!1;var w=_.data=to({},_.data);for(var k in w.on=w.on||{},w.on){var E=w.on[k];k in y&&(w.on[k]=Array.isArray(E)?E:[E])}for(var T in y)T in w.on?w.on[T].push(y[T]):w.on[T]=g;var O=_.data.attrs=to({},_.data.attrs);O.href=s,O["aria-current"]=m}else b.on=y}return n(this.tag,b,this.$slots.default)}};function Wo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ko="undefined"!=typeof window;function Yo(n,e,t,r,i){var o=e||[],a=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,o,a){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Eo(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var p={path:u,regex:Jo(u,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:a,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var o=a?Eo(a+"/"+i.path):void 0;n(e,t,r,i,p,o)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==i.alias)for(var d=Array.isArray(i.alias)?i.alias:[i.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:i.children};n(e,t,r,h,o,p.path||"/")}l&&(r[l]||(r[l]=p))}(o,a,s,n,i)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:a,nameMap:s}}function Jo(n,e){return Oo(n,[],e)}function Xo(n,e){var t=Yo(n),r=t.pathList,i=t.pathMap,o=t.nameMap;function a(n,t,a){var s=qo(n,t,!1,e),c=s.name;if(c){var u=o[c];if(!u)return l(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Fo(u.path,s.params),l(u,s,a)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],v=i[h];if(Zo(v.regex,s.path,s.params))return l(v,s,a)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(fo(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,u=s.path,p=t.query,d=t.hash,f=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,c){o[c];return a({_normalized:!0,name:c,query:p,hash:d,params:f},void 0,t)}if(u){var h=function(n,e){return ko(n,e.parent?e.parent.path:"/",!0)}(u,n);return a({_normalized:!0,path:Fo(h,f),query:p,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=a({_normalized:!0,path:Fo(t,e.params)});if(r){var i=r.matched,o=i[i.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):fo(n,t,r,e)}return{match:a,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Yo([e||n],r,i,o,t),t&&t.alias.length&&Yo(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,o,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Yo(n,r,i,o)}}}function Zo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,o=r.length;i<o;++i){var a=n.keys[i-1];a&&(t[a.name||"pathMatch"]="string"==typeof r[i]?so(r[i]):r[i])}return!0}var Qo=Ko&&window.performance&&window.performance.now?window.performance:Date;function na(){return Qo.now().toFixed(3)}var ea=na();function ta(){return ea}function ra(n){return ea=n}var ia=Object.create(null);function oa(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=to({},window.history.state);return t.key=ta(),window.history.replaceState(t,"",e),window.addEventListener("popstate",la),function(){window.removeEventListener("popstate",la)}}function aa(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var o=function(){var n=ta();if(n)return ia[n]}(),a=i.call(n,e,t,r?o:null);a&&("function"==typeof a.then?a.then((function(n){fa(n,o)})).catch((function(n){0})):fa(a,o))}))}}function sa(){var n=ta();n&&(ia[n]={x:window.pageXOffset,y:window.pageYOffset})}function la(n){sa(),n.state&&n.state.key&&ra(n.state.key)}function ca(n){return pa(n.x)||pa(n.y)}function ua(n){return{x:pa(n.x)?n.x:window.pageXOffset,y:pa(n.y)?n.y:window.pageYOffset}}function pa(n){return"number"==typeof n}var da=/^#\d/;function fa(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=da.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,o={x:pa((t=o).x)?t.x:0,y:pa(t.y)?t.y:0})}else ca(n)&&(e=ua(n))}else r&&ca(n)&&(e=ua(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ha,va=Ko&&((-1===(ha=window.navigator.userAgent).indexOf("Android 2.")&&-1===ha.indexOf("Android 4.0")||-1===ha.indexOf("Mobile Safari")||-1!==ha.indexOf("Chrome")||-1!==ha.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ma(n,e){sa();var t=window.history;try{if(e){var r=to({},t.state);r.key=ta(),t.replaceState(r,"",n)}else t.pushState({key:ra(na())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ga(n){ma(n,!0)}var ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function ba(n,e){return _a(n,e,ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wa.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xa(n,e){return _a(n,e,ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function _a(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var wa=["params","query","hash"];function ka(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Ea(n,e){return ka(n)&&n._isRouter&&(null==e||n.type===e)}function Ta(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}function Oa(n){return function(e,t,r){var i=!1,o=0,a=null;ja(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,o++;var l,c=Ia((function(e){var i;((i=e).__esModule||Ca&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ho.extend(e),t.components[s]=e,--o<=0&&r()})),u=Ia((function(n){var e="Failed to resolve async component "+s+": "+n;a||(a=ka(n)?n:new Error(e),r(a))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,u)}}})),i||r()}}function ja(n,e){return Sa(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Sa(n){return Array.prototype.concat.apply([],n)}var Ca="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ia(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Aa=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ko){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=vo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function za(n,e,t,r){var i=ja(n,(function(n,r,i,o){var a=function(n,e){"function"!=typeof n&&(n=Ho.extend(n));return n.options[e]}(n,e);if(a)return Array.isArray(a)?a.map((function(n){return t(n,r,i,o)})):t(a,r,i,o)}));return Sa(r?i.reverse():i)}function $a(n,e){if(e)return function(){return n.apply(e,arguments)}}Aa.prototype.listen=function(n){this.cb=n},Aa.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Aa.prototype.onError=function(n){this.errorCbs.push(n)},Aa.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(Ea(n,ya.redirected)&&o===vo||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},Aa.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var o,a,s=function(n){!Ea(n)&&ka(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(yo(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&aa(this.router,i,n,!1),s(((a=_a(o=i,n,ya.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,f=u.activated,h=[].concat(function(n){return za(n,"beforeRouteLeave",$a,!0)}(d),this.router.beforeHooks,function(n){return za(n,"beforeRouteUpdate",$a)}(p),f.map((function(n){return n.beforeEnter})),Oa(f)),v=function(e,t){if(r.pending!==n)return s(xa(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return _a(n,e,ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):ka(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(ba(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Ta(h,v,(function(){Ta(function(n){return za(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,o){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),v,(function(){if(r.pending!==n)return s(xa(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){xo(n)}))}))}))},Aa.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Aa.prototype.setupListeners=function(){},Aa.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=vo,this.pending=null};var La=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Pa(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=va&&t;r&&this.listeners.push(oa());var i=function(){var t=n.current,i=Pa(n.base);n.current===vo&&i===n._startLocation||n.transitionTo(i,(function(n){r&&aa(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){ma(Eo(r.base+n.fullPath)),aa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){ga(Eo(r.base+n.fullPath)),aa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Pa(this.base)!==this.current.fullPath){var e=Eo(this.base+this.current.fullPath);n?ma(e):ga(e)}},e.prototype.getCurrentLocation=function(){return Pa(this.base)},e}(Aa);function Pa(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Eo(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ba=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Pa(n);if(!/^\/#/.test(e))return window.location.replace(Eo(n+"/#"+e)),!0}(this.base)||Na()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=va&&e;t&&this.listeners.push(oa());var r=function(){var e=n.current;Na()&&n.transitionTo(Ra(),(function(r){t&&aa(n.router,r,e,!0),va||Ua(r.fullPath)}))},i=va?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ma(n.fullPath),aa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ua(n.fullPath),aa(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ra()!==e&&(n?Ma(e):Ua(e))},e.prototype.getCurrentLocation=function(){return Ra()},e}(Aa);function Na(){var n=Ra();return"/"===n.charAt(0)||(Ua("/"+n),!1)}function Ra(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Da(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ma(n){va?ma(Da(n)):window.location.hash=n}function Ua(n){va?ga(Da(n)):window.location.replace(Da(n))}var Fa=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Ea(n,ya.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Aa),qa=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!va&&!1!==n.fallback,this.fallback&&(e="hash"),Ko||(e="abstract"),this.mode=e,e){case"history":this.history=new La(this,n.base);break;case"hash":this.history=new Ba(this,n.base,this.fallback);break;case"abstract":this.history=new Fa(this,n.base);break;default:0}},Ha={currentRoute:{configurable:!0}};qa.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ha.currentRoute.get=function(){return this.history&&this.history.current},qa.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof La||t instanceof Ba){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;va&&i&&"fullPath"in n&&aa(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},qa.prototype.beforeEach=function(n){return Ga(this.beforeHooks,n)},qa.prototype.beforeResolve=function(n){return Ga(this.resolveHooks,n)},qa.prototype.afterEach=function(n){return Ga(this.afterHooks,n)},qa.prototype.onReady=function(n,e){this.history.onReady(n,e)},qa.prototype.onError=function(n){this.history.onError(n)},qa.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},qa.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},qa.prototype.go=function(n){this.history.go(n)},qa.prototype.back=function(){this.go(-1)},qa.prototype.forward=function(){this.go(1)},qa.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},qa.prototype.resolve=function(n,e,t){var r=qo(n,e=e||this.history.current,t,this),i=this.match(r,e),o=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Eo(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:i}},qa.prototype.getRoutes=function(){return this.matcher.getRoutes()},qa.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==vo&&this.history.transitionTo(this.history.getCurrentLocation())},qa.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==vo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(qa.prototype,Ha);var Va=qa;function Ga(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}qa.install=function n(e){if(!n.installed||Ho!==e){n.installed=!0,Ho=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",_o),e.component("RouterLink",Go);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},qa.version="3.6.5",qa.isNavigationFailure=Ea,qa.NavigationFailureType=ya,qa.START_LOCATION=vo,Ko&&window.Vue&&window.Vue.use(qa);t(153),t(18),t(162);t(163),t(31);var Wa={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,361)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,360))},Ka={"v-f8889c5c":()=>t.e(5).then(t.bind(null,362)),"v-38c6b580":()=>t.e(7).then(t.bind(null,363)),"v-f5961ec6":()=>t.e(9).then(t.bind(null,364)),"v-113bfc22":()=>t.e(8).then(t.bind(null,365)),"v-65e2e2da":()=>t.e(10).then(t.bind(null,366)),"v-1afcd619":()=>t.e(6).then(t.bind(null,367)),"v-4002eec4":()=>t.e(11).then(t.bind(null,368)),"v-df2149cc":()=>t.e(12).then(t.bind(null,369)),"v-63657ac4":()=>t.e(13).then(t.bind(null,370)),"v-334ff26a":()=>t.e(14).then(t.bind(null,371)),"v-3d274ca6":()=>t.e(15).then(t.bind(null,372)),"v-2e58a9ba":()=>t.e(16).then(t.bind(null,373)),"v-e729f00c":()=>t.e(17).then(t.bind(null,374)),"v-4b0c4b95":()=>t.e(19).then(t.bind(null,375)),"v-45abfe3e":()=>t.e(18).then(t.bind(null,376)),"v-8868cef6":()=>t.e(20).then(t.bind(null,377)),"v-9fddd836":()=>t.e(21).then(t.bind(null,378)),"v-cbf003be":()=>t.e(24).then(t.bind(null,379)),"v-26618d36":()=>t.e(23).then(t.bind(null,380)),"v-72ca5905":()=>t.e(25).then(t.bind(null,381)),"v-2b1e259c":()=>t.e(26).then(t.bind(null,382)),"v-212cfc36":()=>t.e(27).then(t.bind(null,383)),"v-4a8dfe05":()=>t.e(22).then(t.bind(null,384))};function Ya(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ja=/-(\w)/g,Xa=Ya(n=>n.replace(Ja,(n,e)=>e?e.toUpperCase():"")),Za=/\B([A-Z])/g,Qa=Ya(n=>n.replace(Za,"-$1").toLowerCase()),ns=Ya(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Xa(e))):n(ns(e))||n(Qa(e))}const ts=Object.assign({},Wa,Ka),rs=n=>ts[n],is=n=>Ka[n],os=n=>Wa[n],as=n=>Wt.component(n);function ss(n){return es(is,n)}function ls(n){return es(os,n)}function cs(n){return es(rs,n)}function us(n){return es(as,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!us(n)&&cs(n)){const e=await cs(n)();Wt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var fs=t(121),hs=t.n(fs),vs=t(122),ms=t.n(vs),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ms()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,_s)},updateCanonicalLink(){ys(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),ys()}};function ys(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function _s(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}t(65);var ws=t(69),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],a=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!a||t<a.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(i===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Es=t(45),Ts=t.n(Es),Os={mounted(){Ts.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Wt.component(n.name)||Ts.a.start(),t()}),this.$router.afterEach(()=>{Ts.a.done(),this.isSidebarOpen=!1})}};t(272),t(273);class js{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Ss={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new js).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Cs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Is={},As=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},zs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Cs[n]},$s=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;i.appendChild(n(t,r,o))})),i},Ls=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},Ps=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=As(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](i);return o.template=e,o}(s.js,s.html);var l=zs("vue");return s.jsLib.unshift(l),s},Bs=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),a={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(t=a.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),a},Ns=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Rs(){var n=Ls(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ls(n,"vuepress-plugin-demo-block__code"),t=Ls(n,"vuepress-plugin-demo-block__display"),r=Ls(n,"vuepress-plugin-demo-block__footer"),i=Ls(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),a=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);a=a?JSON.parse(a):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),o={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ns(n),htmlTpl:As("")},a=zs("react"),s=zs("reactDOM");return o.jsLib.unshift(a,s),o}(o,a):"vanilla"===s?Bs(o,a):Ps(o,a),u=$s("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Ds.bind(null,u,l,e,r)),zs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,a=i.concat(o).concat(zs("cssLib")).concat(zs("jsLib")).join(",");return $s("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),zs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,o=n.cssLib,a=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(zs("jsLib")).join(";"),css_external:o.concat(zs("cssLib")).join(";"),layout:zs("codepenLayout"),js_pre_processor:zs("codepenJsProcessor"),editors:zs("codepenEditors")});return $s("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==a.horizontal?a.horizontal:zs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!Is[n]){var e=$s("style",{innerHTML:n});document.body.appendChild(e),Is[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),i);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();i.appendChild(d.$el)}else"vanilla"===s&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Rs()}),300)}function Ds(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Ms={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Rs()},updated:function(){Rs()}},Us="auto",Fs="zoom-in",qs="zoom-out",Hs="grab",Vs="move";function Gs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Ws(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ks(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ys(n,e,t){!function(n){var e=Js,t=Xs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var o in e)t&&(i[o]=r[o]||""),r[o]=e[o];return i}var Js="transition",Xs="transform",Zs="transform",Qs="transitionend";var nl=function(){},el={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:nl,onClose:nl,onGrab:nl,onMove:nl,onRelease:nl,onBeforeOpen:nl,onBeforeClose:nl,onBeforeGrab:nl,onBeforeRelease:nl,onImageLoading:nl,onImageLoaded:nl},tl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),il(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(i)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(rl(n)&&!il(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){rl(n)&&!il(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function rl(n){return 0===n.button}function il(n){return n.metaKey||n.ctrlKey}var ol={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ys(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Gs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ys(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},al="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),ll=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},cl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ks(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Hs:qs,transition:Zs+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ys(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ys(this.el,{transform:"none"})},grab:function(n,e,t){var r=ul(),i=r.x-n,o=r.y-e;Ys(this.el,{cursor:Vs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=ul(),i=r.x-n,o=r.y-e;Ys(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ys(this.el,this.styleClose)},restoreOpenStyle:function(){Ys(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=ul(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,o=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":al(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var a=this.rect.width/2,s=this.rect.height/2,l=ul(),c={x:l.x-a,y:l.y-s},u=c.x/a,p=c.y/s,d=o+Math.min(u,p);if(i&&"string"==typeof i){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,v=parseFloat(i)*f/(100*this.rect.width),m=parseFloat(i)*h/(100*this.rect.height);if(d>v||d>m)return{x:v,y:m}}return{x:d,y:d}}};function ul(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Gs(n,r,e[r],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(cl),this.overlay=Object.create(ol),this.handler=Object.create(tl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ll({},el,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Fs,Gs(n,"click",this.handler.click),this.options.preloadImage&&Ws(Ks(n)));return this}},{key:"config",value:function(n){return n?(ll(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Ws(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Gs(document,"scroll",this.handler.scroll),Gs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Gs(window,"resize",this.handler.resizeWindow);var o=function n(){Gs(r,Qs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(r)};return Gs(r,Qs,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Us,this.overlay.fadeOut(),this.target.zoomOut(),Gs(document,"scroll",this.handler.scroll,!1),Gs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Gs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Gs(t,Qs,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Gs(t,Qs,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var o=function n(){Gs(i,Qs,n,!1),r(i)};return Gs(i,Qs,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Vs,this.target.move(n,e,t);var i=this.target.el,o=function n(){Gs(i,Qs,n,!1),r(i)};return Gs(i,Qs,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Us,this.target.restoreOpenStyle();var r=function r(){Gs(t,Qs,r,!1),n.lock=!1,n.released=!0,e(t)};return Gs(t,Qs,r),this}}}]),n}();const fl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),hl=Number("500");class vl{constructor(){this.instance=new dl(fl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=hl){setTimeout(()=>this.update(n),e)}}var ml=[gs,ks,Os,Ss,Ms,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new vl,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Wt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},yl=t(15),bl=Object(yl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",ml);const xl=[{name:"v-f8889c5c",path:"/pages/8b1bd0/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-f8889c5c").then(t)}},{path:"/pages/8b1bd0/index.html",redirect:"/pages/8b1bd0/"},{path:"/01.数据结构和算法/00.综合/01.数据结构和算法指南.html",redirect:"/pages/8b1bd0/"},{name:"v-38c6b580",path:"/pages/5a9bff/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-38c6b580").then(t)}},{path:"/pages/5a9bff/index.html",redirect:"/pages/5a9bff/"},{path:"/01.数据结构和算法/01.线性表/01.数组和链表.html",redirect:"/pages/5a9bff/"},{name:"v-f5961ec6",path:"/pages/4b1ed0/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-f5961ec6").then(t)}},{path:"/pages/4b1ed0/index.html",redirect:"/pages/4b1ed0/"},{path:"/01.数据结构和算法/01.线性表/11.线性表的查找.html",redirect:"/pages/4b1ed0/"},{name:"v-113bfc22",path:"/pages/1f15c3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-113bfc22").then(t)}},{path:"/pages/1f15c3/index.html",redirect:"/pages/1f15c3/"},{path:"/01.数据结构和算法/01.线性表/02.栈和队列.html",redirect:"/pages/1f15c3/"},{name:"v-65e2e2da",path:"/pages/21c5f2/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-65e2e2da").then(t)}},{path:"/pages/21c5f2/index.html",redirect:"/pages/21c5f2/"},{path:"/01.数据结构和算法/01.线性表/12.线性表的排序.html",redirect:"/pages/21c5f2/"},{name:"v-1afcd619",path:"/pages/2a4131/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-1afcd619").then(t)}},{path:"/pages/2a4131/index.html",redirect:"/pages/2a4131/"},{path:"/01.数据结构和算法/00.综合/02.复杂度分析.html",redirect:"/pages/2a4131/"},{name:"v-4002eec4",path:"/pages/92e4c1/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-4002eec4").then(t)}},{path:"/pages/92e4c1/index.html",redirect:"/pages/92e4c1/"},{path:"/01.数据结构和算法/02.树/01.树和二叉树.html",redirect:"/pages/92e4c1/"},{name:"v-df2149cc",path:"/pages/ce297c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-df2149cc").then(t)}},{path:"/pages/ce297c/index.html",redirect:"/pages/ce297c/"},{path:"/01.数据结构和算法/02.树/02.堆.html",redirect:"/pages/ce297c/"},{name:"v-63657ac4",path:"/pages/3fd76e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-63657ac4").then(t)}},{path:"/pages/3fd76e/index.html",redirect:"/pages/3fd76e/"},{path:"/01.数据结构和算法/02.树/03.B+树.html",redirect:"/pages/3fd76e/"},{name:"v-334ff26a",path:"/pages/4a217d/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-334ff26a").then(t)}},{path:"/pages/4a217d/index.html",redirect:"/pages/4a217d/"},{path:"/01.数据结构和算法/02.树/04.LSM树.html",redirect:"/pages/4a217d/"},{name:"v-3d274ca6",path:"/pages/0a4984/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-3d274ca6").then(t)}},{path:"/pages/0a4984/index.html",redirect:"/pages/0a4984/"},{path:"/01.数据结构和算法/02.树/05.字典树.html",redirect:"/pages/0a4984/"},{name:"v-2e58a9ba",path:"/pages/0a4414/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2e58a9ba").then(t)}},{path:"/pages/0a4414/index.html",redirect:"/pages/0a4414/"},{path:"/01.数据结构和算法/02.树/06.红黑树.html",redirect:"/pages/0a4414/"},{name:"v-e729f00c",path:"/pages/b501c7/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-e729f00c").then(t)}},{path:"/pages/b501c7/index.html",redirect:"/pages/b501c7/"},{path:"/01.数据结构和算法/03.哈希表.html",redirect:"/pages/b501c7/"},{name:"v-4b0c4b95",path:"/pages/21529b/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-4b0c4b95").then(t)}},{path:"/pages/21529b/index.html",redirect:"/pages/21529b/"},{path:"/01.数据结构和算法/05.图.html",redirect:"/pages/21529b/"},{name:"v-45abfe3e",path:"/pages/62671a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-45abfe3e").then(t)}},{path:"/pages/62671a/index.html",redirect:"/pages/62671a/"},{path:"/01.数据结构和算法/04.跳表.html",redirect:"/pages/62671a/"},{name:"v-8868cef6",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-8868cef6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-9fddd836",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-9fddd836").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-cbf003be",path:"/algorithm-template.html",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-cbf003be").then(t)}},{name:"v-26618d36",path:"/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-26618d36").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-72ca5905",path:"/hash-search.html",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-72ca5905").then(t)}},{name:"v-2b1e259c",path:"/%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2b1e259c").then(t)}},{path:"/算法思路.html",redirect:"/%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html"},{path:"/算法思路.html",redirect:"/%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html"},{name:"v-212cfc36",path:"/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%A0%91.html",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-212cfc36").then(t)}},{path:"/算法练习-树.html",redirect:"/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%A0%91.html"},{path:"/算法练习-树.html",redirect:"/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%A0%91.html"},{name:"v-4a8dfe05",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-4a8dfe05").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{path:"*",component:bl}],_l={title:"ALGORITHM-TUTORIAL",description:"☕ algorithm-tutorial 是一个数据结构与算法教程。",base:"/algorithm-tutorial/",headTags:[["link",{rel:"icon",href:"/algorithm-tutorial/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"数据结构和算法指南",frontmatter:{title:"数据结构和算法指南",categories:["数据结构和算法","综合"],tags:["数据结构","算法"],abbrlink:"e74901af",date:"2015-03-10T18:29:37.000Z",permalink:"/pages/8b1bd0/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/00.%E7%BB%BC%E5%90%88/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97.html",relativePath:"01.数据结构和算法/00.综合/01.数据结构和算法指南.md",key:"v-f8889c5c",path:"/pages/8b1bd0/",headers:[{level:2,title:"1. 为什么学习数据结构和算法",slug:"_1-为什么学习数据结构和算法",normalizedTitle:"1. 为什么学习数据结构和算法",charIndex:16},{level:2,title:"2. 如何学习数据结构和算法",slug:"_2-如何学习数据结构和算法",normalizedTitle:"2. 如何学习数据结构和算法",charIndex:186}],headersStr:"1. 为什么学习数据结构和算法 2. 如何学习数据结构和算法",content:"# 数据结构和算法指南\n\n\n# 1. 为什么学习数据结构和算法\n\n * 为了找到一份好工作：大厂面试喜欢考算法\n * 更深入了解流行技术的设计思想：数据结构和算法是计算机基础学科，很多框架、中间、底层系统设的设计，都借鉴了其思想。因此，掌握数据结构和算法，有利于更深入了解这些技术的设计思想。\n * 提升个人的编程水平\n * 不满足于做业务狗，拓展性能思考的视角\n\n\n# 2. 如何学习数据结构和算法\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n\n数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。\n\n先要学会复杂度分析，才能识别数据结构和算法的利弊。\n\n * 循序渐进\n * 边学边练，适度刷题\n * 学习并思考：学而不思则罔，思而不学则殆\n * 知识需要沉淀，不要想试图一下子掌握所有",normalizedContent:"# 数据结构和算法指南\n\n\n# 1. 为什么学习数据结构和算法\n\n * 为了找到一份好工作：大厂面试喜欢考算法\n * 更深入了解流行技术的设计思想：数据结构和算法是计算机基础学科，很多框架、中间、底层系统设的设计，都借鉴了其思想。因此，掌握数据结构和算法，有利于更深入了解这些技术的设计思想。\n * 提升个人的编程水平\n * 不满足于做业务狗，拓展性能思考的视角\n\n\n# 2. 如何学习数据结构和算法\n\n数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。\n\n数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。\n\n先要学会复杂度分析，才能识别数据结构和算法的利弊。\n\n * 循序渐进\n * 边学边练，适度刷题\n * 学习并思考：学而不思则罔，思而不学则殆\n * 知识需要沉淀，不要想试图一下子掌握所有",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"数组和链表",frontmatter:{title:"数组和链表",categories:["数据结构和算法","线性表"],tags:["数据结构","线性表","数组","链表"],abbrlink:"50ba53aa",date:"2015-04-10T18:46:13.000Z",permalink:"/pages/5a9bff/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/01.%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8.html",relativePath:"01.数据结构和算法/01.线性表/01.数组和链表.md",key:"v-38c6b580",path:"/pages/5a9bff/",headers:[{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2},{level:3,title:"数组的访问",slug:"数组的访问",normalizedTitle:"数组的访问",charIndex:136},{level:3,title:"数组的插入",slug:"数组的插入",normalizedTitle:"数组的插入",charIndex:276},{level:3,title:"数组的删除",slug:"数组的删除",normalizedTitle:"数组的删除",charIndex:288},{level:3,title:"数组的特性",slug:"数组的特性",normalizedTitle:"数组的特性",charIndex:300},{level:3,title:"多维数组",slug:"多维数组",normalizedTitle:"多维数组",charIndex:541},{level:2,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:5},{level:3,title:"单链表",slug:"单链表",normalizedTitle:"单链表",charIndex:1096},{level:4,title:"单链表插入",slug:"单链表插入",normalizedTitle:"单链表插入",charIndex:1287},{level:4,title:"单链表删除",slug:"单链表删除",normalizedTitle:"单链表删除",charIndex:1491},{level:3,title:"双链表",slug:"双链表",normalizedTitle:"双链表",charIndex:1103},{level:4,title:"双链表插入",slug:"双链表插入",normalizedTitle:"双链表插入",charIndex:1930},{level:4,title:"双链表删除",slug:"双链表删除",normalizedTitle:"双链表删除",charIndex:2105},{level:3,title:"循环链表",slug:"循环链表",normalizedTitle:"循环链表",charIndex:1110},{level:4,title:"循环单链表",slug:"循环单链表",normalizedTitle:"循环单链表",charIndex:2267},{level:4,title:"循环双链表",slug:"循环双链表",normalizedTitle:"循环双链表",charIndex:2393},{level:2,title:"数组 vs. 链表",slug:"数组-vs-链表",normalizedTitle:"数组 vs. 链表",charIndex:2405},{level:2,title:"数组和链表的基本操作示例",slug:"数组和链表的基本操作示例",normalizedTitle:"数组和链表的基本操作示例",charIndex:2689},{level:3,title:"一维数组的基本操作",slug:"一维数组的基本操作",normalizedTitle:"一维数组的基本操作",charIndex:2772},{level:3,title:"二维数组的基本操作",slug:"二维数组的基本操作",normalizedTitle:"二维数组的基本操作",charIndex:3623},{level:3,title:"单链表的基本操作",slug:"单链表的基本操作",normalizedTitle:"单链表的基本操作",charIndex:4414},{level:3,title:"双链表的基本操作",slug:"双链表的基本操作",normalizedTitle:"双链表的基本操作",charIndex:5670},{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:7049},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7357}],headersStr:"数组 数组的访问 数组的插入 数组的删除 数组的特性 多维数组 链表 单链表 单链表插入 单链表删除 双链表 双链表插入 双链表删除 循环链表 循环单链表 循环双链表 数组 vs. 链表 数组和链表的基本操作示例 一维数组的基本操作 二维数组的基本操作 单链表的基本操作 双链表的基本操作 练习 参考资料",content:'# 数组和链表\n\n> 数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（Linear List）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、B+ 树等，实际上都是这两者的结合和变化。\n\n\n# 数组\n\n数组用 连续 的内存空间来存储数据。\n\n\n# 数组的访问\n\n数组元素的访问是以行或列索引的单一下标表示。\n\n\n\n在上面的例子中，数组 a 中有 5 个元素。也就是说，a 的长度是 6 。我们可以使用 a[0] 来表示数组中的第一个元素。因此，a[0] = A 。类似地，a[1] = B，a[2] = C，依此类推。\n\n\n# 数组的插入\n\n\n\n\n# 数组的删除\n\n\n\n\n# 数组的特性\n\n数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先分配好空间大小。这使得数组有以下特性：\n\n 1. 用连续的内存空间来存储数据。\n 2. 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。\n 3. 数组的插入、删除操作，平均时间复杂度为 O(n)。\n 4. 空间大小固定，一旦建立，不能再改变。扩容只能采用复制数组的方式。\n 5. 在旧式编程语言中（如有中阶语言之称的 C），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险。\n\n\n# 多维数组\n\n数组是有下标和值组成集合。\n\n如果数组的下标有多个维度，即为多维数组。比如：二维数组可以视为『数组元素为一维数组』的一维数组；三维数组可以视为『数组元素为二维数组』的一维数组；依次类推。\n\n下图是由 M 个行向量，N 个列向量组成的二维数组.\n\n\n\n\n# 链表\n\n> 链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。\n\n区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为「结点」复合区域里，在每一个结点除了存储数据以外，还保存了到下一个节点的指针（Pointer）。由于不必按顺序存储，链表在插入数据的时候可以达到 O(1) 的复杂度，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间。\n\n链表具有以下特性：\n\n * 链表允许插入和移除任意位置上的节点，其时间复杂度为 O(1)\n * 链表没有数组的随机访问特性，链表只支持顺序访问，其时间复杂度为 O(n)。\n * 数组的空间大小是固定的，而链表的空间大小可以动态增长。相比于数组，链表支持扩容，显然更为灵活，但是由于多了指针域，空间开销也更大。\n * 链表相比于数组，多了头指针、尾指针（非必要），合理使用可以大大提高访问效率。\n\n链表有多种类型：\n\n * 单链表\n * 双链表\n * 循环链表\n\n\n# 单链表\n\n单链表中的每个结点不仅包含数据值，还包含一个指针，指向其后继节点。通过这种方式，单链表将所有结点按顺序组织起来。\n\n\n\n与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按 索引 来 访问元素 平均要花费 O(N) 时间，其中 N 是链表的长度。\n\n# 单链表插入\n\n如果我们想在给定的结点 prev 之后添加新值，我们应该：\n\n（1）使用给定值初始化新结点 cur；\n\n\n\n（2）将 cur 的 next 字段链接到 prev 的下一个结点 next ；\n\n\n\n（3）将 prev 中的 next 字段链接到 cur 。\n\n\n\n与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。\n\n# 单链表删除\n\n如果我们想从单链表中删除现有结点 cur，可以分两步完成：\n\n（1）找到 cur 的上一个结点 prev 及其下一个结点 next ；\n\n\n\n（2）接下来链接 prev 到 cur 的下一个节点 next 。\n\n\n\n在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须从头结点遍历链表，以找出 prev，它的平均时间是 O(N)，其中 N 是链表的长度。因此，删除结点的时间复杂度将是 O(N)。\n\n空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。\n\n\n# 双链表\n\n双链表中的每个结点不仅包含数据值，还包含两个指针，分别指向指向其前驱节点和后继节点。\n\n单链表的访问是单向的，而双链表的访问是双向的。显然，双链表比单链表操作更灵活，但是空间开销也更大。\n\n\n\n双链表以类似的方式工作，但还有一个引用字段，称为“prev”字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。\n\n# 双链表插入\n\n如果我们想在给定的结点 prev 之后添加新值，我们应该：\n\n（1）使用给定值初始化新结点 cur；\n\n\n\n（2）链接 cur 与 prev 和 next，其中 next 是 prev 原始的下一个节点；\n\n\n\n（3）用 cur 重新链接 prev 和 next。\n\n\n\n与单链表类似，添加操作的时间和空间复杂度都是 O(1)。\n\n# 双链表删除\n\n如果我们想从双链表中删除一个现有的结点 cur，我们可以简单地将它的前一个结点 prev 与下一个结点 next 链接起来。\n\n与单链表不同，使用 prev 字段可以很容易地在常量时间内获得前一个结点。\n\n因为我们不再需要遍历链表来获取前一个结点，所以时间和空间复杂度都是 O(1)。\n\n\n# 循环链表\n\n# 循环单链表\n\n循环单链表是一种特殊的单链表。它和单链表唯一的区别就在最后结点。\n\n * 单链表的最后一个结点的后继指针 next 指向空地址。\n * 循环链表的最后一个结点的后继指针 next 指向第一个节点（如果有头节点，就指向头节点）。\n\n\n\n# 循环双链表\n\n\n\n\n# 数组 vs. 链表\n\n * 存储方式\n   * 数组用 连续 的内存空间来存储数据。\n   * 链表用 不连续 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。\n * 访问方式\n   * 数组支持随机访问。根据下标随机访问的时间复杂度为 O(1)\n   * 链表不支持随机访问，只能顺序访问，时间复杂度为 O(n)。\n * 空间大小\n   * 数组空间大小固定，扩容只能采用复制数组的方式。\n   * 链表空间大小不固定，扩容灵活。\n * 效率比较\n   * 数组的 查找 效率高于链表。\n   * 链表的 添加、删除 效率高于数组。\n\n\n# 数组和链表的基本操作示例\n\n关于数组和链表的基本操作，网上和各种书籍、教程中已经有大量的示例，感兴趣可以自行搜索。本文只是简单展示一下数组和链表的基本操作。\n\n\n# 一维数组的基本操作\n\npublic class Main {\n    public static void main(String[] args) {\n        // 1. Initialize\n        int[] a0 = new int[5];\n        int[] a1 = {1, 2, 3};\n        // 2. Get Length\n        System.out.println("The size of a1 is: " + a1.length);\n        // 3. Access Element\n        System.out.println("The first element is: " + a1[0]);\n        // 4. Iterate all Elements\n        System.out.print("[Version 1] The contents of a1 are:");\n        for (int i = 0; i < a1.length; ++i) {\n            System.out.print(" " + a1[i]);\n        }\n        System.out.println();\n        System.out.print("[Version 2] The contents of a1 are:");\n        for (int item: a1) {\n            System.out.print(" " + item);\n        }\n        System.out.println();\n        // 5. Modify Element\n        a1[0] = 4;\n        // 6. Sort\n        Arrays.sort(a1);\n    }\n}\n\n\n\n# 二维数组的基本操作\n\npublic class TwoDimensionArray {\n    private static void printArray(int[][] a) {\n        for (int i = 0; i < a.length; ++i) {\n            System.out.println(a[i]);\n        }\n        for (int i = 0; i < a.length; ++i) {\n            for (int j = 0; a[i] != null && j < a[i].length; ++j) {\n                System.out.print(a[i][j] + " ");\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println("Example I:");\n        int[][] a = new int[2][5];\n        printArray(a);\n        System.out.println("Example II:");\n        int[][] b = new int[2][];\n        printArray(b);\n        System.out.println("Example III:");\n        b[0] = new int[3];\n        b[1] = new int[5];\n        printArray(b);\n    }\n}\n\n\n\n# 单链表的基本操作\n\n单链表节点的数据结构\n\npublic class ListNode<E> {\n    E value;\n    ListNode<E> next; // 指向后继节点\n}\n\npublic class SingleLinkList<E> {\n    private ListNode<E> head; // 头节点\n}\n\n\n（1）从头部添加节点（即头插法）\n\nvoid addHead(E value) {\n    ListNode<E> newNode = new ListNode<>(value, null);\n    newNode.next = this.head.next;\n    this.head.next = newNode;\n}\n\n\n（2）从尾部添加节点（即尾插法）\n\nvoid addTail(E value) {\n    // init new node\n    ListNode<E> newNode = new ListNode<>(value, null);\n\n    // find the last node\n    ListNode<E> node = this.head;\n    while (node.next != null) {\n        node = node.next;\n    }\n\n    // add new node to tail\n    node.next = newNode;\n}\n\n\n（3）删除节点\n\n找到要删除元素的前驱节点，将前驱节点的 next 指针指向下一个节点。\n\npublic void remove(E value) {\n    ListNode<E> prev = this.head;\n    while (prev.next != null) {\n        ListNode<E> curr = prev.next;\n        if (curr.value.equals(value)) {\n            prev.next = curr.next;\n            break;\n        }\n        prev = prev.next;\n    }\n}\n\n\n（4）查找节点\n\n从头开始查找，一旦发现有数值与查找值相等的节点，直接返回此节点。如果遍历结束，表明未找到节点，返回 null。\n\npublic ListNode<E> find(E value) {\n    ListNode<E> node = this.head.next;\n    while (node != null) {\n        if (node.value.equals(value)) {\n            return node;\n        }\n        node = node.next;\n    }\n    return null;\n}\n\n\n\n# 双链表的基本操作\n\n双链表节点的数据结构：\n\nstatic class DListNode<E> {\n    E value;\n    DListNode<E> prev; // 指向前驱节点\n    DListNode<E> next; // 指向后继节点\n}\n\npublic class DoubleLinkList<E> {\n    /** 头节点 */\n    private DListNode<E> head;\n    /** 尾节点 */\n    private DListNode<E> tail;\n}\n\n\n（1）从头部添加节点\n\npublic void addHead(E value) {\n    DListNode<E> newNode = new DListNode<>(null, value, null);\n\n    this.head.next.prev = newNode;\n    newNode.next = this.head.next;\n\n    this.head.next = newNode;\n    newNode.prev = this.head;\n}\n\n\n（2）从尾部添加节点\n\npublic void addTail(E value) {\n    DListNode<E> newNode = new DListNode<>(null, value, null);\n\n    this.tail.prev.next = newNode;\n    newNode.prev = this.tail.prev;\n\n    this.tail.prev = newNode;\n    newNode.next = this.tail;\n}\n\n\n（3）删除节点\n\npublic void remove(E value) {\n    DListNode<E> prev = this.head;\n    while (prev.next != this.tail) {\n        DListNode<E> curr = prev.next;\n        if (curr.value.equals(value)) {\n            prev.next = curr.next;\n            curr.next.prev = prev;\n            curr.next = null;\n            curr.prev = null;\n            break;\n        }\n        prev = prev.next;\n    }\n}\n\n\n（4）查找节点\n\npublic DListNode<E> find(E value) {\n    DListNode<E> node = this.head.next;\n    while (node != this.tail) {\n        if (node.value.equals(value)) {\n            return node;\n        }\n        node = node.next;\n    }\n    return null;\n}\n\n\n\n# 练习\n\n * 数组\n   * [x] 724. 寻找数组的中心下标\n   * [x] 35. 搜索插入位置\n   * [x] 56. 合并区间\n * 链表\n   * [ ] 设计链表\n   * [ ] 环形链表\n   * [ ] 环形链表 II\n   * [ ] 相交链表\n   * [ ] 删除链表的倒数第 N 个节点\n   * [ ] 反转链表\n   * [ ] 移除链表元素\n   * [ ] 奇偶链表\n   * [ ] 回文链表\n   * [ ] 合并两个有序链表\n   * [ ] 两数相加\n   * [ ] 扁平化多级双向链表\n   * [ ] 复制带随机指针的链表\n   * [ ] 旋转链表\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * 数据结构（C 语言版）\n * 数据结构（C++语言版）\n * Leetcode：数组和字符串\n * Leetcode：链表',normalizedContent:'# 数组和链表\n\n> 数组和链表分别代表了连续空间和不连续空间的存储方式，它们是线性表（linear list）的典型代表。其他所有的数据结构，比如栈、队列、二叉树、b+ 树等，实际上都是这两者的结合和变化。\n\n\n# 数组\n\n数组用 连续 的内存空间来存储数据。\n\n\n# 数组的访问\n\n数组元素的访问是以行或列索引的单一下标表示。\n\n\n\n在上面的例子中，数组 a 中有 5 个元素。也就是说，a 的长度是 6 。我们可以使用 a[0] 来表示数组中的第一个元素。因此，a[0] = a 。类似地，a[1] = b，a[2] = c，依此类推。\n\n\n# 数组的插入\n\n\n\n\n# 数组的删除\n\n\n\n\n# 数组的特性\n\n数组设计之初是在形式上依赖内存分配而成的，所以必须在使用前预先分配好空间大小。这使得数组有以下特性：\n\n 1. 用连续的内存空间来存储数据。\n 2. 数组支持随机访问，根据下标随机访问的时间复杂度为 o(1)。\n 3. 数组的插入、删除操作，平均时间复杂度为 o(n)。\n 4. 空间大小固定，一旦建立，不能再改变。扩容只能采用复制数组的方式。\n 5. 在旧式编程语言中（如有中阶语言之称的 c），程序不会对数组的操作做下界判断，也就有潜在的越界操作的风险。\n\n\n# 多维数组\n\n数组是有下标和值组成集合。\n\n如果数组的下标有多个维度，即为多维数组。比如：二维数组可以视为『数组元素为一维数组』的一维数组；三维数组可以视为『数组元素为二维数组』的一维数组；依次类推。\n\n下图是由 m 个行向量，n 个列向量组成的二维数组.\n\n\n\n\n# 链表\n\n> 链表用不连续的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。\n\n区别于数组，链表中的元素不是存储在内存中连续的一片区域，链表中的数据存储在每一个称之为「结点」复合区域里，在每一个结点除了存储数据以外，还保存了到下一个节点的指针（pointer）。由于不必按顺序存储，链表在插入数据的时候可以达到 o(1) 的复杂度，但是查找一个节点或者访问特定编号的节点则需要 o(n) 的时间。\n\n链表具有以下特性：\n\n * 链表允许插入和移除任意位置上的节点，其时间复杂度为 o(1)\n * 链表没有数组的随机访问特性，链表只支持顺序访问，其时间复杂度为 o(n)。\n * 数组的空间大小是固定的，而链表的空间大小可以动态增长。相比于数组，链表支持扩容，显然更为灵活，但是由于多了指针域，空间开销也更大。\n * 链表相比于数组，多了头指针、尾指针（非必要），合理使用可以大大提高访问效率。\n\n链表有多种类型：\n\n * 单链表\n * 双链表\n * 循环链表\n\n\n# 单链表\n\n单链表中的每个结点不仅包含数据值，还包含一个指针，指向其后继节点。通过这种方式，单链表将所有结点按顺序组织起来。\n\n\n\n与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按 索引 来 访问元素 平均要花费 o(n) 时间，其中 n 是链表的长度。\n\n# 单链表插入\n\n如果我们想在给定的结点 prev 之后添加新值，我们应该：\n\n（1）使用给定值初始化新结点 cur；\n\n\n\n（2）将 cur 的 next 字段链接到 prev 的下一个结点 next ；\n\n\n\n（3）将 prev 中的 next 字段链接到 cur 。\n\n\n\n与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 o(1) 时间复杂度中将新结点插入到链表中，这非常高效。\n\n# 单链表删除\n\n如果我们想从单链表中删除现有结点 cur，可以分两步完成：\n\n（1）找到 cur 的上一个结点 prev 及其下一个结点 next ；\n\n\n\n（2）接下来链接 prev 到 cur 的下一个节点 next 。\n\n\n\n在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须从头结点遍历链表，以找出 prev，它的平均时间是 o(n)，其中 n 是链表的长度。因此，删除结点的时间复杂度将是 o(n)。\n\n空间复杂度为 o(1)，因为我们只需要常量空间来存储指针。\n\n\n# 双链表\n\n双链表中的每个结点不仅包含数据值，还包含两个指针，分别指向指向其前驱节点和后继节点。\n\n单链表的访问是单向的，而双链表的访问是双向的。显然，双链表比单链表操作更灵活，但是空间开销也更大。\n\n\n\n双链表以类似的方式工作，但还有一个引用字段，称为“prev”字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。\n\n# 双链表插入\n\n如果我们想在给定的结点 prev 之后添加新值，我们应该：\n\n（1）使用给定值初始化新结点 cur；\n\n\n\n（2）链接 cur 与 prev 和 next，其中 next 是 prev 原始的下一个节点；\n\n\n\n（3）用 cur 重新链接 prev 和 next。\n\n\n\n与单链表类似，添加操作的时间和空间复杂度都是 o(1)。\n\n# 双链表删除\n\n如果我们想从双链表中删除一个现有的结点 cur，我们可以简单地将它的前一个结点 prev 与下一个结点 next 链接起来。\n\n与单链表不同，使用 prev 字段可以很容易地在常量时间内获得前一个结点。\n\n因为我们不再需要遍历链表来获取前一个结点，所以时间和空间复杂度都是 o(1)。\n\n\n# 循环链表\n\n# 循环单链表\n\n循环单链表是一种特殊的单链表。它和单链表唯一的区别就在最后结点。\n\n * 单链表的最后一个结点的后继指针 next 指向空地址。\n * 循环链表的最后一个结点的后继指针 next 指向第一个节点（如果有头节点，就指向头节点）。\n\n\n\n# 循环双链表\n\n\n\n\n# 数组 vs. 链表\n\n * 存储方式\n   * 数组用 连续 的内存空间来存储数据。\n   * 链表用 不连续 的内存空间来存储数据；并通过一个指针按顺序将这些空间串起来，形成一条链。\n * 访问方式\n   * 数组支持随机访问。根据下标随机访问的时间复杂度为 o(1)\n   * 链表不支持随机访问，只能顺序访问，时间复杂度为 o(n)。\n * 空间大小\n   * 数组空间大小固定，扩容只能采用复制数组的方式。\n   * 链表空间大小不固定，扩容灵活。\n * 效率比较\n   * 数组的 查找 效率高于链表。\n   * 链表的 添加、删除 效率高于数组。\n\n\n# 数组和链表的基本操作示例\n\n关于数组和链表的基本操作，网上和各种书籍、教程中已经有大量的示例，感兴趣可以自行搜索。本文只是简单展示一下数组和链表的基本操作。\n\n\n# 一维数组的基本操作\n\npublic class main {\n    public static void main(string[] args) {\n        // 1. initialize\n        int[] a0 = new int[5];\n        int[] a1 = {1, 2, 3};\n        // 2. get length\n        system.out.println("the size of a1 is: " + a1.length);\n        // 3. access element\n        system.out.println("the first element is: " + a1[0]);\n        // 4. iterate all elements\n        system.out.print("[version 1] the contents of a1 are:");\n        for (int i = 0; i < a1.length; ++i) {\n            system.out.print(" " + a1[i]);\n        }\n        system.out.println();\n        system.out.print("[version 2] the contents of a1 are:");\n        for (int item: a1) {\n            system.out.print(" " + item);\n        }\n        system.out.println();\n        // 5. modify element\n        a1[0] = 4;\n        // 6. sort\n        arrays.sort(a1);\n    }\n}\n\n\n\n# 二维数组的基本操作\n\npublic class twodimensionarray {\n    private static void printarray(int[][] a) {\n        for (int i = 0; i < a.length; ++i) {\n            system.out.println(a[i]);\n        }\n        for (int i = 0; i < a.length; ++i) {\n            for (int j = 0; a[i] != null && j < a[i].length; ++j) {\n                system.out.print(a[i][j] + " ");\n            }\n            system.out.println();\n        }\n    }\n\n    public static void main(string[] args) {\n        system.out.println("example i:");\n        int[][] a = new int[2][5];\n        printarray(a);\n        system.out.println("example ii:");\n        int[][] b = new int[2][];\n        printarray(b);\n        system.out.println("example iii:");\n        b[0] = new int[3];\n        b[1] = new int[5];\n        printarray(b);\n    }\n}\n\n\n\n# 单链表的基本操作\n\n单链表节点的数据结构\n\npublic class listnode<e> {\n    e value;\n    listnode<e> next; // 指向后继节点\n}\n\npublic class singlelinklist<e> {\n    private listnode<e> head; // 头节点\n}\n\n\n（1）从头部添加节点（即头插法）\n\nvoid addhead(e value) {\n    listnode<e> newnode = new listnode<>(value, null);\n    newnode.next = this.head.next;\n    this.head.next = newnode;\n}\n\n\n（2）从尾部添加节点（即尾插法）\n\nvoid addtail(e value) {\n    // init new node\n    listnode<e> newnode = new listnode<>(value, null);\n\n    // find the last node\n    listnode<e> node = this.head;\n    while (node.next != null) {\n        node = node.next;\n    }\n\n    // add new node to tail\n    node.next = newnode;\n}\n\n\n（3）删除节点\n\n找到要删除元素的前驱节点，将前驱节点的 next 指针指向下一个节点。\n\npublic void remove(e value) {\n    listnode<e> prev = this.head;\n    while (prev.next != null) {\n        listnode<e> curr = prev.next;\n        if (curr.value.equals(value)) {\n            prev.next = curr.next;\n            break;\n        }\n        prev = prev.next;\n    }\n}\n\n\n（4）查找节点\n\n从头开始查找，一旦发现有数值与查找值相等的节点，直接返回此节点。如果遍历结束，表明未找到节点，返回 null。\n\npublic listnode<e> find(e value) {\n    listnode<e> node = this.head.next;\n    while (node != null) {\n        if (node.value.equals(value)) {\n            return node;\n        }\n        node = node.next;\n    }\n    return null;\n}\n\n\n\n# 双链表的基本操作\n\n双链表节点的数据结构：\n\nstatic class dlistnode<e> {\n    e value;\n    dlistnode<e> prev; // 指向前驱节点\n    dlistnode<e> next; // 指向后继节点\n}\n\npublic class doublelinklist<e> {\n    /** 头节点 */\n    private dlistnode<e> head;\n    /** 尾节点 */\n    private dlistnode<e> tail;\n}\n\n\n（1）从头部添加节点\n\npublic void addhead(e value) {\n    dlistnode<e> newnode = new dlistnode<>(null, value, null);\n\n    this.head.next.prev = newnode;\n    newnode.next = this.head.next;\n\n    this.head.next = newnode;\n    newnode.prev = this.head;\n}\n\n\n（2）从尾部添加节点\n\npublic void addtail(e value) {\n    dlistnode<e> newnode = new dlistnode<>(null, value, null);\n\n    this.tail.prev.next = newnode;\n    newnode.prev = this.tail.prev;\n\n    this.tail.prev = newnode;\n    newnode.next = this.tail;\n}\n\n\n（3）删除节点\n\npublic void remove(e value) {\n    dlistnode<e> prev = this.head;\n    while (prev.next != this.tail) {\n        dlistnode<e> curr = prev.next;\n        if (curr.value.equals(value)) {\n            prev.next = curr.next;\n            curr.next.prev = prev;\n            curr.next = null;\n            curr.prev = null;\n            break;\n        }\n        prev = prev.next;\n    }\n}\n\n\n（4）查找节点\n\npublic dlistnode<e> find(e value) {\n    dlistnode<e> node = this.head.next;\n    while (node != this.tail) {\n        if (node.value.equals(value)) {\n            return node;\n        }\n        node = node.next;\n    }\n    return null;\n}\n\n\n\n# 练习\n\n * 数组\n   * [x] 724. 寻找数组的中心下标\n   * [x] 35. 搜索插入位置\n   * [x] 56. 合并区间\n * 链表\n   * [ ] 设计链表\n   * [ ] 环形链表\n   * [ ] 环形链表 ii\n   * [ ] 相交链表\n   * [ ] 删除链表的倒数第 n 个节点\n   * [ ] 反转链表\n   * [ ] 移除链表元素\n   * [ ] 奇偶链表\n   * [ ] 回文链表\n   * [ ] 合并两个有序链表\n   * [ ] 两数相加\n   * [ ] 扁平化多级双向链表\n   * [ ] 复制带随机指针的链表\n   * [ ] 旋转链表\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * 数据结构（c 语言版）\n * 数据结构（c++语言版）\n * leetcode：数组和字符串\n * leetcode：链表',charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"线性表的查找",frontmatter:{title:"线性表的查找",categories:["数据结构和算法","线性表"],tags:["数据结构","线性表","查找"],abbrlink:"443d1da2",date:"2015-03-10T18:29:13.000Z",permalink:"/pages/4b1ed0/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/11.%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE.html",relativePath:"01.数据结构和算法/01.线性表/11.线性表的查找.md",key:"v-f5961ec6",path:"/pages/4b1ed0/",headers:[{level:2,title:"查找简介",slug:"查找简介",normalizedTitle:"查找简介",charIndex:13},{level:3,title:"什么是查找？",slug:"什么是查找",normalizedTitle:"什么是查找？",charIndex:22},{level:3,title:"查找算法的分类",slug:"查找算法的分类",normalizedTitle:"查找算法的分类",charIndex:73},{level:3,title:"查找算法性能比较的标准",slug:"查找算法性能比较的标准",normalizedTitle:"查找算法性能比较的标准",charIndex:194},{level:2,title:"顺序查找",slug:"顺序查找",normalizedTitle:"顺序查找",charIndex:394},{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:981},{level:2,title:"分块查找",slug:"分块查找",normalizedTitle:"分块查找",charIndex:1957},{level:2,title:"三种线性查找的 PK",slug:"三种线性查找的-pk",normalizedTitle:"三种线性查找的 pk",charIndex:5478},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5672}],headersStr:"查找简介 什么是查找？ 查找算法的分类 查找算法性能比较的标准 顺序查找 二分查找 分块查找 三种线性查找的 PK 参考资料",content:'# 线性表的查找\n\n\n# 查找简介\n\n\n# 什么是查找？\n\n查找是根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。\n\n\n# 查找算法的分类\n\n若在查找的同时对表记录做修改操作（如插入和删除），则相应的表称之为动态查找表；\n\n否则，称之为静态查找表。\n\n此外，如果查找的全过程都在内存中进行，称之为内查找；\n\n反之，如果查找过程中需要访问外存，称之为外查找。\n\n\n# 查找算法性能比较的标准\n\n——平均查找长度 ASL（Average Search Length）\n\n由于查找算法的主要运算是关键字的比较过程，所以通常把查找过程中对关键字需要执行的平均比较长度（也称为平均比较次数）作为衡量一个查找算法效率优劣的比较标准。\n\n\n\n选取查找算法的因素\n\n(1) 使用什么数据存储结构（如线性表、树形表等）。\n\n(2) 表中的次序，即对无序表还是有序表进行查找。\n\n\n# 顺序查找\n\n要点\n\n它是一种最简单的查找算法，效率也很低下。\n\n存储结构\n\n没有存储结构要求，可以无序，也可以有序。\n\n基本思想\n\n从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值 k 相比较，若相等则表示查找成功；\n\n若扫描结束仍没有找到关键字等于 k 的结点，表示查找失败。\n\n核心代码\n\npublic int orderSearch(int[] list, int length, int key) {\n    // 从前往后扫描list数组，如果有元素的值与key相等，直接返回其位置\n    for (int i = 0; i < length; i++) {\n        if (key == list[i]) {\n            return i;\n        }\n    }\n\n    // 如果扫描完，说明没有元素的值匹配key，返回-1，表示查找失败\n    return -1;\n}\n\n\n算法分析\n\n顺序查找算法最好的情况是，第一个记录即匹配关键字，则需要比较 1 次；\n\n最坏的情况是，最后一个记录匹配关键字，则需要比较 N 次。\n\n所以，顺序查找算法的平均查找长度为\n\nASL = (N + N-1 + ... + 2 + 1) / N = (N+1) / 2\n\n顺序查找的平均时间复杂度为O(N)。\n\n\n# 二分查找\n\n> 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。\n\n存储结构\n\n使用二分查找需要两个前提：\n\n(1) 必须是顺序存储结构。\n\n(2) 必须是有序的表。\n\n基本思想\n\n首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；\n\n否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。 重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。\n\n核心代码\n\npublic int binarySearch(int[] list, int length, int key) {\n    int low = 0, mid = 0, high = length - 1;\n    while (low <= high) {\n        mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid; // 查找成功，直接返回位置\n        } else if (list[mid] < key) {\n            low = mid + 1; // 关键字大于中间位置的值，则在大值区间[mid+1, high]继续查找\n        } else {\n            high = mid - 1; // 关键字小于中间位置的值，则在小值区间[low, mid-1]继续查找\n        }\n    }\n    return -1;\n}\n\n\n算法分析\n\n二分查找的过程可看成一个二叉树。\n\n把查找区间的中间位置视为树的根，左区间和右区间视为根的左子树和右子树。\n\n由此得到的二叉树，称为二分查找的判定树或比较树。\n\n由此可知，二分查找的平均查找长度实际上就是树的高度O(log2N)。\n\n二分查找的局限性\n\n * 二分查找依赖的是顺序表结构，简单点说就是数组\n * 二分查找针对的是有序数据\n * 数据量太小不适合二分查找\n * 数据量太大也不适合二分查找\n\n\n# 分块查找\n\n要点\n\n分块查找(Blocking Search)又称索引顺序查找。它是一种性能介于顺序查找和二分查找之间的查找方法。\n\n分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。\n\n存储结构\n\n分块查找表是由**“分块有序”的线性表和索引表**两部分构成的。\n\n所谓**“分块有序”的线性表**，是指：\n\n假设要排序的表为 R[0...N-1]，将表均匀分成 b 块，前 b-1 块中记录个数为 s=N/b，最后一块记录数小于等于 s；\n\n每一块中的关键字不一定有序，但前一块中的最大关键字必须小于后一块中的最小关键字。\n\n注：这是使用分块查找的前提条件。\n\n如上将表均匀分成 b 块后，抽取各块中的最大关键字和起始位置构成一个索引表 IDX[0...b-1]。\n\n由于表 R 是分块有序的，所以索引表是一个递增有序表。\n\n下图就是一个分块查找表的存储结构示意图\n\n\n\n基本思想\n\n分块查找算法有两个处理步骤：\n\n(1) 首先查找索引表\n\n因为分块查找表是“分块有序”的，所以我们可以通过索引表来锁定关键字所在的区间。\n\n又因为索引表是递增有序的，所以查找索引可以使用顺序查找或二分查找。\n\n(2) 然后在已确定的块中进行顺序查找\n\n因为块中不一定是有序的，所以只能使用顺序查找。\n\n代码范例\n\n\n\nclass BlockSearch {\n\n    class IndexType {\n        public int key; // 分块中的最大值\n        public int link; // 分块的起始位置\n    }\n\n    // 建立索引方法，n 是线性表最大长度，gap是分块的最大长度\n    public IndexType[] createIndex(int[] list, int n, int gap) {\n        int i = 0, j = 0, max = 0;\n        int num = n / gap;\n        IndexType[] idxGroup = new IndexType[num]; // 根据步长数分配索引数组大小\n\n        while (i < num) {\n            j = 0;\n            idxGroup[i] = new IndexType();\n            idxGroup[i].link = gap * i; // 确定当前索引组的第一个元素位置\n            max = list[gap * i]; // 每次假设当前组的第一个数为最大值\n            // 遍历这个分块，找到最大值\n            while (j < gap) {\n                if (max < list[gap * i + j]) {\n                    max = list[gap * i + j];\n                }\n                j++;\n            }\n            idxGroup[i].key = max;\n            i++;\n        }\n\n        return idxGroup;\n    }\n\n    // 分块查找算法\n    public int blockSearch(IndexType[] idxGroup, int m, int[] list, int n, int key) {\n        int mid = 0;\n        int low = 0;\n        int high = m -1;\n        int gap = n / m; // 分块大小等于线性表长度除以组数\n\n        // 先在索引表中进行二分查找，找到的位置存放在 low 中\n        while (low <= high) {\n            mid = (low + high) / 2;\n            if (idxGroup[mid].key >= key) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // 在索引表中查找成功后，再在线性表的指定块中进行顺序查找\n        if (low < m) {\n            for (int i = idxGroup[low].link; i < idxGroup[low].link + gap; i++) {\n                if (list[i] == key)\n                    return i;\n            }\n        }\n\n        return -1;\n    }\n\n    // 打印完整序列\n    public void printAll(int[] list) {\n        for (int value : list) {\n            System.out.print(value + " ");\n        }\n        System.out.println();\n    }\n\n    // 打印索引表\n    public void printIDX(IndexType[] list) {\n        System.out.println("构造索引表如下：");\n        for (IndexType elem : list) {\n            System.out.format("key = %d, link = %d\\n", elem.key, elem.link);\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int key = 85;\n        int array2[] = { 8, 14, 6, 9, 10, 22, 34, 18, 19, 31, 40, 38, 54, 66, 46, 71, 78, 68, 80, 85 };\n        BlockSearch search = new BlockSearch();\n\n        System.out.print("线性表: ");\n        search.printAll(array2);\n\n        IndexType[] idxGroup = search.createIndex(array2, array2.length, 5);\n        search.printIDX(idxGroup);\n        int pos = search.blockSearch(idxGroup, idxGroup.length, array2,\n                array2.length, key);\n        if (-1 == pos) {\n            System.out.format("查找key = %d失败", key);\n        } else {\n            System.out.format("查找key = %d成功，位置为%d", key, pos);\n        }\n    }\n\n}\n\n\n运行结果\n\n线性表: 8 14 6 9 10 22 34 18 19 31 40 38 54 66 46 71 78 68 80 85\n构造索引表如下：\nkey = 14, link = 0\nkey = 34, link = 5\nkey = 66, link = 10\nkey = 85, link = 15\n\n查找key = 85成功，位置为19\n\n\n算法分析\n\n因为分块查找实际上是两次查找过程之和。若以二分查找来确定块，显然它的查找效率介于顺序查找和二分查找之间。\n\n\n# 三种线性查找的 PK\n\n(1) 以平均查找长度而言，二分查找 > 分块查找 > 顺序查找。\n\n(2) 从适用性而言，顺序查找无限制条件，二分查找仅适用于有序表，分块查找要求“分块有序”。\n\n(3) 从存储结构而言，顺序查找和分块查找既可用于顺序表也可用于链表；而二分查找只适用于顺序表。\n\n(4) 分块查找综合了顺序查找和二分查找的优点，既可以较为快速，也能使用动态变化的要求。\n\n\n# 参考资料',normalizedContent:'# 线性表的查找\n\n\n# 查找简介\n\n\n# 什么是查找？\n\n查找是根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。\n\n\n# 查找算法的分类\n\n若在查找的同时对表记录做修改操作（如插入和删除），则相应的表称之为动态查找表；\n\n否则，称之为静态查找表。\n\n此外，如果查找的全过程都在内存中进行，称之为内查找；\n\n反之，如果查找过程中需要访问外存，称之为外查找。\n\n\n# 查找算法性能比较的标准\n\n——平均查找长度 asl（average search length）\n\n由于查找算法的主要运算是关键字的比较过程，所以通常把查找过程中对关键字需要执行的平均比较长度（也称为平均比较次数）作为衡量一个查找算法效率优劣的比较标准。\n\n\n\n选取查找算法的因素\n\n(1) 使用什么数据存储结构（如线性表、树形表等）。\n\n(2) 表中的次序，即对无序表还是有序表进行查找。\n\n\n# 顺序查找\n\n要点\n\n它是一种最简单的查找算法，效率也很低下。\n\n存储结构\n\n没有存储结构要求，可以无序，也可以有序。\n\n基本思想\n\n从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值 k 相比较，若相等则表示查找成功；\n\n若扫描结束仍没有找到关键字等于 k 的结点，表示查找失败。\n\n核心代码\n\npublic int ordersearch(int[] list, int length, int key) {\n    // 从前往后扫描list数组，如果有元素的值与key相等，直接返回其位置\n    for (int i = 0; i < length; i++) {\n        if (key == list[i]) {\n            return i;\n        }\n    }\n\n    // 如果扫描完，说明没有元素的值匹配key，返回-1，表示查找失败\n    return -1;\n}\n\n\n算法分析\n\n顺序查找算法最好的情况是，第一个记录即匹配关键字，则需要比较 1 次；\n\n最坏的情况是，最后一个记录匹配关键字，则需要比较 n 次。\n\n所以，顺序查找算法的平均查找长度为\n\nasl = (n + n-1 + ... + 2 + 1) / n = (n+1) / 2\n\n顺序查找的平均时间复杂度为o(n)。\n\n\n# 二分查找\n\n> 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。\n\n存储结构\n\n使用二分查找需要两个前提：\n\n(1) 必须是顺序存储结构。\n\n(2) 必须是有序的表。\n\n基本思想\n\n首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；\n\n否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。 重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。\n\n核心代码\n\npublic int binarysearch(int[] list, int length, int key) {\n    int low = 0, mid = 0, high = length - 1;\n    while (low <= high) {\n        mid = (low + high) / 2;\n        if (list[mid] == key) {\n            return mid; // 查找成功，直接返回位置\n        } else if (list[mid] < key) {\n            low = mid + 1; // 关键字大于中间位置的值，则在大值区间[mid+1, high]继续查找\n        } else {\n            high = mid - 1; // 关键字小于中间位置的值，则在小值区间[low, mid-1]继续查找\n        }\n    }\n    return -1;\n}\n\n\n算法分析\n\n二分查找的过程可看成一个二叉树。\n\n把查找区间的中间位置视为树的根，左区间和右区间视为根的左子树和右子树。\n\n由此得到的二叉树，称为二分查找的判定树或比较树。\n\n由此可知，二分查找的平均查找长度实际上就是树的高度o(log2n)。\n\n二分查找的局限性\n\n * 二分查找依赖的是顺序表结构，简单点说就是数组\n * 二分查找针对的是有序数据\n * 数据量太小不适合二分查找\n * 数据量太大也不适合二分查找\n\n\n# 分块查找\n\n要点\n\n分块查找(blocking search)又称索引顺序查找。它是一种性能介于顺序查找和二分查找之间的查找方法。\n\n分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况。\n\n存储结构\n\n分块查找表是由**“分块有序”的线性表和索引表**两部分构成的。\n\n所谓**“分块有序”的线性表**，是指：\n\n假设要排序的表为 r[0...n-1]，将表均匀分成 b 块，前 b-1 块中记录个数为 s=n/b，最后一块记录数小于等于 s；\n\n每一块中的关键字不一定有序，但前一块中的最大关键字必须小于后一块中的最小关键字。\n\n注：这是使用分块查找的前提条件。\n\n如上将表均匀分成 b 块后，抽取各块中的最大关键字和起始位置构成一个索引表 idx[0...b-1]。\n\n由于表 r 是分块有序的，所以索引表是一个递增有序表。\n\n下图就是一个分块查找表的存储结构示意图\n\n\n\n基本思想\n\n分块查找算法有两个处理步骤：\n\n(1) 首先查找索引表\n\n因为分块查找表是“分块有序”的，所以我们可以通过索引表来锁定关键字所在的区间。\n\n又因为索引表是递增有序的，所以查找索引可以使用顺序查找或二分查找。\n\n(2) 然后在已确定的块中进行顺序查找\n\n因为块中不一定是有序的，所以只能使用顺序查找。\n\n代码范例\n\n\n\nclass blocksearch {\n\n    class indextype {\n        public int key; // 分块中的最大值\n        public int link; // 分块的起始位置\n    }\n\n    // 建立索引方法，n 是线性表最大长度，gap是分块的最大长度\n    public indextype[] createindex(int[] list, int n, int gap) {\n        int i = 0, j = 0, max = 0;\n        int num = n / gap;\n        indextype[] idxgroup = new indextype[num]; // 根据步长数分配索引数组大小\n\n        while (i < num) {\n            j = 0;\n            idxgroup[i] = new indextype();\n            idxgroup[i].link = gap * i; // 确定当前索引组的第一个元素位置\n            max = list[gap * i]; // 每次假设当前组的第一个数为最大值\n            // 遍历这个分块，找到最大值\n            while (j < gap) {\n                if (max < list[gap * i + j]) {\n                    max = list[gap * i + j];\n                }\n                j++;\n            }\n            idxgroup[i].key = max;\n            i++;\n        }\n\n        return idxgroup;\n    }\n\n    // 分块查找算法\n    public int blocksearch(indextype[] idxgroup, int m, int[] list, int n, int key) {\n        int mid = 0;\n        int low = 0;\n        int high = m -1;\n        int gap = n / m; // 分块大小等于线性表长度除以组数\n\n        // 先在索引表中进行二分查找，找到的位置存放在 low 中\n        while (low <= high) {\n            mid = (low + high) / 2;\n            if (idxgroup[mid].key >= key) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // 在索引表中查找成功后，再在线性表的指定块中进行顺序查找\n        if (low < m) {\n            for (int i = idxgroup[low].link; i < idxgroup[low].link + gap; i++) {\n                if (list[i] == key)\n                    return i;\n            }\n        }\n\n        return -1;\n    }\n\n    // 打印完整序列\n    public void printall(int[] list) {\n        for (int value : list) {\n            system.out.print(value + " ");\n        }\n        system.out.println();\n    }\n\n    // 打印索引表\n    public void printidx(indextype[] list) {\n        system.out.println("构造索引表如下：");\n        for (indextype elem : list) {\n            system.out.format("key = %d, link = %d\\n", elem.key, elem.link);\n        }\n        system.out.println();\n    }\n\n    public static void main(string[] args) {\n        int key = 85;\n        int array2[] = { 8, 14, 6, 9, 10, 22, 34, 18, 19, 31, 40, 38, 54, 66, 46, 71, 78, 68, 80, 85 };\n        blocksearch search = new blocksearch();\n\n        system.out.print("线性表: ");\n        search.printall(array2);\n\n        indextype[] idxgroup = search.createindex(array2, array2.length, 5);\n        search.printidx(idxgroup);\n        int pos = search.blocksearch(idxgroup, idxgroup.length, array2,\n                array2.length, key);\n        if (-1 == pos) {\n            system.out.format("查找key = %d失败", key);\n        } else {\n            system.out.format("查找key = %d成功，位置为%d", key, pos);\n        }\n    }\n\n}\n\n\n运行结果\n\n线性表: 8 14 6 9 10 22 34 18 19 31 40 38 54 66 46 71 78 68 80 85\n构造索引表如下：\nkey = 14, link = 0\nkey = 34, link = 5\nkey = 66, link = 10\nkey = 85, link = 15\n\n查找key = 85成功，位置为19\n\n\n算法分析\n\n因为分块查找实际上是两次查找过程之和。若以二分查找来确定块，显然它的查找效率介于顺序查找和二分查找之间。\n\n\n# 三种线性查找的 pk\n\n(1) 以平均查找长度而言，二分查找 > 分块查找 > 顺序查找。\n\n(2) 从适用性而言，顺序查找无限制条件，二分查找仅适用于有序表，分块查找要求“分块有序”。\n\n(3) 从存储结构而言，顺序查找和分块查找既可用于顺序表也可用于链表；而二分查找只适用于顺序表。\n\n(4) 分块查找综合了顺序查找和二分查找的优点，既可以较为快速，也能使用动态变化的要求。\n\n\n# 参考资料',charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"栈和队列",frontmatter:{title:"栈和队列",categories:["数据结构和算法"],tags:["数据结构","线性表","栈","队列"],abbrlink:"8d66b5f2",date:"2014-01-25T16:46:13.000Z",permalink:"/pages/1f15c3/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html",relativePath:"01.数据结构和算法/01.线性表/02.栈和队列.md",key:"v-113bfc22",path:"/pages/1f15c3/",headers:[{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:2},{level:3,title:"栈是什么",slug:"栈是什么",normalizedTitle:"栈是什么",charIndex:50},{level:3,title:"为什么需要栈",slug:"为什么需要栈",normalizedTitle:"为什么需要栈",charIndex:450},{level:3,title:"栈的应用场景",slug:"栈的应用场景",normalizedTitle:"栈的应用场景",charIndex:597},{level:2,title:"队列",slug:"队列",normalizedTitle:"队列",charIndex:4},{level:3,title:"什么是队列",slug:"什么是队列",normalizedTitle:"什么是队列",charIndex:805},{level:3,title:"循环队列",slug:"循环队列",normalizedTitle:"循环队列",charIndex:1024},{level:3,title:"为什么需要队列",slug:"为什么需要队列",normalizedTitle:"为什么需要队列",charIndex:1145},{level:3,title:"队列的应用场景",slug:"队列的应用场景",normalizedTitle:"队列的应用场景",charIndex:1190},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1509}],headersStr:"栈 栈是什么 为什么需要栈 栈的应用场景 队列 什么是队列 循环队列 为什么需要队列 队列的应用场景 参考资料",content:"# 栈和队列\n\n> 队列和栈都是操作受限的线性表：前者先进先出，后者先进后出。\n\n\n# 栈\n\n\n# 栈是什么\n\n在 LIFO(后进先出) 数据结构中，将首先处理添加到队列中的最新元素。\n\n栈是一个 LIFO(后进先出) 数据结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。\n\n\n\n当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。\n\n从栈的定义可以看出，栈只支持两个基本操作：入栈 push() 和 出栈 pop() ，也就是在栈顶插入一个数据和从栈顶删除一个数据。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。\n\n栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。\n\n\n# 为什么需要栈\n\n相比数组和链表，栈只是对操作进行了限制，似乎并没有任何优势。为什么不直接使用数组或者链表？为什么还要用这个“操作受限”的“栈”呢？\n\n特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。\n\n\n# 栈的应用场景\n\n（1）函数调用栈\n\n\n\n（2）表达式求值\n\n\n\n（3）表达式匹配\n\n可以借助栈来检查表达式中的括号是否匹配\n\n\n# 队列\n\n在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。\n\n队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。\n\n\n# 什么是队列\n\n队列：先进先出的线性表。\n\n队列是一种“操作受限”的线性表，只允许在一端插入数据，在另一端删除数据。\n\n队列的最基本操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。\n\n\n\n队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n\n队满的判断条件是 tail == n，队空的判断条件是 head == tail。\n\n\n# 循环队列\n\n循环队列是一种较为特殊的队列。\n\n循环队列的要点是确定好 队空和队满的判定条件。\n\n在用数组实现的非循环队列中，队满的判断条件是 (tail+1) % n == head，队空的判断条件是 head == tail。\n\n\n\n\n# 为什么需要队列\n\n为什么需要队列和为什么需要栈，是同样的道理，参考 为什么需要栈\n\n\n# 队列的应用场景\n\n（1）阻塞队列\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是：\n\n * 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；\n * 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n\n\n\n\n\n（2）并发队列\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * Leetcode：栈和队列",normalizedContent:"# 栈和队列\n\n> 队列和栈都是操作受限的线性表：前者先进先出，后者先进后出。\n\n\n# 栈\n\n\n# 栈是什么\n\n在 lifo(后进先出) 数据结构中，将首先处理添加到队列中的最新元素。\n\n栈是一个 lifo(后进先出) 数据结构。栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。\n\n\n\n当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。\n\n从栈的定义可以看出，栈只支持两个基本操作：入栈 push() 和 出栈 pop() ，也就是在栈顶插入一个数据和从栈顶删除一个数据。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 o(1)。\n\n栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。\n\n\n# 为什么需要栈\n\n相比数组和链表，栈只是对操作进行了限制，似乎并没有任何优势。为什么不直接使用数组或者链表？为什么还要用这个“操作受限”的“栈”呢？\n\n特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。\n\n\n# 栈的应用场景\n\n（1）函数调用栈\n\n\n\n（2）表达式求值\n\n\n\n（3）表达式匹配\n\n可以借助栈来检查表达式中的括号是否匹配\n\n\n# 队列\n\n在 fifo 数据结构中，将首先处理添加到队列中的第一个元素。\n\n队列是典型的 fifo 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。\n\n\n# 什么是队列\n\n队列：先进先出的线性表。\n\n队列是一种“操作受限”的线性表，只允许在一端插入数据，在另一端删除数据。\n\n队列的最基本操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。\n\n\n\n队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n\n队满的判断条件是 tail == n，队空的判断条件是 head == tail。\n\n\n# 循环队列\n\n循环队列是一种较为特殊的队列。\n\n循环队列的要点是确定好 队空和队满的判定条件。\n\n在用数组实现的非循环队列中，队满的判断条件是 (tail+1) % n == head，队空的判断条件是 head == tail。\n\n\n\n\n# 为什么需要队列\n\n为什么需要队列和为什么需要栈，是同样的道理，参考 为什么需要栈\n\n\n# 队列的应用场景\n\n（1）阻塞队列\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是：\n\n * 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；\n * 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n\n\n\n\n\n（2）并发队列\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 cas 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * leetcode：栈和队列",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"线性表的排序",frontmatter:{title:"线性表的排序",categories:["数据结构和算法","线性表"],tags:["数据结构","线性表","排序"],abbrlink:"d3b2b8db",date:"2015-03-03T17:37:24.000Z",permalink:"/pages/21c5f2/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01.%E7%BA%BF%E6%80%A7%E8%A1%A8/12.%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F.html",relativePath:"01.数据结构和算法/01.线性表/12.线性表的排序.md",key:"v-65e2e2da",path:"/pages/21c5f2/",headers:[{level:2,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:75},{level:3,title:"要点",slug:"要点",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"算法稳定性",slug:"算法稳定性",normalizedTitle:"算法稳定性",charIndex:1903},{level:4,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:2001},{level:3,title:"示例代码",slug:"示例代码",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:2932},{level:3,title:"要点",slug:"要点-2",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-2",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-2",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-2",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"空间复杂度",slug:"空间复杂度",normalizedTitle:"空间复杂度",charIndex:1504},{level:4,title:"算法稳定性",slug:"算法稳定性-2",normalizedTitle:"算法稳定性",charIndex:1903},{level:3,title:"示例代码",slug:"示例代码-2",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:5144},{level:3,title:"要点",slug:"要点-3",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-3",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-3",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-3",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"空间复杂度",slug:"空间复杂度-2",normalizedTitle:"空间复杂度",charIndex:1504},{level:4,title:"算法稳定性",slug:"算法稳定性-3",normalizedTitle:"算法稳定性",charIndex:1903},{level:3,title:"示例代码",slug:"示例代码-3",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:6804},{level:3,title:"要点",slug:"要点-4",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-4",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-4",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-4",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"算法稳定性",slug:"算法稳定性-4",normalizedTitle:"算法稳定性",charIndex:1903},{level:4,title:"直接插入排序和希尔排序的比较",slug:"直接插入排序和希尔排序的比较",normalizedTitle:"直接插入排序和希尔排序的比较",charIndex:8770},{level:3,title:"示例代码",slug:"示例代码-4",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"简单选择排序",slug:"简单选择排序",normalizedTitle:"简单选择排序",charIndex:9037},{level:3,title:"要点",slug:"要点-5",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-5",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-5",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-5",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"空间复杂度",slug:"空间复杂度-3",normalizedTitle:"空间复杂度",charIndex:1504},{level:3,title:"示例代码",slug:"示例代码-5",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:8662},{level:3,title:"要点",slug:"要点-6",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-6",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-6",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-6",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"算法稳定性",slug:"算法稳定性-5",normalizedTitle:"算法稳定性",charIndex:1903},{level:3,title:"示例代码",slug:"示例代码-6",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:12439},{level:3,title:"要点",slug:"要点-7",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法思想",slug:"算法思想-7",normalizedTitle:"算法思想",charIndex:167},{level:3,title:"算法分析",slug:"算法分析-7",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-7",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"空间复杂度",slug:"空间复杂度-4",normalizedTitle:"空间复杂度",charIndex:1504},{level:4,title:"算法稳定性",slug:"算法稳定性-6",normalizedTitle:"算法稳定性",charIndex:1903},{level:4,title:"归并排序和堆排序、快速排序的比较",slug:"归并排序和堆排序、快速排序的比较",normalizedTitle:"归并排序和堆排序、快速排序的比较",charIndex:15181},{level:3,title:"示例代码",slug:"示例代码-7",normalizedTitle:"示例代码",charIndex:41},{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:15371},{level:3,title:"要点",slug:"要点-8",normalizedTitle:"要点",charIndex:84},{level:3,title:"算法分析",slug:"算法分析-8",normalizedTitle:"算法分析",charIndex:1385},{level:4,title:"时间复杂度",slug:"时间复杂度-8",normalizedTitle:"时间复杂度",charIndex:1451},{level:4,title:"空间复杂度",slug:"空间复杂度-5",normalizedTitle:"空间复杂度",charIndex:1504},{level:4,title:"算法稳定性",slug:"算法稳定性-7",normalizedTitle:"算法稳定性",charIndex:1903},{level:3,title:"示例代码",slug:"示例代码-8",normalizedTitle:"示例代码",charIndex:41}],headersStr:"冒泡排序 要点 算法思想 算法分析 时间复杂度 算法稳定性 优化 示例代码 快速排序 要点 算法思想 算法分析 时间复杂度 空间复杂度 算法稳定性 示例代码 插入排序 要点 算法思想 算法分析 时间复杂度 空间复杂度 算法稳定性 示例代码 希尔排序 要点 算法思想 算法分析 时间复杂度 算法稳定性 直接插入排序和希尔排序的比较 示例代码 简单选择排序 要点 算法思想 算法分析 时间复杂度 空间复杂度 示例代码 堆排序 要点 算法思想 算法分析 时间复杂度 算法稳定性 示例代码 归并排序 要点 算法思想 算法分析 时间复杂度 空间复杂度 算法稳定性 归并排序和堆排序、快速排序的比较 示例代码 基数排序 要点 算法分析 时间复杂度 空间复杂度 算法稳定性 示例代码",content:'# 线性表的排序\n\n> 📦 本文已归档到：「blog」\n> \n> 🔁 本文中的示例代码已归档到：「algorithm-tutorial」\n\n\n# 冒泡排序\n\n\n# 要点\n\n冒泡排序是一种交换排序。\n\n什么是交换排序呢？\n\n> 交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。\n\n\n# 算法思想\n\n它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，故名。\n\n假设有一个大小为 N 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。\n\n\n\n以上图为例，演示一下冒泡排序的实际流程：\n\n假设有一个无序序列 { 4. 3. 1. 2, 5 }\n\n * 第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。\n * 第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。\n * 第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。\n\n至此，所有元素已经有序，排序结束。\n\n要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。\n\n * 假设要对一个大小为 N 的无序序列进行升序排序（即从小到大）。\n   * 每趟排序过程中需要通过比较找到第 i 个小的元素。\n   * 所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 N - 2) ，剩下最后一个元素，必然为最大。\n * 假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。\n   * 所以，需要一个内部循环，从数组末端开始（下标 N - 1），扫描到 (下标 i + 1)。\n\n核心代码\n\npublic void bubbleSort(int[] list) {\n    int temp = 0; // 用来交换的临时数\n\n    // 要遍历的次数\n    for (int i = 0; i < list.length - 1; i++) {\n        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上\n        for (int j = list.length - 1; j > i; j--) {\n            // 比较相邻的元素，如果前面的数大于后面的数，则交换\n            if (list[j - 1] > list[j]) {\n                temp = list[j - 1];\n                list[j - 1] = list[j];\n                list[j] = temp;\n            }\n        }\n\n        System.out.format("第 %d 趟：\\t", i);\n        printAll(list);\n    }\n}\n\n\n\n# 算法分析\n\n冒泡排序算法的性能\n\n参数          结果\n排序类别        交换排序\n排序方法        冒泡排序\n时间复杂度平均情况   O(N2)\n时间复杂度最坏情况   O(N3)\n时间复杂度最好情况   O(N)\n空间复杂度       O(1)\n稳定性         稳定\n复杂性         简单\n\n# 时间复杂度\n\n若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值：Cmin = N - 1, Mmin = 0。所以，冒泡排序最好时间复杂度为 O(N)。\n\n若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：\n\nCmax = N(N-1)/2 = O(N2)\n\nMmax = 3N(N-1)/2 = O(N2)\n\n冒泡排序的最坏时间复杂度为 O(N2)。\n\n因此，冒泡排序的平均时间复杂度为 O(N2)。\n\n总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。\n\n# 算法稳定性\n\n冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。\n\n所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n\n# 优化\n\n对冒泡排序常见的改进方法是加入标志性变量 exchange，用于标志某一趟排序过程中是否有数据交换。\n\n如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。\n\n核心代码\n\n// 对 bubbleSort 的优化算法\npublic void bubbleSort_2(int[] list) {\n    int temp = 0; // 用来交换的临时数\n    boolean bChange = false; // 交换标志\n\n    // 要遍历的次数\n    for (int i = 0; i < list.length - 1; i++) {\n        bChange = false;\n        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上\n        for (int j = list.length - 1; j > i; j--) {\n            // 比较相邻的元素，如果前面的数大于后面的数，则交换\n            if (list[j - 1] > list[j]) {\n                temp = list[j - 1];\n                list[j - 1] = list[j];\n                list[j] = temp;\n                bChange = true;\n            }\n        }\n\n        // 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序\n        if (false == bChange)\n            break;\n\n        System.out.format("第 %d 趟：\\t", i);\n        printAll(list);\n    }\n}\n\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 快速排序\n\n\n# 要点\n\n> 快速排序是一种交换排序。\n\n快速排序由 C. A. R. Hoare 在 1962 年提出。\n\n\n# 算法思想\n\n它的基本思想是：\n\n通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。\n\n然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n详细的图解往往比大堆的文字更有说明力，所以直接上图：\n\n\n\n上图中，演示了快速排序的处理过程：\n\n 1. 初始状态为一组无序的数组：2、4、5、1、3。\n 2. 经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。\n 3. 新的数组中，以 2 为分割点，左边都是比 2 小的数，右边都是比 2 大的数。\n 4. 因为 2 已经在数组中找到了合适的位置，所以不用再动。\n 5. 2 左边的数组只有一个元素 1，所以显然不用再排序，位置也被确定。（注：这种情况时，left 指针和 right 指针显然是重合的。因此在代码中，我们可以通过设置判定条件 left 必须小于 right，如果不满足，则不用排序了）。\n 6. 而对于 2 右边的数组 5、4、3，设置 left 指向 5，right 指向 3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序。\n\n核心代码\n\npublic int division(int[] list, int left, int right) {\n    // 以最左边的数(left)为基准\n    int base = list[left];\n    while (left < right) {\n        // 从序列右端开始，向左遍历，直到找到小于base的数\n        while (left < right && list[right] >= base)\n            right--;\n        // 找到了比base小的元素，将这个元素放到最左边的位置\n        list[left] = list[right];\n\n        // 从序列左端开始，向右遍历，直到找到大于base的数\n        while (left < right && list[left] <= base)\n            left++;\n        // 找到了比base大的元素，将这个元素放到最右边的位置\n        list[right] = list[left];\n    }\n\n    // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小；\n    // 而left位置的右侧数值应该都比left大。\n    list[left] = base;\n    return left;\n}\n\nprivate void quickSort(int[] list, int left, int right) {\n\n    // 左下标一定小于右下标，否则就越界了\n    if (left < right) {\n        // 对数组进行分割，取出下次分割的基准标号\n        int base = division(list, left, right);\n\n        System.out.format("base = %d:\\t", list[base]);\n        printPart(list, left, right);\n\n        // 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序\n        quickSort(list, left, base - 1);\n\n        // 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序\n        quickSort(list, base + 1, right);\n    }\n}\n\n\n\n# 算法分析\n\n快速排序算法的性能\n\n参数          结果\n排序类别        交换排序\n排序方法        快速排序\n时间复杂度平均情况   O(Nlog2N)\n时间复杂度最坏情况   O(N2)\n时间复杂度最好情况   O(Nlog2N)\n空间复杂度       O(Nlog2N)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。\n\n而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。\n\n所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。\n\n# 空间复杂度\n\n快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 Nlog2N 次的分割处理，所以占用空间也是 Nlog2N 个。\n\n# 算法稳定性\n\n在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 插入排序\n\n\n# 要点\n\n> 直接插入排序是一种最简单的插入排序。\n> \n> 插入排序：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，知道全部插入完成。\n\n\n# 算法思想\n\n在讲解直接插入排序之前，先让我们脑补一下我们打牌的过程。\n\n\n\n * 先拿一张 5 在手里，\n * 再摸到一张 4，比 5 小，插到 5 前面，\n * 摸到一张 6，嗯，比 5 大，插到 5 后面，\n * 摸到一张 8，比 6 大，插到 6 后面，\n * 。。。\n * 最后一看，我靠，凑到的居然是同花顺，这下牛逼大了。\n\n以上的过程，其实就是典型的直接插入排序，每次将一个新数据插入到有序队列中的合适位置里。\n\n很简单吧，接下来，我们要将这个算法转化为编程语言。\n\n假设有一组无序序列 R0, R1, ... , RN-1。\n\n * 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。\n * 然后，我们要依次把 R1, R2, ... , RN-1 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。\n * 接下来描述插入过程。假设这是要将 Ri 插入到前面有序的序列中。由前面所述，我们可知，插入 Ri 时，前 i-1 个数肯定已经是有序了。\n\n所以我们需要将 Ri 和 R0 ~ Ri-1 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。\n\n核心代码\n\npublic void insertSort(int[] list) {\n   // 打印第一个元素\n   System.out.format("i = %d:\\t", 0);\n   printPart(list, 0, 0);\n\n   // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列\n   for (int i = 1; i < list.length; i++) {\n       int j = 0;\n       int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置\n\n       // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位\n       for (j = i - 1; j >= 0 && temp < list[j]; j--) {\n           list[j + 1] = list[j];\n       }\n       list[j + 1] = temp;\n\n       System.out.format("i = %d:\\t", i);\n       printPart(list, 0, i);\n   }\n}\n\n\n\n# 算法分析\n\n直接插入排序的算法性能\n\n参数          结果\n排序类别        插入排序\n排序方法        直接插入排序\n时间复杂度平均情况   O(N2)\n时间复杂度最坏情况   O(N2)\n时间复杂度最好情况   O(N)\n空间复杂度       O(1)\n稳定性         稳定\n复杂性         简单\n\n# 时间复杂度\n\n当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为 O(N)。\n\n当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为 O(N2)。\n\n所以，数据越接近正序，直接插入排序的算法性能越好。\n\n# 空间复杂度\n\n由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 1 。\n\n# 算法稳定性\n\n直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 希尔排序\n\n\n# 要点\n\n> 希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。\n\n该方法因 DL．Shell 于 1959 年提出而得名。\n\n\n# 算法思想\n\n希尔排序的基本思想是：\n\n把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。 随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。\n\n我们来通过演示图，更深入的理解一下这个过程。\n\n\n\n在上面这幅图中：\n\n初始时，有一个大小为 10 的无序序列。\n\n * 在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。\n   * 接下来，按照直接插入排序的方法对每个组进行排序。\n * 在** 第二趟排序中**，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。\n   * 按照直接插入排序的方法对每个组进行排序。\n * 在第三趟排序中，再次把 gap 缩小一半，即 gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。\n   * 按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。\n\n需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。\n\n所以，希尔排序是不稳定的算法。\n\n核心代码\n\npublic void shellSort(int[] list) {\n   int gap = list.length / 2;\n\n   while (1 <= gap) {\n       // 把距离为 gap 的元素编为一个组，扫描所有组\n       for (int i = gap; i < list.length; i++) {\n           int j = 0;\n           int temp = list[i];\n\n           // 对距离为 gap 的元素组进行排序\n           for (j = i - gap; j >= 0 && temp < list[j]; j = j - gap) {\n               list[j + gap] = list[j];\n           }\n           list[j + gap] = temp;\n       }\n\n       System.out.format("gap = %d:\\t", gap);\n       printAll(list);\n       gap = gap / 2; // 减小增量\n   }\n}\n\n\n\n# 算法分析\n\n希尔排序的算法性能\n\n参数          结果\n排序类别        插入排序\n排序方法        希尔排序\n时间复杂度平均情况   O(Nlog2N)\n时间复杂度最坏情况   O(N1.5)\n时间复杂度最好情况   \n空间复杂度       O(1)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。\n\n算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为插入排序，这就保证了数据一定会被排序。\n\nDonald Shell 最初建议步长选择为 N/2 并且对步长取半直到步长达到 1。虽然这样取可以比 O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。\n\n已知的最好步长序列是由 Sedgewick 提出的(1, 5, 19, 41, 109,...)，该序列的项来自这两个算式。\n\n这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n\n# 算法稳定性\n\n由上文的希尔排序算法演示图即可知，希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。\n\n# 直接插入排序和希尔排序的比较\n\n * 直接插入排序是稳定的；而希尔排序是不稳定的。\n * 直接插入排序更适合于原始记录基本有序的集合。\n * 希尔排序的比较次数和移动次数都要比直接插入排序少，当 N 越大时，效果越明显。\n * 在希尔排序中，增量序列 gap 的取法必须满足：**最后一个步长必须是 1 。 **\n * 直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 简单选择排序\n\n\n# 要点\n\n> 简单选择排序是一种选择排序。\n> \n> 选择排序：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。\n\n\n# 算法思想\n\n 1. 从待排序序列中，找到关键字最小的元素；\n 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；\n 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。\n\n如图所示，每趟排序中，将当前**第 i 小的元素放在位置 i **上。\n\n核心代码\n\n\n\n\n# 算法分析\n\n简单选择排序算法的性能\n\n参数          结果\n排序类别        选择排序\n排序方法        简单选择排序\n时间复杂度平均情况   O(N2)\n时间复杂度最坏情况   O(N2)\n时间复杂度最好情况   O(N2)\n空间复杂度       O(1)\n稳定性         不稳定\n复杂性         简单\n\n# 时间复杂度\n\n简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则**比较次数总是 N (N - 1) / 2 **。\n\n而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.\n\n当序列反序时，移动次数最多，为 3N (N - 1) / 2。\n\n所以，综合以上，简单排序的时间复杂度为 O(N2)。\n\n# 空间复杂度\n\n简单选择排序需要占用一个临时空间，在交换数值时使用。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 堆排序\n\n\n# 要点\n\n在介绍堆排序之前，首先需要说明一下，堆是个什么玩意儿。\n\n堆是一棵顺序存储的完全二叉树。\n\n其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。 其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。 举例来说，对于 n 个元素的序列 {R0, R1, ... , Rn} 当且仅当满足下列关系之一时，称之为堆：\n\n * Ri <= R2i+1 且 Ri <= R2i+2 （小根堆）\n * Ri >= R2i+1 且 Ri >= R2i+2 （大根堆）\n\n其中 i=1,2,…,n/2 向下取整;\n\n\n\n如上图所示，序列 R{3, 8,15, 31, 25} 是一个典型的小根堆。\n\n堆中有两个父结点，元素 3 和元素 8。\n\n元素 3 在数组中以 R[0] 表示，它的左孩子结点是 R[1]，右孩子结点是 R[2]。\n\n元素 8 在数组中以 R[1] 表示，它的左孩子结点是 R[3]，右孩子结点是 R[4]，它的父结点是 R[0]。可以看出，它们满足以下规律：\n\n设当前元素在数组中以 R[i] 表示，那么，\n\n * 它的左孩子结点是：R[2*i+1];\n * 它的右孩子结点是：R[2*i+2];\n * 它的父结点是：R[(i-1)/2];\n * R[i] <= R[2*i+1] 且 R[i] <= R[2i+2]。\n\n\n# 算法思想\n\n * 首先，按堆的定义将数组 R[0..n]调整为堆（这个过程称为创建初始堆），交换 R[0]和 R[n]；\n * 然后，将 R[0..n-1]调整为堆，交换 R[0]和 R[n-1]；\n * 如此反复，直到交换了 R[0]和 R[1]为止。\n\n以上思想可归纳为两个操作：\n\n 1. 根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。\n 2. 每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。\n\n当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。\n\n先通过详细的实例图来看一下，如何构建初始堆。\n\n设有一个无序序列 { 1, 3,4, 5, 2, 6, 9, 7, 8, 0 }。\n\n\n\n构造了初始堆后，我们来看一下完整的堆排序处理：\n\n还是针对前面提到的无序序列 { 1,3, 4, 5, 2, 6, 9, 7, 8, 0 } 来加以说明。\n\n\n\n相信，通过以上两幅图，应该能很直观的演示堆排序的操作处理。\n\n核心代码\n\npublic void HeapAdjust(int[] array2, int parent, int length) {\n    int temp = array2[parent]; // temp保存当前父节点\n    int child = 2 * parent + 1; // 先获得左孩子\n\n    while (child < length) {\n        // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点\n        if (child + 1 < length && array2[child] < array2[child + 1]) {\n            child++;\n        }\n\n        // 如果父结点的值已经大于孩子结点的值，则直接结束\n        if (temp >= array2[child])\n            break;\n\n        // 把孩子结点的值赋给父结点\n        array2[parent] = array2[child];\n\n        // 选取孩子结点的左孩子结点,继续向下筛选\n        parent = child;\n        child = 2 * child + 1;\n    }\n\n    array2[parent] = temp;\n}\n\npublic void heapSort(int[] list) {\n    // 循环建立初始堆\n    for (int i = list.length / 2; i >= 0; i--) {\n        HeapAdjust(list, i, list.length);\n    }\n\n    // 进行n-1次循环，完成排序\n    for (int i = list.length - 1; i > 0; i--) {\n        // 最后一个元素和第一元素进行交换\n        int temp = list[i];\n        list[i] = list[0];\n        list[0] = temp;\n\n        // 筛选 R[0] 结点，得到i-1个结点的堆\n        HeapAdjust(list, 0, i);\n        System.out.format("第 %d 趟: \\t", list.length - i);\n        printPart(list, 0, list.length - 1);\n    }\n}\n\n\n\n# 算法分析\n\n堆排序算法的总体情况\n\n参数          结果\n排序类别        选择排序\n排序方法        堆排序\n时间复杂度平均情况   O(nlog2n)\n时间复杂度最坏情况   O(nlog2n)\n时间复杂度最好情况   O(nlog2n)\n空间复杂度       O(1)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n堆的存储表示是顺序的。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。\n\n当想得到一个序列中第 k 个最小的元素之前的部分排序序列，最好采用堆排序。\n\n因为堆排序的时间复杂度是 O(n+klog2n)，若 k ≤ n/log2n，则可得到的时间复杂度为 O(n)。\n\n# 算法稳定性\n\n堆排序是一种不稳定的排序方法。\n\n因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，\n\n因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 归并排序\n\n\n# 要点\n\n> 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用**分治法（Divide and Conquer）**的一个非常典型的应用。\n> \n> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n\n# 算法思想\n\n将待排序序列 R[0...n-1] 看成是 n 个长度为 1 的有序序列，将相邻的有序表成对归并，得到 n/2 个长度为 2 的有序表；将这些有序序列再次归并，得到 n/4 个长度为 4 的有序序列；如此反复进行下去，最后得到一个长度为 n 的有序序列。\n\n综上可知：\n\n归并排序其实要做两件事：\n\n * “分解”——将序列每次折半划分。\n * “合并”——将划分后的序列段两两合并后排序。\n\n我们先来考虑第二步，如何合并？\n\n在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。\n\n这两个有序序列段分别为 R[low, mid] 和 R[mid+1, high]。\n\n先将他们合并到一个局部的暂存数组R2 中，带合并完成后再将 R2 复制回 R 中。\n\n为了方便描述，我们称 R[low, mid] 第一段，R[mid+1, high] 为第二段。\n\n每次从两个段中取出一个记录进行关键字的比较，将较小者放入 R2 中。最后将各段中余下的部分直接复制到 R2 中。\n\n经过这样的过程，R2 已经是一个有序的序列，再将其复制回 R 中，一次合并排序就完成了。\n\n核心代码\n\npublic void Merge(int[] array2, int low, int mid, int high) {\n    int i = low; // i是第一段序列的下标\n    int j = mid + 1; // j是第二段序列的下标\n    int k = 0; // k是临时存放合并序列的下标\n    int[] array2 = new int[high - low + 1]; // array2是临时合并序列\n\n    // 扫描第一段和第二段序列，直到有一个扫描结束\n    while (i <= mid && j <= high) {\n        // 判断第一段和第二段取出的数哪个更小，将其存入合并序列，并继续向下扫描\n        if (array2[i] <= array2[j]) {\n            array2[k] = array2[i];\n            i++;\n            k++;\n        } else {\n            array2[k] = array2[j];\n            j++;\n            k++;\n        }\n    }\n\n    // 若第一段序列还没扫描完，将其全部复制到合并序列\n    while (i <= mid) {\n        array2[k] = array2[i];\n        i++;\n        k++;\n    }\n\n    // 若第二段序列还没扫描完，将其全部复制到合并序列\n    while (j <= high) {\n        array2[k] = array2[j];\n        j++;\n        k++;\n    }\n\n    // 将合并序列复制到原始序列中\n    for (k = 0, i = low; i <= high; i++, k++) {\n        array2[i] = array2[k];\n    }\n}\n\n\n掌握了合并的方法，接下来，让我们来了解如何分解。\n\n\n\n在某趟归并中，设各子表的长度为 gap，则归并前 R[0...n-1] 中共有 n/gap 个有序的子表：R[0...gap-1], R[gap...2*gap-1], ... , R[(n/gap)*gap ... n-1]。\n\n调用 Merge 将相邻的子表归并时，必须对表的特殊情况进行特殊处理。\n\n若子表个数为奇数，则最后一个子表无须和其他子表归并（即本趟处理轮空）：若子表个数为偶数，则要注意到最后一对子表中后一个子表区间的上限为 n-1。\n\n核心代码\n\npublic void MergePass(int[] array2, int gap, int length) {\n    int i = 0;\n\n    // 归并gap长度的两个相邻子表\n    for (i = 0; i + 2 * gap - 1 < length; i = i + 2 * gap) {\n        Merge(array2, i, i + gap - 1, i + 2 * gap - 1);\n    }\n\n    // 余下两个子表，后者长度小于gap\n    if (i + gap - 1 < length) {\n        Merge(array2, i, i + gap - 1, length - 1);\n    }\n}\n\npublic int[] sort(int[] list) {\n    for (int gap = 1; gap < list.length; gap = 2 * gap) {\n        MergePass(list, gap, list.length);\n        System.out.print("gap = " + gap + ":\\t");\n        this.printAll(list);\n    }\n    return list;\n}\n\n\n\n# 算法分析\n\n归并排序算法的性能\n\n参数          结果\n排序类别        归并排序\n排序方法        归并排序\n时间复杂度平均情况   O(nlog2n)\n时间复杂度最坏情况   O(nlog2n)\n时间复杂度最好情况   O(nlog2n)\n空间复杂度       O(n)\n稳定性         稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是 O(n*log2n)。\n\n# 空间复杂度\n\n由前面的算法说明可知，算法处理过程中，需要一个大小为 n 的临时存储空间用以保存合并序列。\n\n# 算法稳定性\n\n在归并排序中，相等的元素的顺序不会改变，所以它是稳定的算法。\n\n# 归并排序和堆排序、快速排序的比较\n\n若从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。\n\n若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。\n\n若从平均情况下的排序速度考虑，应该选择快速排序。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 基数排序\n\n\n# 要点\n\n基数排序与本系列前面讲解的七种排序方法都不同，它不需要比较关键字的大小。\n\n它是根据关键字中各位的值，通过对排序的 N 个元素进行若干趟“分配”与“收集”来实现排序的。\n\n不妨通过一个具体的实例来展示一下，基数排序是如何进行的。\n\n设有一个初始序列为: R {50, 123, 543, 187, 49, 30,0, 2, 11, 100}。\n\n我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的。\n\n所以我们不妨把 0~9 视为 10 个桶。\n\n我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。\n\n\n\n分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。\n\n这时，得到的序列就是个位数上呈递增趋势的序列。\n\n按照个位数排序： {50, 30, 0, 100, 11, 2, 123,543, 187, 49}。\n\n接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。\n\n\n# 算法分析\n\n基数排序的性能\n\n参数          结果\n排序类别        基数排序\n排序方法        基数排序\n时间复杂度平均情况   O(d(n+r))\n时间复杂度最坏情况   O(d(n+r))\n时间复杂度最好情况   O(d(n+r))\n空间复杂度       O(n+r)\n稳定性         稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n通过上文可知，假设在基数排序中，r 为基数，d 为位数。则基数排序的时间复杂度为 O(d(n+r))。\n\n我们可以看出，基数排序的效率和初始序列是否有序没有关联。\n\n# 空间复杂度\n\n在基数排序过程中，对于任何位数上的基数进行“装桶”操作时，都需要 n+r 个临时空间。\n\n# 算法稳定性\n\n在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是稳定的算法。\n\n\n# 示例代码\n\n我的 Github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。',normalizedContent:'# 线性表的排序\n\n> 📦 本文已归档到：「blog」\n> \n> 🔁 本文中的示例代码已归档到：「algorithm-tutorial」\n\n\n# 冒泡排序\n\n\n# 要点\n\n冒泡排序是一种交换排序。\n\n什么是交换排序呢？\n\n> 交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。\n\n\n# 算法思想\n\n它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，故名。\n\n假设有一个大小为 n 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。\n\n\n\n以上图为例，演示一下冒泡排序的实际流程：\n\n假设有一个无序序列 { 4. 3. 1. 2, 5 }\n\n * 第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。\n * 第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。\n * 第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。\n\n至此，所有元素已经有序，排序结束。\n\n要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。\n\n * 假设要对一个大小为 n 的无序序列进行升序排序（即从小到大）。\n   * 每趟排序过程中需要通过比较找到第 i 个小的元素。\n   * 所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 n - 2) ，剩下最后一个元素，必然为最大。\n * 假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。\n   * 所以，需要一个内部循环，从数组末端开始（下标 n - 1），扫描到 (下标 i + 1)。\n\n核心代码\n\npublic void bubblesort(int[] list) {\n    int temp = 0; // 用来交换的临时数\n\n    // 要遍历的次数\n    for (int i = 0; i < list.length - 1; i++) {\n        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上\n        for (int j = list.length - 1; j > i; j--) {\n            // 比较相邻的元素，如果前面的数大于后面的数，则交换\n            if (list[j - 1] > list[j]) {\n                temp = list[j - 1];\n                list[j - 1] = list[j];\n                list[j] = temp;\n            }\n        }\n\n        system.out.format("第 %d 趟：\\t", i);\n        printall(list);\n    }\n}\n\n\n\n# 算法分析\n\n冒泡排序算法的性能\n\n参数          结果\n排序类别        交换排序\n排序方法        冒泡排序\n时间复杂度平均情况   o(n2)\n时间复杂度最坏情况   o(n3)\n时间复杂度最好情况   o(n)\n空间复杂度       o(1)\n稳定性         稳定\n复杂性         简单\n\n# 时间复杂度\n\n若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 c 和记录移动次数 m 均达到最小值：cmin = n - 1, mmin = 0。所以，冒泡排序最好时间复杂度为 o(n)。\n\n若初始文件是反序的，需要进行 n -1 趟排序。每趟排序要进行 n - i 次关键字的比较(1 ≤ i ≤ n - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：\n\ncmax = n(n-1)/2 = o(n2)\n\nmmax = 3n(n-1)/2 = o(n2)\n\n冒泡排序的最坏时间复杂度为 o(n2)。\n\n因此，冒泡排序的平均时间复杂度为 o(n2)。\n\n总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。\n\n# 算法稳定性\n\n冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。\n\n所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n\n# 优化\n\n对冒泡排序常见的改进方法是加入标志性变量 exchange，用于标志某一趟排序过程中是否有数据交换。\n\n如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。\n\n核心代码\n\n// 对 bubblesort 的优化算法\npublic void bubblesort_2(int[] list) {\n    int temp = 0; // 用来交换的临时数\n    boolean bchange = false; // 交换标志\n\n    // 要遍历的次数\n    for (int i = 0; i < list.length - 1; i++) {\n        bchange = false;\n        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上\n        for (int j = list.length - 1; j > i; j--) {\n            // 比较相邻的元素，如果前面的数大于后面的数，则交换\n            if (list[j - 1] > list[j]) {\n                temp = list[j - 1];\n                list[j - 1] = list[j];\n                list[j] = temp;\n                bchange = true;\n            }\n        }\n\n        // 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序\n        if (false == bchange)\n            break;\n\n        system.out.format("第 %d 趟：\\t", i);\n        printall(list);\n    }\n}\n\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 快速排序\n\n\n# 要点\n\n> 快速排序是一种交换排序。\n\n快速排序由 c. a. r. hoare 在 1962 年提出。\n\n\n# 算法思想\n\n它的基本思想是：\n\n通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。\n\n然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n详细的图解往往比大堆的文字更有说明力，所以直接上图：\n\n\n\n上图中，演示了快速排序的处理过程：\n\n 1. 初始状态为一组无序的数组：2、4、5、1、3。\n 2. 经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。\n 3. 新的数组中，以 2 为分割点，左边都是比 2 小的数，右边都是比 2 大的数。\n 4. 因为 2 已经在数组中找到了合适的位置，所以不用再动。\n 5. 2 左边的数组只有一个元素 1，所以显然不用再排序，位置也被确定。（注：这种情况时，left 指针和 right 指针显然是重合的。因此在代码中，我们可以通过设置判定条件 left 必须小于 right，如果不满足，则不用排序了）。\n 6. 而对于 2 右边的数组 5、4、3，设置 left 指向 5，right 指向 3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序。\n\n核心代码\n\npublic int division(int[] list, int left, int right) {\n    // 以最左边的数(left)为基准\n    int base = list[left];\n    while (left < right) {\n        // 从序列右端开始，向左遍历，直到找到小于base的数\n        while (left < right && list[right] >= base)\n            right--;\n        // 找到了比base小的元素，将这个元素放到最左边的位置\n        list[left] = list[right];\n\n        // 从序列左端开始，向右遍历，直到找到大于base的数\n        while (left < right && list[left] <= base)\n            left++;\n        // 找到了比base大的元素，将这个元素放到最右边的位置\n        list[right] = list[left];\n    }\n\n    // 最后将base放到left位置。此时，left位置的左侧数值应该都比left小；\n    // 而left位置的右侧数值应该都比left大。\n    list[left] = base;\n    return left;\n}\n\nprivate void quicksort(int[] list, int left, int right) {\n\n    // 左下标一定小于右下标，否则就越界了\n    if (left < right) {\n        // 对数组进行分割，取出下次分割的基准标号\n        int base = division(list, left, right);\n\n        system.out.format("base = %d:\\t", list[base]);\n        printpart(list, left, right);\n\n        // 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序\n        quicksort(list, left, base - 1);\n\n        // 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序\n        quicksort(list, base + 1, right);\n    }\n}\n\n\n\n# 算法分析\n\n快速排序算法的性能\n\n参数          结果\n排序类别        交换排序\n排序方法        快速排序\n时间复杂度平均情况   o(nlog2n)\n时间复杂度最坏情况   o(n2)\n时间复杂度最好情况   o(nlog2n)\n空间复杂度       o(nlog2n)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。\n\n而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。\n\n所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。\n\n# 空间复杂度\n\n快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 nlog2n 次的分割处理，所以占用空间也是 nlog2n 个。\n\n# 算法稳定性\n\n在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 插入排序\n\n\n# 要点\n\n> 直接插入排序是一种最简单的插入排序。\n> \n> 插入排序：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，知道全部插入完成。\n\n\n# 算法思想\n\n在讲解直接插入排序之前，先让我们脑补一下我们打牌的过程。\n\n\n\n * 先拿一张 5 在手里，\n * 再摸到一张 4，比 5 小，插到 5 前面，\n * 摸到一张 6，嗯，比 5 大，插到 5 后面，\n * 摸到一张 8，比 6 大，插到 6 后面，\n * 。。。\n * 最后一看，我靠，凑到的居然是同花顺，这下牛逼大了。\n\n以上的过程，其实就是典型的直接插入排序，每次将一个新数据插入到有序队列中的合适位置里。\n\n很简单吧，接下来，我们要将这个算法转化为编程语言。\n\n假设有一组无序序列 r0, r1, ... , rn-1。\n\n * 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。\n * 然后，我们要依次把 r1, r2, ... , rn-1 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 n-1 。\n * 接下来描述插入过程。假设这是要将 ri 插入到前面有序的序列中。由前面所述，我们可知，插入 ri 时，前 i-1 个数肯定已经是有序了。\n\n所以我们需要将 ri 和 r0 ~ ri-1 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。\n\n核心代码\n\npublic void insertsort(int[] list) {\n   // 打印第一个元素\n   system.out.format("i = %d:\\t", 0);\n   printpart(list, 0, 0);\n\n   // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列\n   for (int i = 1; i < list.length; i++) {\n       int j = 0;\n       int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置\n\n       // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位\n       for (j = i - 1; j >= 0 && temp < list[j]; j--) {\n           list[j + 1] = list[j];\n       }\n       list[j + 1] = temp;\n\n       system.out.format("i = %d:\\t", i);\n       printpart(list, 0, i);\n   }\n}\n\n\n\n# 算法分析\n\n直接插入排序的算法性能\n\n参数          结果\n排序类别        插入排序\n排序方法        直接插入排序\n时间复杂度平均情况   o(n2)\n时间复杂度最坏情况   o(n2)\n时间复杂度最好情况   o(n)\n空间复杂度       o(1)\n稳定性         稳定\n复杂性         简单\n\n# 时间复杂度\n\n当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为 o(n)。\n\n当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为 o(n2)。\n\n所以，数据越接近正序，直接插入排序的算法性能越好。\n\n# 空间复杂度\n\n由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 1 。\n\n# 算法稳定性\n\n直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 希尔排序\n\n\n# 要点\n\n> 希尔(shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。\n\n该方法因 dl．shell 于 1959 年提出而得名。\n\n\n# 算法思想\n\n希尔排序的基本思想是：\n\n把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。 随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。\n\n我们来通过演示图，更深入的理解一下这个过程。\n\n\n\n在上面这幅图中：\n\n初始时，有一个大小为 10 的无序序列。\n\n * 在第一趟排序中，我们不妨设 gap1 = n / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。\n   * 接下来，按照直接插入排序的方法对每个组进行排序。\n * 在** 第二趟排序中**，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。\n   * 按照直接插入排序的方法对每个组进行排序。\n * 在第三趟排序中，再次把 gap 缩小一半，即 gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。\n   * 按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。\n\n需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。\n\n所以，希尔排序是不稳定的算法。\n\n核心代码\n\npublic void shellsort(int[] list) {\n   int gap = list.length / 2;\n\n   while (1 <= gap) {\n       // 把距离为 gap 的元素编为一个组，扫描所有组\n       for (int i = gap; i < list.length; i++) {\n           int j = 0;\n           int temp = list[i];\n\n           // 对距离为 gap 的元素组进行排序\n           for (j = i - gap; j >= 0 && temp < list[j]; j = j - gap) {\n               list[j + gap] = list[j];\n           }\n           list[j + gap] = temp;\n       }\n\n       system.out.format("gap = %d:\\t", gap);\n       printall(list);\n       gap = gap / 2; // 减小增量\n   }\n}\n\n\n\n# 算法分析\n\n希尔排序的算法性能\n\n参数          结果\n排序类别        插入排序\n排序方法        希尔排序\n时间复杂度平均情况   o(nlog2n)\n时间复杂度最坏情况   o(n1.5)\n时间复杂度最好情况   \n空间复杂度       o(1)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。\n\n算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为插入排序，这就保证了数据一定会被排序。\n\ndonald shell 最初建议步长选择为 n/2 并且对步长取半直到步长达到 1。虽然这样取可以比 o(n2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。\n\n已知的最好步长序列是由 sedgewick 提出的(1, 5, 19, 41, 109,...)，该序列的项来自这两个算式。\n\n这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。\n\n# 算法稳定性\n\n由上文的希尔排序算法演示图即可知，希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。\n\n# 直接插入排序和希尔排序的比较\n\n * 直接插入排序是稳定的；而希尔排序是不稳定的。\n * 直接插入排序更适合于原始记录基本有序的集合。\n * 希尔排序的比较次数和移动次数都要比直接插入排序少，当 n 越大时，效果越明显。\n * 在希尔排序中，增量序列 gap 的取法必须满足：**最后一个步长必须是 1 。 **\n * 直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 简单选择排序\n\n\n# 要点\n\n> 简单选择排序是一种选择排序。\n> \n> 选择排序：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。\n\n\n# 算法思想\n\n 1. 从待排序序列中，找到关键字最小的元素；\n 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；\n 3. 从余下的 n - 1 个元素中，找出关键字最小的元素，重复 1、2 步，直到排序结束。\n\n如图所示，每趟排序中，将当前**第 i 小的元素放在位置 i **上。\n\n核心代码\n\n\n\n\n# 算法分析\n\n简单选择排序算法的性能\n\n参数          结果\n排序类别        选择排序\n排序方法        简单选择排序\n时间复杂度平均情况   o(n2)\n时间复杂度最坏情况   o(n2)\n时间复杂度最好情况   o(n2)\n空间复杂度       o(1)\n稳定性         不稳定\n复杂性         简单\n\n# 时间复杂度\n\n简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 n 个元素，则**比较次数总是 n (n - 1) / 2 **。\n\n而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.\n\n当序列反序时，移动次数最多，为 3n (n - 1) / 2。\n\n所以，综合以上，简单排序的时间复杂度为 o(n2)。\n\n# 空间复杂度\n\n简单选择排序需要占用一个临时空间，在交换数值时使用。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 堆排序\n\n\n# 要点\n\n在介绍堆排序之前，首先需要说明一下，堆是个什么玩意儿。\n\n堆是一棵顺序存储的完全二叉树。\n\n其中每个结点的关键字都不大于其孩子结点的关键字，这样的堆称为小根堆。 其中每个结点的关键字都不小于其孩子结点的关键字，这样的堆称为大根堆。 举例来说，对于 n 个元素的序列 {r0, r1, ... , rn} 当且仅当满足下列关系之一时，称之为堆：\n\n * ri <= r2i+1 且 ri <= r2i+2 （小根堆）\n * ri >= r2i+1 且 ri >= r2i+2 （大根堆）\n\n其中 i=1,2,…,n/2 向下取整;\n\n\n\n如上图所示，序列 r{3, 8,15, 31, 25} 是一个典型的小根堆。\n\n堆中有两个父结点，元素 3 和元素 8。\n\n元素 3 在数组中以 r[0] 表示，它的左孩子结点是 r[1]，右孩子结点是 r[2]。\n\n元素 8 在数组中以 r[1] 表示，它的左孩子结点是 r[3]，右孩子结点是 r[4]，它的父结点是 r[0]。可以看出，它们满足以下规律：\n\n设当前元素在数组中以 r[i] 表示，那么，\n\n * 它的左孩子结点是：r[2*i+1];\n * 它的右孩子结点是：r[2*i+2];\n * 它的父结点是：r[(i-1)/2];\n * r[i] <= r[2*i+1] 且 r[i] <= r[2i+2]。\n\n\n# 算法思想\n\n * 首先，按堆的定义将数组 r[0..n]调整为堆（这个过程称为创建初始堆），交换 r[0]和 r[n]；\n * 然后，将 r[0..n-1]调整为堆，交换 r[0]和 r[n-1]；\n * 如此反复，直到交换了 r[0]和 r[1]为止。\n\n以上思想可归纳为两个操作：\n\n 1. 根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。\n 2. 每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。\n\n当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。\n\n先通过详细的实例图来看一下，如何构建初始堆。\n\n设有一个无序序列 { 1, 3,4, 5, 2, 6, 9, 7, 8, 0 }。\n\n\n\n构造了初始堆后，我们来看一下完整的堆排序处理：\n\n还是针对前面提到的无序序列 { 1,3, 4, 5, 2, 6, 9, 7, 8, 0 } 来加以说明。\n\n\n\n相信，通过以上两幅图，应该能很直观的演示堆排序的操作处理。\n\n核心代码\n\npublic void heapadjust(int[] array2, int parent, int length) {\n    int temp = array2[parent]; // temp保存当前父节点\n    int child = 2 * parent + 1; // 先获得左孩子\n\n    while (child < length) {\n        // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点\n        if (child + 1 < length && array2[child] < array2[child + 1]) {\n            child++;\n        }\n\n        // 如果父结点的值已经大于孩子结点的值，则直接结束\n        if (temp >= array2[child])\n            break;\n\n        // 把孩子结点的值赋给父结点\n        array2[parent] = array2[child];\n\n        // 选取孩子结点的左孩子结点,继续向下筛选\n        parent = child;\n        child = 2 * child + 1;\n    }\n\n    array2[parent] = temp;\n}\n\npublic void heapsort(int[] list) {\n    // 循环建立初始堆\n    for (int i = list.length / 2; i >= 0; i--) {\n        heapadjust(list, i, list.length);\n    }\n\n    // 进行n-1次循环，完成排序\n    for (int i = list.length - 1; i > 0; i--) {\n        // 最后一个元素和第一元素进行交换\n        int temp = list[i];\n        list[i] = list[0];\n        list[0] = temp;\n\n        // 筛选 r[0] 结点，得到i-1个结点的堆\n        heapadjust(list, 0, i);\n        system.out.format("第 %d 趟: \\t", list.length - i);\n        printpart(list, 0, list.length - 1);\n    }\n}\n\n\n\n# 算法分析\n\n堆排序算法的总体情况\n\n参数          结果\n排序类别        选择排序\n排序方法        堆排序\n时间复杂度平均情况   o(nlog2n)\n时间复杂度最坏情况   o(nlog2n)\n时间复杂度最好情况   o(nlog2n)\n空间复杂度       o(1)\n稳定性         不稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n堆的存储表示是顺序的。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。\n\n当想得到一个序列中第 k 个最小的元素之前的部分排序序列，最好采用堆排序。\n\n因为堆排序的时间复杂度是 o(n+klog2n)，若 k ≤ n/log2n，则可得到的时间复杂度为 o(n)。\n\n# 算法稳定性\n\n堆排序是一种不稳定的排序方法。\n\n因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，\n\n因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 归并排序\n\n\n# 要点\n\n> 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用**分治法（divide and conquer）**的一个非常典型的应用。\n> \n> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n\n# 算法思想\n\n将待排序序列 r[0...n-1] 看成是 n 个长度为 1 的有序序列，将相邻的有序表成对归并，得到 n/2 个长度为 2 的有序表；将这些有序序列再次归并，得到 n/4 个长度为 4 的有序序列；如此反复进行下去，最后得到一个长度为 n 的有序序列。\n\n综上可知：\n\n归并排序其实要做两件事：\n\n * “分解”——将序列每次折半划分。\n * “合并”——将划分后的序列段两两合并后排序。\n\n我们先来考虑第二步，如何合并？\n\n在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。\n\n这两个有序序列段分别为 r[low, mid] 和 r[mid+1, high]。\n\n先将他们合并到一个局部的暂存数组r2 中，带合并完成后再将 r2 复制回 r 中。\n\n为了方便描述，我们称 r[low, mid] 第一段，r[mid+1, high] 为第二段。\n\n每次从两个段中取出一个记录进行关键字的比较，将较小者放入 r2 中。最后将各段中余下的部分直接复制到 r2 中。\n\n经过这样的过程，r2 已经是一个有序的序列，再将其复制回 r 中，一次合并排序就完成了。\n\n核心代码\n\npublic void merge(int[] array2, int low, int mid, int high) {\n    int i = low; // i是第一段序列的下标\n    int j = mid + 1; // j是第二段序列的下标\n    int k = 0; // k是临时存放合并序列的下标\n    int[] array2 = new int[high - low + 1]; // array2是临时合并序列\n\n    // 扫描第一段和第二段序列，直到有一个扫描结束\n    while (i <= mid && j <= high) {\n        // 判断第一段和第二段取出的数哪个更小，将其存入合并序列，并继续向下扫描\n        if (array2[i] <= array2[j]) {\n            array2[k] = array2[i];\n            i++;\n            k++;\n        } else {\n            array2[k] = array2[j];\n            j++;\n            k++;\n        }\n    }\n\n    // 若第一段序列还没扫描完，将其全部复制到合并序列\n    while (i <= mid) {\n        array2[k] = array2[i];\n        i++;\n        k++;\n    }\n\n    // 若第二段序列还没扫描完，将其全部复制到合并序列\n    while (j <= high) {\n        array2[k] = array2[j];\n        j++;\n        k++;\n    }\n\n    // 将合并序列复制到原始序列中\n    for (k = 0, i = low; i <= high; i++, k++) {\n        array2[i] = array2[k];\n    }\n}\n\n\n掌握了合并的方法，接下来，让我们来了解如何分解。\n\n\n\n在某趟归并中，设各子表的长度为 gap，则归并前 r[0...n-1] 中共有 n/gap 个有序的子表：r[0...gap-1], r[gap...2*gap-1], ... , r[(n/gap)*gap ... n-1]。\n\n调用 merge 将相邻的子表归并时，必须对表的特殊情况进行特殊处理。\n\n若子表个数为奇数，则最后一个子表无须和其他子表归并（即本趟处理轮空）：若子表个数为偶数，则要注意到最后一对子表中后一个子表区间的上限为 n-1。\n\n核心代码\n\npublic void mergepass(int[] array2, int gap, int length) {\n    int i = 0;\n\n    // 归并gap长度的两个相邻子表\n    for (i = 0; i + 2 * gap - 1 < length; i = i + 2 * gap) {\n        merge(array2, i, i + gap - 1, i + 2 * gap - 1);\n    }\n\n    // 余下两个子表，后者长度小于gap\n    if (i + gap - 1 < length) {\n        merge(array2, i, i + gap - 1, length - 1);\n    }\n}\n\npublic int[] sort(int[] list) {\n    for (int gap = 1; gap < list.length; gap = 2 * gap) {\n        mergepass(list, gap, list.length);\n        system.out.print("gap = " + gap + ":\\t");\n        this.printall(list);\n    }\n    return list;\n}\n\n\n\n# 算法分析\n\n归并排序算法的性能\n\n参数          结果\n排序类别        归并排序\n排序方法        归并排序\n时间复杂度平均情况   o(nlog2n)\n时间复杂度最坏情况   o(nlog2n)\n时间复杂度最好情况   o(nlog2n)\n空间复杂度       o(n)\n稳定性         稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是 o(n*log2n)。\n\n# 空间复杂度\n\n由前面的算法说明可知，算法处理过程中，需要一个大小为 n 的临时存储空间用以保存合并序列。\n\n# 算法稳定性\n\n在归并排序中，相等的元素的顺序不会改变，所以它是稳定的算法。\n\n# 归并排序和堆排序、快速排序的比较\n\n若从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。\n\n若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。\n\n若从平均情况下的排序速度考虑，应该选择快速排序。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。\n\n\n# 基数排序\n\n\n# 要点\n\n基数排序与本系列前面讲解的七种排序方法都不同，它不需要比较关键字的大小。\n\n它是根据关键字中各位的值，通过对排序的 n 个元素进行若干趟“分配”与“收集”来实现排序的。\n\n不妨通过一个具体的实例来展示一下，基数排序是如何进行的。\n\n设有一个初始序列为: r {50, 123, 543, 187, 49, 30,0, 2, 11, 100}。\n\n我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0~9 来表示的。\n\n所以我们不妨把 0~9 视为 10 个桶。\n\n我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：r[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。\n\n\n\n分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。\n\n这时，得到的序列就是个位数上呈递增趋势的序列。\n\n按照个位数排序： {50, 30, 0, 100, 11, 2, 123,543, 187, 49}。\n\n接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。\n\n\n# 算法分析\n\n基数排序的性能\n\n参数          结果\n排序类别        基数排序\n排序方法        基数排序\n时间复杂度平均情况   o(d(n+r))\n时间复杂度最坏情况   o(d(n+r))\n时间复杂度最好情况   o(d(n+r))\n空间复杂度       o(n+r)\n稳定性         稳定\n复杂性         较复杂\n\n# 时间复杂度\n\n通过上文可知，假设在基数排序中，r 为基数，d 为位数。则基数排序的时间复杂度为 o(d(n+r))。\n\n我们可以看出，基数排序的效率和初始序列是否有序没有关联。\n\n# 空间复杂度\n\n在基数排序过程中，对于任何位数上的基数进行“装桶”操作时，都需要 n+r 个临时空间。\n\n# 算法稳定性\n\n在基数排序过程中，每次都是将当前位数上相同数值的元素统一“装桶”，并不需要交换位置。所以基数排序是稳定的算法。\n\n\n# 示例代码\n\n我的 github 测试例\n\n样本包含：数组个数为奇数、偶数的情况；元素重复或不重复的情况。且样本均为随机样本，实测有效。',charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"复杂度分析",frontmatter:{title:"复杂度分析",categories:["数据结构和算法","综合"],tags:["数据结构","算法"],abbrlink:"a1a87ec3",date:"2022-03-20T23:25:17.000Z",permalink:"/pages/2a4131/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/00.%E7%BB%BC%E5%90%88/02.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html",relativePath:"01.数据结构和算法/00.综合/02.复杂度分析.md",key:"v-1afcd619",path:"/pages/2a4131/",headers:[{level:2,title:"为什么需要复杂度分析",slug:"为什么需要复杂度分析",normalizedTitle:"为什么需要复杂度分析",charIndex:12},{level:2,title:"时间复杂度分析",slug:"时间复杂度分析",normalizedTitle:"时间复杂度分析",charIndex:223},{level:3,title:"大 O 表示法",slug:"大-o-表示法",normalizedTitle:"大 o 表示法",charIndex:235},{level:3,title:"时间复杂度分析的要点",slug:"时间复杂度分析的要点",normalizedTitle:"时间复杂度分析的要点",charIndex:491},{level:3,title:"最好、最坏和平均情况",slug:"最好、最坏和平均情况",normalizedTitle:"最好、最坏和平均情况",charIndex:586},{level:3,title:"时间复杂度分析示例",slug:"时间复杂度分析示例",normalizedTitle:"时间复杂度分析示例",charIndex:897},{level:2,title:"空间复杂度分析",slug:"空间复杂度分析",normalizedTitle:"空间复杂度分析",charIndex:1382},{level:2,title:"复杂度量级",slug:"复杂度量级",normalizedTitle:"复杂度量级",charIndex:1510},{level:2,title:"常见数据结构的复杂度",slug:"常见数据结构的复杂度",normalizedTitle:"常见数据结构的复杂度",charIndex:2292},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2309}],headersStr:"为什么需要复杂度分析 时间复杂度分析 大 O 表示法 时间复杂度分析的要点 最好、最坏和平均情况 时间复杂度分析示例 空间复杂度分析 复杂度量级 常见数据结构的复杂度 参考资料",content:'# 复杂度分析\n\n\n# 为什么需要复杂度分析\n\n衡量算法的优劣，有两种评估方式：事前估计和后期测试。\n\n后期测试有性能测试、基准测试（Benchmark）等手段。\n\n但是，后期测试有以下限制：\n\n * 测试结果非常依赖测试环境。如：不同机型、不同编译器版本、不同硬件配置等等，都会影响测试结果。\n * 测试结果受数据规模的影响很大。\n\n所以，需要一种方法，可以不受环境或数据规模的影响，粗略地估计算法的执行效率。这种方法就是复杂度分析。\n\n\n# 时间复杂度分析\n\n\n# 大 O 表示法\n\n假设问题的规模为 n，则程序的时间复杂度表示为 T(n)。代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。\n\n当 n 增大时，T(n) 也随之增大，想要准确估计其变化比较困难。所以，可以采用大 O 时间复杂度来粗略估计其复杂度，其表达式为：T(n) = O(f(n))。\n\n大 O 表示法实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。\n\n\n# 时间复杂度分析的要点\n\n * 只关注循环执行次数最多的一段代码\n * 加法法则：总复杂度等于量级最大的那段代码的复杂度\n * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n\n# 最好、最坏和平均情况\n\n * 最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行代码的时间复杂度。例如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，此时最好情况时间复杂度为 1。\n * 最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行代码的时间复杂度。例如：在最理想的情况下，要查找的变量 x 正好是数组的最后个元素，此时最好情况时间复杂度为 n。\n * 平均情况时间复杂度（average case time complexity）：平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。\n\n\n# 时间复杂度分析示例\n\n【示例】从 1 累加到 100 的时间复杂度是多少？\n\nint sum = 0;\nint N = 100;\nfor (int i = 1; i <= N; i++) {\n    sum = sum + i;\n}\n\n\n时间复杂度计算：显然，这段代码执行了 100 次加法，其时间复杂度和 N 的大小完全一致\n\nT(n) = O(n)\n\n\n【示例】嵌套循环的时间复杂度是多少？\n\nint M = 10;\nint N = 20;\nfor (int i = 1; i < M; i++) {\n    for (int j = 1; j < N; j++) {\n        System.out.println("i = " + i + ", j = " + j);\n    }\n}\n\n\n时间复杂度计算：\n\nT(n) = (M-1)(N-1) = O(M*N) ≈ O(N^2)\n\n\n【示例】递归函数的时间复杂度是多少？思考一下斐波那契数列 f(n) = f(n-1) + f(n-2) 的时间复杂度是多少？\n\n\n\nT(n) = O(2^N)\n\n\n\n# 空间复杂度分析\n\n时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。\n\n类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n\n\n# 复杂度量级\n\n复杂度有以下量级：\n\n * O(1)：常数复杂度\n * O(log n)：对数复杂度\n * O(n)：线性复杂度\n * O(nlog n)：线性对数阶复杂度\n * O(n^2)：平方复杂度\n * O(n^3)：立方复杂度\n * O(n^k)：K 次方复杂度\n * O(2^n)：指数复杂度\n * O(n!)：阶乘复杂度\n\n在数据量比较小的时候，复杂度量级差异并不明显；但是，随着数据规模大小的变化，差异会逐渐突出。\n\n\n\nO(1) 复杂度示例：\n\nint num = 100;\nSystem.out.println("num = " + num);\n\n\nO(log n) 对数复杂度示例：\n\nint max = 100;\nfor (int i = 1; i < max; i = i * 2) {\n    System.out.println("i = " + i);\n}\n\n\nO(n) 复杂度示例：\n\nint max = 100;\nfor (int i = 1; i < max; i++) {\n    System.out.println("i = " + i);\n}\n\n\nO(n^2) 复杂度示例：\n\nint M = 10;\nint N = 20;\nfor (int i = 1; i < M; i++) {\n    for (int j = 1; j < N; j++) {\n        System.out.println("i = " + i + ", j = " + j);\n    }\n}\n\n\nO(k^n) 复杂度示例：\n\nint max = 10;\nfor (int i = 1; i <= Math.pow(2, max); i++) {\n    System.out.println("i = " + i);\n}\n\n\n\n# 常见数据结构的复杂度\n\n\n\n\n# 参考资料\n\n * 数据结构与算法之美',normalizedContent:'# 复杂度分析\n\n\n# 为什么需要复杂度分析\n\n衡量算法的优劣，有两种评估方式：事前估计和后期测试。\n\n后期测试有性能测试、基准测试（benchmark）等手段。\n\n但是，后期测试有以下限制：\n\n * 测试结果非常依赖测试环境。如：不同机型、不同编译器版本、不同硬件配置等等，都会影响测试结果。\n * 测试结果受数据规模的影响很大。\n\n所以，需要一种方法，可以不受环境或数据规模的影响，粗略地估计算法的执行效率。这种方法就是复杂度分析。\n\n\n# 时间复杂度分析\n\n\n# 大 o 表示法\n\n假设问题的规模为 n，则程序的时间复杂度表示为 t(n)。代码的执行时间 t(n) 与每行代码的执行次数 n 成正比。\n\n当 n 增大时，t(n) 也随之增大，想要准确估计其变化比较困难。所以，可以采用大 o 时间复杂度来粗略估计其复杂度，其表达式为：t(n) = o(f(n))。\n\n大 o 表示法实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。\n\n\n# 时间复杂度分析的要点\n\n * 只关注循环执行次数最多的一段代码\n * 加法法则：总复杂度等于量级最大的那段代码的复杂度\n * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n\n# 最好、最坏和平均情况\n\n * 最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行代码的时间复杂度。例如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，此时最好情况时间复杂度为 1。\n * 最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行代码的时间复杂度。例如：在最理想的情况下，要查找的变量 x 正好是数组的最后个元素，此时最好情况时间复杂度为 n。\n * 平均情况时间复杂度（average case time complexity）：平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。\n\n\n# 时间复杂度分析示例\n\n【示例】从 1 累加到 100 的时间复杂度是多少？\n\nint sum = 0;\nint n = 100;\nfor (int i = 1; i <= n; i++) {\n    sum = sum + i;\n}\n\n\n时间复杂度计算：显然，这段代码执行了 100 次加法，其时间复杂度和 n 的大小完全一致\n\nt(n) = o(n)\n\n\n【示例】嵌套循环的时间复杂度是多少？\n\nint m = 10;\nint n = 20;\nfor (int i = 1; i < m; i++) {\n    for (int j = 1; j < n; j++) {\n        system.out.println("i = " + i + ", j = " + j);\n    }\n}\n\n\n时间复杂度计算：\n\nt(n) = (m-1)(n-1) = o(m*n) ≈ o(n^2)\n\n\n【示例】递归函数的时间复杂度是多少？思考一下斐波那契数列 f(n) = f(n-1) + f(n-2) 的时间复杂度是多少？\n\n\n\nt(n) = o(2^n)\n\n\n\n# 空间复杂度分析\n\n时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。\n\n类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。\n\n\n# 复杂度量级\n\n复杂度有以下量级：\n\n * o(1)：常数复杂度\n * o(log n)：对数复杂度\n * o(n)：线性复杂度\n * o(nlog n)：线性对数阶复杂度\n * o(n^2)：平方复杂度\n * o(n^3)：立方复杂度\n * o(n^k)：k 次方复杂度\n * o(2^n)：指数复杂度\n * o(n!)：阶乘复杂度\n\n在数据量比较小的时候，复杂度量级差异并不明显；但是，随着数据规模大小的变化，差异会逐渐突出。\n\n\n\no(1) 复杂度示例：\n\nint num = 100;\nsystem.out.println("num = " + num);\n\n\no(log n) 对数复杂度示例：\n\nint max = 100;\nfor (int i = 1; i < max; i = i * 2) {\n    system.out.println("i = " + i);\n}\n\n\no(n) 复杂度示例：\n\nint max = 100;\nfor (int i = 1; i < max; i++) {\n    system.out.println("i = " + i);\n}\n\n\no(n^2) 复杂度示例：\n\nint m = 10;\nint n = 20;\nfor (int i = 1; i < m; i++) {\n    for (int j = 1; j < n; j++) {\n        system.out.println("i = " + i + ", j = " + j);\n    }\n}\n\n\no(k^n) 复杂度示例：\n\nint max = 10;\nfor (int i = 1; i <= math.pow(2, max); i++) {\n    system.out.println("i = " + i);\n}\n\n\n\n# 常见数据结构的复杂度\n\n\n\n\n# 参考资料\n\n * 数据结构与算法之美',charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"树和二叉树",frontmatter:{title:"树和二叉树",categories:["数据结构和算法","树"],tags:["数据结构","树","二叉树","完全二叉树"],abbrlink:"dd5c0739",date:"2014-06-15T15:39:23.000Z",permalink:"/pages/92e4c1/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/01.%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"01.数据结构和算法/02.树/01.树和二叉树.md",key:"v-4002eec4",path:"/pages/92e4c1/",headers:[{level:2,title:"树",slug:"树",normalizedTitle:"树",charIndex:2},{level:3,title:"什么是树",slug:"什么是树",normalizedTitle:"什么是树",charIndex:18},{level:3,title:"树的术语",slug:"树的术语",normalizedTitle:"树的术语",charIndex:278},{level:3,title:"树的性质",slug:"树的性质",normalizedTitle:"树的性质",charIndex:699},{level:3,title:"树的种类",slug:"树的种类",normalizedTitle:"树的种类",charIndex:872},{level:2,title:"二叉树",slug:"二叉树",normalizedTitle:"二叉树",charIndex:4},{level:3,title:"二叉树的性质",slug:"二叉树的性质",normalizedTitle:"二叉树的性质",charIndex:1326},{level:3,title:"满二叉树",slug:"满二叉树",normalizedTitle:"满二叉树",charIndex:1079},{level:3,title:"完全二叉树",slug:"完全二叉树",normalizedTitle:"完全二叉树",charIndex:985},{level:3,title:"二叉树的遍历",slug:"二叉树的遍历",normalizedTitle:"二叉树的遍历",charIndex:2108},{level:2,title:"二叉查找树",slug:"二叉查找树",normalizedTitle:"二叉查找树",charIndex:1156},{level:3,title:"二叉查找树的查找",slug:"二叉查找树的查找",normalizedTitle:"二叉查找树的查找",charIndex:2449},{level:3,title:"二叉查找树的插入",slug:"二叉查找树的插入",normalizedTitle:"二叉查找树的插入",charIndex:2571},{level:3,title:"二叉查找树的删除",slug:"二叉查找树的删除",normalizedTitle:"二叉查找树的删除",charIndex:2723},{level:3,title:"二叉查找树的时间复杂度",slug:"二叉查找树的时间复杂度",normalizedTitle:"二叉查找树的时间复杂度",charIndex:3014},{level:3,title:"为什么需要二叉查找树",slug:"为什么需要二叉查找树",normalizedTitle:"为什么需要二叉查找树",charIndex:3201},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3665}],headersStr:"树 什么是树 树的术语 树的性质 树的种类 二叉树 二叉树的性质 满二叉树 完全二叉树 二叉树的遍历 二叉查找树 二叉查找树的查找 二叉查找树的插入 二叉查找树的删除 二叉查找树的时间复杂度 为什么需要二叉查找树 参考资料",content:"# 树和二叉树\n\n\n# 树\n\n\n# 什么是树\n\n在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n\n它具有以下的特点：\n\n * 每个节点都只有有限个子节点或无子节点。\n * 树有且仅有一个根节点。\n * 根节点没有父节点；非根节点有且仅有一个父节点。\n * 每个非根节点可以分为多个不相交的子树。\n * 树里面没有环路。\n\n\n\n\n# 树的术语\n\n * 节点的度：一个节点含有的子树的个数称为该节点的度；\n * 树的度：一棵树中，最大的节点度称为树的度；\n * 叶子节点或终端节点：度为零的节点；\n * 非终端节点或分支节点：度不为零的节点；\n * 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n * 子节点：一个节点含有的子树的根节点称为该节点的子节点；\n * 兄弟节点：具有相同父节点的节点互称为兄弟节点；\n * 堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n * 节点的祖先：从根到该节点所经分支上的所有节点；\n * 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n * 森林：由 m（m>=0）棵互不相交的树的集合称为森林；\n\n\n\n * 节点的高度：节点到叶子节点的最长路径。高度是从下往上度量。\n * 节点的深度：根节点到该节点的最长路径。深度是从上往下度量。\n * 节点的层次：节点的深度 + 1。\n * 树的高度：根节点的高度。\n\n\n# 树的性质\n\n * 树中的节点数等于所有节点的度数加 1。\n * 度为 m 的树中第 i 层上至多有 $$m^{i-1}$$ 个节点（$$i ≥ 1$$）。\n * 高度为 h 的 m 次树至多有 $$(m^h-1)/(m-1)$$ 个节点。\n * 具有 n 个节点的 m 次树的最小高度为 $$\\log_m{(n(m-1)+1)}$$ 。\n\n\n# 树的种类\n\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；\n\n有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；\n\n * 二叉树：每个节点最多含有两个子树的树称为二叉树；\n   * 完全二叉树：对于一颗二叉树，假设其深度为 d（d>1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；\n * 满二叉树：所有叶节点都在最底层的完全二叉树；\n * 平衡二叉树（AVL 树）：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；\n * 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉树；\n * 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；\n * B 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。\n\n\n# 二叉树\n\n二叉树中的每个节点最多有两个子节点，分别是左子节点和右子节点。\n\n\n# 二叉树的性质\n\n 1. 二叉树第 i 层上的结点数目最多为 2i-1 (i≥1)。\n 2. 深度为 k 的二叉树至多有 2k-1 个结点(k≥1)。\n 3. 包含 n 个结点的二叉树的高度至少为 log2(n+1)。\n 4. 在任意一棵二叉树中，若终端结点的个数为 n0，度为 2 的结点数为 n2，则 n0=n2+1。\n\n\n# 满二叉树\n\n除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。\n\n\n\n\n# 完全二叉树\n\n叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。\n\n特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。\n\n\n\n存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。\n\n二叉链式存储法\n\n每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。\n\n\n\n顺序存储法\n\n\n\n如果节点 X 存储在数组中下标为 i 的位置，下标为 2 _ i 的位置存储的就是左子节点，下标为 2 _ i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。\n\n如果是非完全二叉树，其实会浪费比较多的数组存储空间。所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是 为什么完全二叉树要求最后一层的子节点都靠左的原因。\n\n\n# 二叉树的遍历\n\n二叉树的遍历有三种方式：\n\n * 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。\n * 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。\n * 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。\n\n\n\n\n# 二叉查找树\n\n二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。\n\n二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。\n\n\n\n\n# 二叉查找树的查找\n\n首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。\n\n\n\n\n# 二叉查找树的插入\n\n如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。\n\n\n\n\n# 二叉查找树的删除\n\n第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。\n\n第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。\n\n\n\n\n\n第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。\n\n\n\n\n# 二叉查找树的时间复杂度\n\n不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(log n)。\n\n二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。\n\n\n\n\n# 为什么需要二叉查找树\n\n第一，哈希表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。\n\n第二，哈希表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。\n\n第三，笼统地来说，尽管哈希表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。\n\n第四，哈希表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。\n\n最后，为了避免过多的散列冲突，哈希表装载因子不能太大，特别是基于开放寻址法解决冲突的哈希表，不然会浪费一定的存储空间。\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# 树和二叉树\n\n\n# 树\n\n\n# 什么是树\n\n在计算机科学中，树（英语：tree）是一种抽象数据类型（adt）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n\n它具有以下的特点：\n\n * 每个节点都只有有限个子节点或无子节点。\n * 树有且仅有一个根节点。\n * 根节点没有父节点；非根节点有且仅有一个父节点。\n * 每个非根节点可以分为多个不相交的子树。\n * 树里面没有环路。\n\n\n\n\n# 树的术语\n\n * 节点的度：一个节点含有的子树的个数称为该节点的度；\n * 树的度：一棵树中，最大的节点度称为树的度；\n * 叶子节点或终端节点：度为零的节点；\n * 非终端节点或分支节点：度不为零的节点；\n * 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；\n * 子节点：一个节点含有的子树的根节点称为该节点的子节点；\n * 兄弟节点：具有相同父节点的节点互称为兄弟节点；\n * 堂兄弟节点：父节点在同一层的节点互为堂兄弟；\n * 节点的祖先：从根到该节点所经分支上的所有节点；\n * 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。\n * 森林：由 m（m>=0）棵互不相交的树的集合称为森林；\n\n\n\n * 节点的高度：节点到叶子节点的最长路径。高度是从下往上度量。\n * 节点的深度：根节点到该节点的最长路径。深度是从上往下度量。\n * 节点的层次：节点的深度 + 1。\n * 树的高度：根节点的高度。\n\n\n# 树的性质\n\n * 树中的节点数等于所有节点的度数加 1。\n * 度为 m 的树中第 i 层上至多有 $$m^{i-1}$$ 个节点（$$i ≥ 1$$）。\n * 高度为 h 的 m 次树至多有 $$(m^h-1)/(m-1)$$ 个节点。\n * 具有 n 个节点的 m 次树的最小高度为 $$\\log_m{(n(m-1)+1)}$$ 。\n\n\n# 树的种类\n\n无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；\n\n有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；\n\n * 二叉树：每个节点最多含有两个子树的树称为二叉树；\n   * 完全二叉树：对于一颗二叉树，假设其深度为 d（d>1）。除了第 d 层外，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；\n * 满二叉树：所有叶节点都在最底层的完全二叉树；\n * 平衡二叉树（avl 树）：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树；\n * 排序二叉树(二叉查找树（英语：binary search tree))：也称二叉搜索树、有序二叉树；\n * 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；\n * b 树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。\n\n\n# 二叉树\n\n二叉树中的每个节点最多有两个子节点，分别是左子节点和右子节点。\n\n\n# 二叉树的性质\n\n 1. 二叉树第 i 层上的结点数目最多为 2i-1 (i≥1)。\n 2. 深度为 k 的二叉树至多有 2k-1 个结点(k≥1)。\n 3. 包含 n 个结点的二叉树的高度至少为 log2(n+1)。\n 4. 在任意一棵二叉树中，若终端结点的个数为 n0，度为 2 的结点数为 n2，则 n0=n2+1。\n\n\n# 满二叉树\n\n除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。\n\n\n\n\n# 完全二叉树\n\n叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。\n\n特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。\n\n\n\n存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。\n\n二叉链式存储法\n\n每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。\n\n\n\n顺序存储法\n\n\n\n如果节点 x 存储在数组中下标为 i 的位置，下标为 2 _ i 的位置存储的就是左子节点，下标为 2 _ i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。\n\n如果是非完全二叉树，其实会浪费比较多的数组存储空间。所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是 为什么完全二叉树要求最后一层的子节点都靠左的原因。\n\n\n# 二叉树的遍历\n\n二叉树的遍历有三种方式：\n\n * 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。\n * 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。\n * 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。\n\n\n\n\n# 二叉查找树\n\n二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。\n\n二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。\n\n\n\n\n# 二叉查找树的查找\n\n首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。\n\n\n\n\n# 二叉查找树的插入\n\n如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。\n\n\n\n\n# 二叉查找树的删除\n\n第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。\n\n第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。\n\n\n\n\n\n第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。\n\n\n\n\n# 二叉查找树的时间复杂度\n\n不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 o(log n)。\n\n二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 o(n)。\n\n\n\n\n# 为什么需要二叉查找树\n\n第一，哈希表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 o(n) 的时间复杂度内，输出有序的数据序列。\n\n第二，哈希表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 o(logn)。\n\n第三，笼统地来说，尽管哈希表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 o(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。\n\n第四，哈希表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。\n\n最后，为了避免过多的散列冲突，哈希表装载因子不能太大，特别是基于开放寻址法解决冲突的哈希表，不然会浪费一定的存储空间。\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"堆",frontmatter:{title:"堆",categories:["数据结构和算法","树"],tags:["数据结构","树","二叉树","堆"],abbrlink:"fab451a5",date:"2015-03-09T16:01:27.000Z",permalink:"/pages/ce297c/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/02.%E5%A0%86.html",relativePath:"01.数据结构和算法/02.树/02.堆.md",key:"v-df2149cc",path:"/pages/ce297c/",headers:[{level:2,title:"什么是堆？",slug:"什么是堆",normalizedTitle:"什么是堆？",charIndex:8},{level:2,title:"如何实现堆",slug:"如何实现堆",normalizedTitle:"如何实现堆",charIndex:229},{level:2,title:"堆的应用场景",slug:"堆的应用场景",normalizedTitle:"堆的应用场景",charIndex:593},{level:3,title:"求 TOP N",slug:"求-top-n",normalizedTitle:"求 top n",charIndex:604},{level:3,title:"优先级队列",slug:"优先级队列",normalizedTitle:"优先级队列",charIndex:695},{level:3,title:"求中位数",slug:"求中位数",normalizedTitle:"求中位数",charIndex:850}],headersStr:"什么是堆？ 如何实现堆 堆的应用场景 求 TOP N 优先级队列 求中位数",content:"# 堆\n\n\n# 什么是堆？\n\n堆（Heap）是一个可以被看成近似完全二叉树的数组。\n\n * 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。\n * 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。\n\n堆可以分为大顶堆和小顶堆。\n\n * 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。\n\n * 对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”。\n\n\n# 如何实现堆\n\n完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。\n\n\n\n堆常见的操作：\n\n * HEAPIFY 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $$O(n)$$。\n * HEAPPUSH：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $$O(log N)$$\n * HEAPPOP：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $$O(log N)$$。\n * HEAPSORT：借由 HEAPFY 建堆和 HEAPPOP 堆数组进行排序，时间复杂度为$$ O(N log N)$$，空间复杂度为 $$O(1)$$。\n\n\n# 堆的应用场景\n\n\n# 求 TOP N\n\n堆结构的一个常见应用是建立优先队列（Priority Queue）。\n\n求 Top K 的问题抽象成两类。一类是针对静态数据集合；另一类是针对动态数据集合\n\n\n# 优先级队列\n\n在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。\n\n堆和优先级队列非常相似：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。\n\n> 参考：Java 的 PriorityQueue 类\n\n\n# 求中位数",normalizedContent:"# 堆\n\n\n# 什么是堆？\n\n堆（heap）是一个可以被看成近似完全二叉树的数组。\n\n * 堆是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。\n * 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。\n\n堆可以分为大顶堆和小顶堆。\n\n * 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”。\n\n * 对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”。\n\n\n# 如何实现堆\n\n完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。\n\n\n\n堆常见的操作：\n\n * heapify 建堆：把一个乱序的数组变成堆结构的数组，时间复杂度为 $$o(n)$$。\n * heappush：把一个数值放进已经是堆结构的数组中，并保持堆结构，时间复杂度为 $$o(log n)$$\n * heappop：从最大堆中取出最大值或从最小堆中取出最小值，并将剩余的数组保持堆结构，时间复杂度为 $$o(log n)$$。\n * heapsort：借由 heapfy 建堆和 heappop 堆数组进行排序，时间复杂度为$$ o(n log n)$$，空间复杂度为 $$o(1)$$。\n\n\n# 堆的应用场景\n\n\n# 求 top n\n\n堆结构的一个常见应用是建立优先队列（priority queue）。\n\n求 top k 的问题抽象成两类。一类是针对静态数据集合；另一类是针对动态数据集合\n\n\n# 优先级队列\n\n在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。\n\n堆和优先级队列非常相似：往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。\n\n> 参考：java 的 priorityqueue 类\n\n\n# 求中位数",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"B+树",frontmatter:{title:"B+树",categories:["数据结构和算法","树"],tags:["数据结构","树","二叉树","B+ 树"],abbrlink:17426722,date:"2022-03-13T22:37:27.000Z",permalink:"/pages/3fd76e/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/03.B+%E6%A0%91.html",relativePath:"01.数据结构和算法/02.树/03.B+树.md",key:"v-63657ac4",path:"/pages/3fd76e/",headers:[{level:2,title:"什么是 B+树",slug:"什么是-b-树",normalizedTitle:"什么是 b+树",charIndex:10},{level:2,title:"为什么需要 B+树",slug:"为什么需要-b-树",normalizedTitle:"为什么需要 b+树",charIndex:1055},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1699}],headersStr:"什么是 B+树 为什么需要 B+树 参考资料",content:"# B+树\n\n\n# 什么是 B+树\n\nB+树是在二叉查找树的基础上进行了改造：树中的节点并不存储数据本身，而是只是作为索引。每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。\n\n\n\n改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。\n\n\n\n但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。\n\n比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？\n\n我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。\n\n这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。\n\n二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。\n\n我们前面讲到，比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？\n\n我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。\n\n\n# 为什么需要 B+树\n\n关系型数据库中常用 B+ 树作为索引，这是为什么呢？\n\n思考以下经典应用场景\n\n * 根据某个值查找数据，比如 select * from user where id=1234。\n * 根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345。\n\n为了提高查询效率，需要使用索引。而对于索引的性能要求，主要考察执行效率和存储空间。如果让你选择一种数据结构去存储索引，你会如何考虑？\n\n以一些常见数据结构为例：\n\n * 哈希表：哈希表的查询性能很好，时间复杂度是 O(1)。但是，哈希表不能支持按照区间快速查找数据。所以，哈希表不能满足我们的需求。\n * 平衡二叉查找树：尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。\n * 跳表：跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。\n\n实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。B+树的应用场景\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# b+树\n\n\n# 什么是 b+树\n\nb+树是在二叉查找树的基础上进行了改造：树中的节点并不存储数据本身，而是只是作为索引。每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。\n\n\n\n改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。\n\n\n\n但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。\n\n比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1gb 的内存空间。给一张表建立索引，我们需要 1gb 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？\n\n我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。\n\n这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。\n\n二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 io 操作。树的高度就等于每次查询数据时磁盘 io 操作的次数。\n\n我们前面讲到，比起内存读写操作，磁盘 io 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 io 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？\n\n我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 io 操作（如果根节点存储在内存中，其他结点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 io 就能获取到数据。磁盘 io 变少了，查找数据的效率也就提高了。\n\n\n# 为什么需要 b+树\n\n关系型数据库中常用 b+ 树作为索引，这是为什么呢？\n\n思考以下经典应用场景\n\n * 根据某个值查找数据，比如 select * from user where id=1234。\n * 根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345。\n\n为了提高查询效率，需要使用索引。而对于索引的性能要求，主要考察执行效率和存储空间。如果让你选择一种数据结构去存储索引，你会如何考虑？\n\n以一些常见数据结构为例：\n\n * 哈希表：哈希表的查询性能很好，时间复杂度是 o(1)。但是，哈希表不能支持按照区间快速查找数据。所以，哈希表不能满足我们的需求。\n * 平衡二叉查找树：尽管平衡二叉查找树查询的性能也很高，时间复杂度是 o(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。\n * 跳表：跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 o(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。\n\n实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 b+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。b+树的应用场景\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"LSM树",frontmatter:{title:"LSM树",categories:["数据结构和算法","树"],tags:["数据结构","树","LSM 树"],abbrlink:"5bf5ed66",date:"2022-03-16T09:27:21.000Z",permalink:"/pages/4a217d/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/04.LSM%E6%A0%91.html",relativePath:"01.数据结构和算法/02.树/04.LSM树.md",key:"v-334ff26a",path:"/pages/4a217d/",headers:[{level:2,title:"什么是 LSM 树",slug:"什么是-lsm-树",normalizedTitle:"什么是 lsm 树",charIndex:12},{level:3,title:"如何将内存数据与磁盘数据合并",slug:"如何将内存数据与磁盘数据合并",normalizedTitle:"如何将内存数据与磁盘数据合并",charIndex:462},{level:3,title:"LSM 树是如何检索",slug:"lsm-树是如何检索",normalizedTitle:"lsm 树是如何检索",charIndex:1115},{level:2,title:"为什么需要 LSM 树",slug:"为什么需要-lsm-树",normalizedTitle:"为什么需要 lsm 树",charIndex:1370},{level:2,title:"WAL 技术",slug:"wal-技术",normalizedTitle:"wal 技术",charIndex:112},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2215}],headersStr:"什么是 LSM 树 如何将内存数据与磁盘数据合并 LSM 树是如何检索 为什么需要 LSM 树 WAL 技术 参考资料",content:"# LSM 树\n\n\n# 什么是 LSM 树\n\nLSM 树具有以下 3 个特点：\n\n 1. 将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（Merge Trees）；\n 2. 用批量写入代替随机写入，并且用预写日志 WAL 技术（Write AheadLog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；\n 3. 数据采取类似日志追加写的方式写入（Log Structured）磁盘，以顺序写的方式提高写 入效率。\n\nLSM 树的这些特点，使得它相对于 B+ 树，在写入性能上有大幅提升。所以，许多 NoSQL 系统都使用 LSM 树作为检索引擎，而且还对 LSM 树进行了优化以提升检索性能。\n\nLSM 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，LSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。\n\n\n# 如何将内存数据与磁盘数据合并\n\n可以参考两个有序链表归并排序的过程，将 C0 树和 C1 树的所有叶子节点中存储的数据，看作是两个有序链表，那滚动合并问题就变成了我们熟悉的两个有序链表的归并问题。不过由于涉及磁盘操作，那为了提高写入效率和检索效率，我们还需要针对磁盘的特性，在一些归并细节上进行优化。\n\n\n\n由于磁盘具有顺序读写效率高的特性，因此，为了提高 C1 树中节点的读写性能，除了根节点以外的节点都要尽可能地存放到连续的块中，让它们能作为一个整体单位来读写。这种包含多个节点的块就叫作多页块（Multi-Pages Block）。\n\n第一步，以多页块为单位，将 C1 树的当前叶子节点从前往后读入内存。读入内存的多页块，叫作清空块（Emptying Block），意思是处理完以后会被清空。\n\n第二步，将 C0 树的叶子节点和清空块中的数据进行归并排序，把归并的结果写入内存的一个新块中，叫作填充块（Filling Block）。\n\n第三步，如果填充块写满了，我们就要将填充块作为新的叶节点集合顺序写入磁盘。这个时候，如果 C0 树的叶子节点和清空块都没有遍历完，我们就继续遍历归并，将数据写入新的填充块。如果清空块遍历完了，我们就去 C1 树中顺序读取新的多页块，加载到清空块中。\n\n第四步，重复第三步，直到遍历完 C0 树和 C1 树的所有叶子节点，并将所有的归并结果写入到磁盘。这个时候，我们就可以同时删除 C0 树和 C1 树中被处理过的叶子节点。这样就完成了滚动归并的过程。\n\n\n\n\n# LSM 树是如何检索\n\n因为同时存在 C0 和 C1 树，所以要查询一个 key 时，我们会先到 C0 树中查询。如果查询到了则直接返回；如过没有查询到，则查询 C1 树。\n\n需要注意一种特殊情况：删除操作。假设某数据在 C0 树中被删除了，但是在 C1 树中仍存在。这此时查询时，可以在 C1 树中查到这个 key，这其实是过期数据了，如何应对这种情况呢？对于被删除的数据，可以将这些数据的 key 插入到 C0 树中，并标记一个删除标志。如果查到了一个带着删除标志的 key，就直接返回查询失败。\n\n\n# 为什么需要 LSM 树\n\n在关系型数据库中，通常使用 B+ 树作为索引。B+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。\n\n操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：LSM 树（Log Structured Merge Trees）。\n\n\n# WAL 技术\n\nLSM 树至少需要由两棵树组成，一棵是存储在内存中较小的 C0 树，另一棵是存储在磁盘中较大的 C1 树。\n\n如果机器断电或系统崩溃了，那内存中还未写入磁盘的数据岂不就永远丢失了？这种情况我们该如何解决呢？\n\n为了保证内存中的数据在系统崩溃后能恢复，可以使用 WAL 技术（Write Ahead Log，预写日志技术）将数据第一时间高效写入磁盘进行备份。\n\nWAL 技术保存和恢复数据的具体步骤如下：\n\n 1. 内存中的程序在处理数据时，会先将对数据的修改作为一条记录，顺序写入磁盘的 log 文件作为备份。由于磁盘文件的顺序追加写入效率很高，因此许多应用场景都可以接受这种备份处理。\n 2. 在数据写入 log 文件后，备份就成功了。接下来，该数据就可以长期驻留在内存中了。\n 3. 系统会周期性地检查内存中的数据是否都被处理完了（比如，被删除或者写入磁盘），并且生成对应的检查点（Check Point）记录在磁盘中。然后，我们就可以随时删除被处理完的数据了。这样一来，log 文件就不会无限增长了。\n 4. 系统崩溃重启，我们只需要从磁盘中读取检查点，就能知道最后一次成功处理的数据在 log 文件中的位置。接下来，我们就可以把这个位置之后未被处理的数据，从 log 文件中读出，然后重新加载到内存中。\n\n\n\n\n# 参考资料\n\n * 检索技术核心 20 讲",normalizedContent:"# lsm 树\n\n\n# 什么是 lsm 树\n\nlsm 树具有以下 3 个特点：\n\n 1. 将索引分为内存和磁盘两部分，并在内存达到阈值时启动树合并（merge trees）；\n 2. 用批量写入代替随机写入，并且用预写日志 wal 技术（write aheadlog，预写日志技术）保证内存数据，在系统崩溃后可以被恢复；\n 3. 数据采取类似日志追加写的方式写入（log structured）磁盘，以顺序写的方式提高写 入效率。\n\nlsm 树的这些特点，使得它相对于 b+ 树，在写入性能上有大幅提升。所以，许多 nosql 系统都使用 lsm 树作为检索引擎，而且还对 lsm 树进行了优化以提升检索性能。\n\nlsm 树就是根据这个思路设计了这样一个机制：当数据写入时，延迟写磁盘，将数据先存放在内存中的树里，进行常规的存储和查询。当内存中的树持续变大达到阈值时，再批量地以块为单位写入磁盘的树中。因此，lsm 树至少需要由两棵树组成，一棵是存储在内存中较小的 c0 树，另一棵是存储在磁盘中较大的 c1 树。\n\n\n# 如何将内存数据与磁盘数据合并\n\n可以参考两个有序链表归并排序的过程，将 c0 树和 c1 树的所有叶子节点中存储的数据，看作是两个有序链表，那滚动合并问题就变成了我们熟悉的两个有序链表的归并问题。不过由于涉及磁盘操作，那为了提高写入效率和检索效率，我们还需要针对磁盘的特性，在一些归并细节上进行优化。\n\n\n\n由于磁盘具有顺序读写效率高的特性，因此，为了提高 c1 树中节点的读写性能，除了根节点以外的节点都要尽可能地存放到连续的块中，让它们能作为一个整体单位来读写。这种包含多个节点的块就叫作多页块（multi-pages block）。\n\n第一步，以多页块为单位，将 c1 树的当前叶子节点从前往后读入内存。读入内存的多页块，叫作清空块（emptying block），意思是处理完以后会被清空。\n\n第二步，将 c0 树的叶子节点和清空块中的数据进行归并排序，把归并的结果写入内存的一个新块中，叫作填充块（filling block）。\n\n第三步，如果填充块写满了，我们就要将填充块作为新的叶节点集合顺序写入磁盘。这个时候，如果 c0 树的叶子节点和清空块都没有遍历完，我们就继续遍历归并，将数据写入新的填充块。如果清空块遍历完了，我们就去 c1 树中顺序读取新的多页块，加载到清空块中。\n\n第四步，重复第三步，直到遍历完 c0 树和 c1 树的所有叶子节点，并将所有的归并结果写入到磁盘。这个时候，我们就可以同时删除 c0 树和 c1 树中被处理过的叶子节点。这样就完成了滚动归并的过程。\n\n\n\n\n# lsm 树是如何检索\n\n因为同时存在 c0 和 c1 树，所以要查询一个 key 时，我们会先到 c0 树中查询。如果查询到了则直接返回；如过没有查询到，则查询 c1 树。\n\n需要注意一种特殊情况：删除操作。假设某数据在 c0 树中被删除了，但是在 c1 树中仍存在。这此时查询时，可以在 c1 树中查到这个 key，这其实是过期数据了，如何应对这种情况呢？对于被删除的数据，可以将这些数据的 key 插入到 c0 树中，并标记一个删除标志。如果查到了一个带着删除标志的 key，就直接返回查询失败。\n\n\n# 为什么需要 lsm 树\n\n在关系型数据库中，通常使用 b+ 树作为索引。b+ 树的数据都存储在叶子节点中，而叶子节点一般都存储在磁盘中。因此，每次插入的新数据都需要随机写入磁盘，而随机写入的性能非常慢。如果是一个日志系统，每秒钟要写入上千条甚至上万条数据，这样的磁盘操作代价会使得系统性能急剧下降，甚至无法使用。\n\n操作系统对磁盘的读写是以块为单位的，我们能否以块为单位写入，而不是每次插入一个数据都要随机写入磁盘呢？这样是不是就可以大幅度减少写入操作了呢？解决方案就是：lsm 树（log structured merge trees）。\n\n\n# wal 技术\n\nlsm 树至少需要由两棵树组成，一棵是存储在内存中较小的 c0 树，另一棵是存储在磁盘中较大的 c1 树。\n\n如果机器断电或系统崩溃了，那内存中还未写入磁盘的数据岂不就永远丢失了？这种情况我们该如何解决呢？\n\n为了保证内存中的数据在系统崩溃后能恢复，可以使用 wal 技术（write ahead log，预写日志技术）将数据第一时间高效写入磁盘进行备份。\n\nwal 技术保存和恢复数据的具体步骤如下：\n\n 1. 内存中的程序在处理数据时，会先将对数据的修改作为一条记录，顺序写入磁盘的 log 文件作为备份。由于磁盘文件的顺序追加写入效率很高，因此许多应用场景都可以接受这种备份处理。\n 2. 在数据写入 log 文件后，备份就成功了。接下来，该数据就可以长期驻留在内存中了。\n 3. 系统会周期性地检查内存中的数据是否都被处理完了（比如，被删除或者写入磁盘），并且生成对应的检查点（check point）记录在磁盘中。然后，我们就可以随时删除被处理完的数据了。这样一来，log 文件就不会无限增长了。\n 4. 系统崩溃重启，我们只需要从磁盘中读取检查点，就能知道最后一次成功处理的数据在 log 文件中的位置。接下来，我们就可以把这个位置之后未被处理的数据，从 log 文件中读出，然后重新加载到内存中。\n\n\n\n\n# 参考资料\n\n * 检索技术核心 20 讲",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"字典树",frontmatter:{title:"字典树",categories:["数据结构和算法","树"],tags:["数据结构","树","字典树"],abbrlink:"eea60a6a",date:"2022-03-13T22:37:27.000Z",permalink:"/pages/0a4984/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/05.%E5%AD%97%E5%85%B8%E6%A0%91.html",relativePath:"01.数据结构和算法/02.树/05.字典树.md",key:"v-3d274ca6",path:"/pages/0a4984/",headers:[{level:2,title:"什么是字典树",slug:"什么是字典树",normalizedTitle:"什么是字典树",charIndex:10},{level:3,title:"字典树的构造",slug:"字典树的构造",normalizedTitle:"字典树的构造",charIndex:181},{level:3,title:"字典树的查找",slug:"字典树的查找",normalizedTitle:"字典树的查找",charIndex:777},{level:2,title:"字典树的应用场景",slug:"字典树的应用场景",normalizedTitle:"字典树的应用场景",charIndex:1073},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1647}],headersStr:"什么是字典树 字典树的构造 字典树的查找 字典树的应用场景 参考资料",content:"# 字典树\n\n\n# 什么是字典树\n\nTrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。\n\n * 根节点（Root）不包含字符，除根节点外的每一个节点都仅包含一个字符；\n * 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；\n * 任意节点的所有子节点所包含的字符都不相同；\n\n\n\n\n# 字典树的构造\n\n\n\n\n\n构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。\n\n字典树非常耗费内存。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n\n# 字典树的查找\n\n 1. 每次从根结点开始搜索；\n 2. 获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；\n 3. 在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；\n 4. 以此类推，进行迭代过程；\n 5. 在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。\n\n\n\n每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。\n\n\n# 字典树的应用场景\n\n在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。\n\n第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。\n\n第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。\n\n第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。\n\n在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n（1）自动补全\n\n\n\n（2）拼写检查\n\n\n\n（3）IP 路由 (最长前缀匹配)\n\n\n\n图 3. 使用 Trie 树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。\n\n（4）T9 (九宫格) 打字预测\n\n\n\n（5）单词游戏\n\n\n\nTrie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/",normalizedContent:"# 字典树\n\n\n# 什么是字典树\n\ntrie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。\n\n * 根节点（root）不包含字符，除根节点外的每一个节点都仅包含一个字符；\n * 从根节点到某一节点路径上所经过的字符连接起来，即为该节点对应的字符串；\n * 任意节点的所有子节点所包含的字符都不相同；\n\n\n\n\n# 字典树的构造\n\n\n\n\n\n构建 trie 树的过程，需要扫描所有的字符串，时间复杂度是 o(n)（n 表示所有字符串的长度和）。\n\n字典树非常耗费内存。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 cpu、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 cpu、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 cpu、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。\n\n\n# 字典树的查找\n\n 1. 每次从根结点开始搜索；\n 2. 获取关键词的第一个字符，根据该字符选择对应的子节点，转到该子节点继续检索；\n 3. 在相应的子节点上，获取关键词的第二个字符，进一步选择对应的子节点进行检索；\n 4. 以此类推，进行迭代过程；\n 5. 在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，查找完成。\n\n\n\n每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 trie 树后，在其中查找字符串的时间复杂度是 o(k)，k 表示要查找的字符串的长度。\n\n\n# 字典树的应用场景\n\n在一组字符串中查找字符串，trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。\n\n第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。\n\n第三，如果要用 trie 树解决问题，那我们就要自己从零开始实现一个 trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。\n\n第四，我们知道，通过指针串起来的数据块是不连续的，而 trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。\n\n在一组字符串中查找字符串，trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n在一组字符串中查找字符串，trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。\n\n（1）自动补全\n\n\n\n（2）拼写检查\n\n\n\n（3）ip 路由 (最长前缀匹配)\n\n\n\n图 3. 使用 trie 树的最长前缀匹配算法，internet 协议（ip）路由中利用转发表选择路径。\n\n（4）t9 (九宫格) 打字预测\n\n\n\n（5）单词游戏\n\n\n\ntrie 树可通过剪枝搜索空间来高效解决 boggle 单词游戏\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"红黑树",frontmatter:{title:"红黑树",categories:["数据结构和算法","树"],tags:["数据结构","树","二叉树","红黑树"],abbrlink:"f89cb603",date:"2018-06-01T21:10:23.000Z",permalink:"/pages/0a4414/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02.%E6%A0%91/06.%E7%BA%A2%E9%BB%91%E6%A0%91.html",relativePath:"01.数据结构和算法/02.树/06.红黑树.md",key:"v-2e58a9ba",path:"/pages/0a4414/",headers:[{level:2,title:"平衡二叉树",slug:"平衡二叉树",normalizedTitle:"平衡二叉树",charIndex:10},{level:2,title:"什么是红黑树",slug:"什么是红黑树",normalizedTitle:"什么是红黑树",charIndex:211},{level:3,title:"为什么说红黑树是“近似平衡”的？",slug:"为什么说红黑树是-近似平衡-的",normalizedTitle:"为什么说红黑树是“近似平衡”的？",charIndex:460},{level:2,title:"为什么需要红黑树",slug:"为什么需要红黑树",normalizedTitle:"为什么需要红黑树",charIndex:1026},{level:2,title:"红黑树平衡调整",slug:"红黑树平衡调整",normalizedTitle:"红黑树平衡调整",charIndex:1295},{level:3,title:"插入操作的平衡调整",slug:"插入操作的平衡调整",normalizedTitle:"插入操作的平衡调整",charIndex:1307},{level:3,title:"删除操作的平衡调整",slug:"删除操作的平衡调整",normalizedTitle:"删除操作的平衡调整",charIndex:2078},{level:4,title:"针对删除节点初步调整",slug:"针对删除节点初步调整",normalizedTitle:"针对删除节点初步调整",charIndex:2091},{level:4,title:"针对关注节点进行二次调整",slug:"针对关注节点进行二次调整",normalizedTitle:"针对关注节点进行二次调整",charIndex:2878},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3652}],headersStr:"平衡二叉树 什么是红黑树 为什么说红黑树是“近似平衡”的？ 为什么需要红黑树 红黑树平衡调整 插入操作的平衡调整 删除操作的平衡调整 针对删除节点初步调整 针对关注节点进行二次调整 参考资料",content:"# 红黑树\n\n\n# 平衡二叉树\n\n平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。\n\n完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。\n\n\n\n平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。\n\n\n# 什么是红黑树\n\n红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树。\n\n红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：\n\n * 根节点是黑色的；\n * 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；\n * 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；\n * 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；\n\n\n\n\n# 为什么说红黑树是“近似平衡”的？\n\n平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。\n\n所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。\n\n如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？\n\n红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。\n\n\n\n前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。\n\n现在把红色节点加回去，高度会变成多少呢？\n\n在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。\n\n所以，红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。\n\n\n# 为什么需要红黑树\n\nAVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。\n\n红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。\n\n所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。\n\n\n# 红黑树平衡调整\n\n\n# 插入操作的平衡调整\n\n红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。\n\n * 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。\n * 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。\n\n除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。\n\n红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。\n\n新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。\n\nCASE 1：如果关注节点是 a，它的叔叔节点 d 是红色，我们就依次执行下面的操作：\n\n * 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；\n * 将关注节点 a 的祖父节点 c 的颜色设置成红色；\n * 关注节点变成 a 的祖父节点 c；\n * 跳到 CASE 2 或者 CASE 3。\n\n\n\nCASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：\n\n * 关注节点变成节点 a 的父节点 b；\n * 围绕新的关注节点 b 左旋；\n * 跳到 CASE 3。\n\n\n\nCASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：\n\n * 围绕关注节点 a 的祖父节点 c 右旋；\n * 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。\n * 调整结束。\n\n\n\n\n# 删除操作的平衡调整\n\n# 针对删除节点初步调整\n\nCASE 1：如果要删除的节点是 a，它只有一个子节点 b，那我们就依次进行下面的操作：\n\n * 删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；\n * 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；\n * 调整结束，不需要进行二次调整。\n\n\n\nCASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c。我们就依次进行下面的操作：\n\n * 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；\n * 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；\n * 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；\n * 这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。\n\nCASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点，我们就依次进行下面的操作：\n\n * 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；\n * 将节点 a 替换成后继节点 d；\n * 把节点 d 的颜色设置为跟节点 a 相同的颜色；\n * 如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；\n * 这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。\n\n# 针对关注节点进行二次调整\n\nCASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的父节点 b 左旋；\n * 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；\n * 关注节点不变；\n * 继续从四种情况中选择适合的规则来调整。\n\nCASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的，我们就依次进行下面的操作：\n\n * 将关注节点 a 的兄弟节点 c 的颜色变成红色；\n * 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；\n * 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；\n * 关注节点从 a 变成其父节点 b；\n * 继续从四种情况中选择符合的规则来调整。\n\nCASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的兄弟节点 c 右旋；\n * 节点 c 和节点 d 交换颜色；\n * 关注节点不变；\n * 跳转到 CASE 4，继续调整。\n\nCASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的父节点 b 左旋；\n * 将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；\n * 将关注节点 a 的父节点 b 的颜色设置为黑色；\n * 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；\n * 将关注节点 a 的叔叔节点 e 设置为黑色；\n * 调整结束。\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# 红黑树\n\n\n# 平衡二叉树\n\n平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。\n\n完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。\n\n\n\n平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。\n\n\n# 什么是红黑树\n\n红黑树的英文是“red-black tree”，简称 r-b tree。它是一种不严格的平衡二叉查找树。\n\n红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：\n\n * 根节点是黑色的；\n * 每个叶子节点都是黑色的空节点（nil），也就是说，叶子节点不存储数据；\n * 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；\n * 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；\n\n\n\n\n# 为什么说红黑树是“近似平衡”的？\n\n平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。\n\n所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。\n\n如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？\n\n红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。\n\n\n\n前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。\n\n现在把红色节点加回去，高度会变成多少呢？\n\n在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，红黑树的高度近似 2log2n。\n\n所以，红黑树的高度只比高度平衡的 avl 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。\n\n\n# 为什么需要红黑树\n\navl 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，avl 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 avl 树的代价就有点高了。\n\n红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 avl 树要低。\n\n所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。\n\n\n# 红黑树平衡调整\n\n\n# 插入操作的平衡调整\n\n红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。\n\n * 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。\n * 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。\n\n除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。\n\n红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作关注节点。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。\n\n新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。\n\ncase 1：如果关注节点是 a，它的叔叔节点 d 是红色，我们就依次执行下面的操作：\n\n * 将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；\n * 将关注节点 a 的祖父节点 c 的颜色设置成红色；\n * 关注节点变成 a 的祖父节点 c；\n * 跳到 case 2 或者 case 3。\n\n\n\ncase 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：\n\n * 关注节点变成节点 a 的父节点 b；\n * 围绕新的关注节点 b 左旋；\n * 跳到 case 3。\n\n\n\ncase 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：\n\n * 围绕关注节点 a 的祖父节点 c 右旋；\n * 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。\n * 调整结束。\n\n\n\n\n# 删除操作的平衡调整\n\n# 针对删除节点初步调整\n\ncase 1：如果要删除的节点是 a，它只有一个子节点 b，那我们就依次进行下面的操作：\n\n * 删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；\n * 节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；\n * 调整结束，不需要进行二次调整。\n\n\n\ncase 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c。我们就依次进行下面的操作：\n\n * 如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；\n * 然后把节点 c 的颜色设置为跟节点 a 相同的颜色；\n * 如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；\n * 这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。\n\ncase 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点，我们就依次进行下面的操作：\n\n * 找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 case 1；\n * 将节点 a 替换成后继节点 d；\n * 把节点 d 的颜色设置为跟节点 a 相同的颜色；\n * 如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；\n * 这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。\n\n# 针对关注节点进行二次调整\n\ncase 1：如果关注节点是 a，它的兄弟节点 c 是红色的，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的父节点 b 左旋；\n * 关注节点 a 的父节点 b 和祖父节点 c 交换颜色；\n * 关注节点不变；\n * 继续从四种情况中选择适合的规则来调整。\n\ncase 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的，我们就依次进行下面的操作：\n\n * 将关注节点 a 的兄弟节点 c 的颜色变成红色；\n * 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；\n * 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；\n * 关注节点从 a 变成其父节点 b；\n * 继续从四种情况中选择符合的规则来调整。\n\ncase 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的兄弟节点 c 右旋；\n * 节点 c 和节点 d 交换颜色；\n * 关注节点不变；\n * 跳转到 case 4，继续调整。\n\ncase 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的，我们就依次进行下面的操作：\n\n * 围绕关注节点 a 的父节点 b 左旋；\n * 将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；\n * 将关注节点 a 的父节点 b 的颜色设置为黑色；\n * 从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；\n * 将关注节点 a 的叔叔节点 e 设置为黑色；\n * 调整结束。\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"哈希表",frontmatter:{title:"哈希表",categories:["数据结构和算法"],tags:["数据结构和算法","哈希表"],abbrlink:"850f2080",date:"2015-03-16T14:19:59.000Z",permalink:"/pages/b501c7/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03.%E5%93%88%E5%B8%8C%E8%A1%A8.html",relativePath:"01.数据结构和算法/03.哈希表.md",key:"v-e729f00c",path:"/pages/b501c7/",headers:[{level:2,title:"什么是哈希表",slug:"什么是哈希表",normalizedTitle:"什么是哈希表",charIndex:161},{level:2,title:"散列函数",slug:"散列函数",normalizedTitle:"散列函数",charIndex:429},{level:3,title:"散列冲突",slug:"散列冲突",normalizedTitle:"散列冲突",charIndex:1058},{level:3,title:"装载因子",slug:"装载因子",normalizedTitle:"装载因子",charIndex:1177},{level:3,title:"开放寻址法",slug:"开放寻址法",normalizedTitle:"开放寻址法",charIndex:1135},{level:3,title:"链表法",slug:"链表法",normalizedTitle:"链表法",charIndex:1158},{level:3,title:"开放寻址法 vs. 链表法",slug:"开放寻址法-vs-链表法",normalizedTitle:"开放寻址法 vs. 链表法",charIndex:2868},{level:2,title:"哈希表的应用场景",slug:"哈希表的应用场景",normalizedTitle:"哈希表的应用场景",charIndex:2970},{level:3,title:"典型应用场景",slug:"典型应用场景",normalizedTitle:"典型应用场景",charIndex:3246},{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:3654},{level:2,title:"思考",slug:"思考",normalizedTitle:"思考",charIndex:3707},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3807}],headersStr:"什么是哈希表 散列函数 散列冲突 装载因子 开放寻址法 链表法 开放寻址法 vs. 链表法 哈希表的应用场景 典型应用场景 练习 思考 参考资料",content:"# 哈希表\n\n> 哈希表 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构。\n> \n> 有两种不同类型的哈希表：哈希集合 和 哈希映射。\n> \n>  * 哈希集合 是集合数据结构的实现之一，用于存储非重复值。\n>  * 哈希映射 是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n\n# 什么是哈希表\n\n哈希表的英文叫“Hash Table”，我们平时也叫它“散列表”或者“Hash 表”。\n\n哈希表 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构。\n\n有两种不同类型的哈希表：哈希集合 和 哈希映射。\n\n * 哈希集合 是集合数据结构的实现之一，用于存储非重复值。\n * 哈希映射 是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n哈希表用的是数组支持按照下标随机访问数据的特性，所以哈希表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有哈希表。\n\n\n\n哈希表通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。\n\n有两种不同类型的哈希表：哈希集合和哈希映射。\n\n * 哈希集合是集合数据结构的实现之一，用于存储非重复值。\n * 哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如 Java，C ++ 和 Python）都支持哈希集合和哈希映射。\n\n\n# 散列函数\n\n散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。\n\n哈希表的关键思想是使用哈希函数将键映射到存储桶。更确切地说，\n\n 1. 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；\n 2. 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。\n\n散列函数将取决于 键值的范围 和 桶的数量 。\n\n散列函数设计的基本要求：\n\n 1. 散列函数计算得到的散列值是一个非负整数；\n 2. 如果 key1 = key2，那 hash(key1) == hash(key2)；\n 3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。\n\n\n# 散列冲突\n\n即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。\n\n该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。\n\n\n# 装载因子\n\n当哈希表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证哈希表的操作效率，一般情况下，我们会尽可能保证哈希表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。\n\n装载因子的计算公式是：\n\n哈希表的装载因子 = 填入表中的元素个数 / 哈希表的长度\n\n\n装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。\n\n当装载因子过大时，就需要对哈希表扩容。新申请一个更大的哈希表，将数据搬移到这个新哈希表中。针对数组的扩容，数据搬移操作比较简单。但是，针对哈希表的扩容，数据搬移操作要复杂很多。因为哈希表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。\n\n插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，哈希表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。\n\n装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。\n\n\n# 开放寻址法\n\n开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。\n\n当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。\n\n线性探测（Linear Probing）：当我们往哈希表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。\n\n\n\n对于使用线性探测法解决冲突的哈希表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？\n\n我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。\n\n线性探测法其实存在很大问题。当哈希表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个哈希表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张哈希表，才能找到要查找或者删除的数据。\n\n\n# 链表法\n\n在哈希表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。\n\n链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。\n\n基于链表的散列冲突处理方法比较适合存储大对象、大数据量的哈希表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。\n\n\n\n当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？\n\n实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示哈希表中“槽”的个数。\n\n\n# 开放寻址法 vs. 链表法\n\n开放寻址法适用于数据量比较小、装载因子小的场景。\n\n链表法适用于存储大对象、大数据量的哈希表。比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。\n\n\n# 哈希表的应用场景\n\n哈希算法的应用非常非常多，最常见的七个，分别是：\n\n * 安全加密：如：MD5、SHA\n * 唯一标识：UUID\n * 数据校验：数字签名\n * 散列函数：\n * 负载均衡：会话粘滞（session sticky）负载均衡算法。可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。\n * 数据分片\n * 分布式存储：一致性哈希算法、虚拟哈希槽\n\n\n# 典型应用场景\n\nJava 的 HashMap 工具类，其\n\n * HashMap 默认的初始大小是 16\n * 最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示哈希表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。\n * HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现链表过长的情况，一旦出现链表过长，则会严重影响 HashMap 的性能。在 JDK1.8 版本中，对 HashMap 做了进一步优化：引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。\n\n\n# 练习\n\nLeetcode 练习题：\n\n * 705. 设计哈希集合\n * 706. 设计哈希映射\n\n\n# 思考\n\n 1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？\n 2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# 哈希表\n\n> 哈希表 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构。\n> \n> 有两种不同类型的哈希表：哈希集合 和 哈希映射。\n> \n>  * 哈希集合 是集合数据结构的实现之一，用于存储非重复值。\n>  * 哈希映射 是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n\n# 什么是哈希表\n\n哈希表的英文叫“hash table”，我们平时也叫它“散列表”或者“hash 表”。\n\n哈希表 是一种使用 哈希函数 组织数据，以支持快速插入和搜索的数据结构。\n\n有两种不同类型的哈希表：哈希集合 和 哈希映射。\n\n * 哈希集合 是集合数据结构的实现之一，用于存储非重复值。\n * 哈希映射 是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n哈希表用的是数组支持按照下标随机访问数据的特性，所以哈希表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有哈希表。\n\n\n\n哈希表通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。\n\n有两种不同类型的哈希表：哈希集合和哈希映射。\n\n * 哈希集合是集合数据结构的实现之一，用于存储非重复值。\n * 哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。\n\n在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如 java，c ++ 和 python）都支持哈希集合和哈希映射。\n\n\n# 散列函数\n\n散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。\n\n哈希表的关键思想是使用哈希函数将键映射到存储桶。更确切地说，\n\n 1. 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；\n 2. 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。\n\n散列函数将取决于 键值的范围 和 桶的数量 。\n\n散列函数设计的基本要求：\n\n 1. 散列函数计算得到的散列值是一个非负整数；\n 2. 如果 key1 = key2，那 hash(key1) == hash(key2)；\n 3. 如果 key1 = key2，那 hash(key1) = hash(key2)。\n\n\n# 散列冲突\n\n即便像业界著名的md5、sha、crc等哈希算法，也无法完全避免这种散列冲突。\n\n该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。\n\n\n# 装载因子\n\n当哈希表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证哈希表的操作效率，一般情况下，我们会尽可能保证哈希表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。\n\n装载因子的计算公式是：\n\n哈希表的装载因子 = 填入表中的元素个数 / 哈希表的长度\n\n\n装载因子越大，说明空闲位置越少，冲突越多，哈希表的性能会下降。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。\n\n当装载因子过大时，就需要对哈希表扩容。新申请一个更大的哈希表，将数据搬移到这个新哈希表中。针对数组的扩容，数据搬移操作比较简单。但是，针对哈希表的扩容，数据搬移操作要复杂很多。因为哈希表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。\n\n插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 o(1)。最坏情况下，哈希表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 o(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 o(1)。\n\n装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。\n\n\n# 开放寻址法\n\n开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。\n\n当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 java 中的 threadlocalmap 使用开放寻址法解决散列冲突的原因。\n\n线性探测（linear probing）：当我们往哈希表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。\n\n\n\n对于使用线性探测法解决冲突的哈希表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？\n\n我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。\n\n线性探测法其实存在很大问题。当哈希表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个哈希表，所以最坏情况下的时间复杂度为 o(n)。同理，在删除和查找时，也有可能会线性探测整张哈希表，才能找到要查找或者删除的数据。\n\n\n# 链表法\n\n在哈希表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。\n\n链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。\n\n基于链表的散列冲突处理方法比较适合存储大对象、大数据量的哈希表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。\n\n\n\n当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 o(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？\n\n实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 o(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示哈希表中“槽”的个数。\n\n\n# 开放寻址法 vs. 链表法\n\n开放寻址法适用于数据量比较小、装载因子小的场景。\n\n链表法适用于存储大对象、大数据量的哈希表。比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。\n\n\n# 哈希表的应用场景\n\n哈希算法的应用非常非常多，最常见的七个，分别是：\n\n * 安全加密：如：md5、sha\n * 唯一标识：uuid\n * 数据校验：数字签名\n * 散列函数：\n * 负载均衡：会话粘滞（session sticky）负载均衡算法。可以通过哈希算法，对客户端 ip 地址或者会话 id 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 ip 过来的所有请求，都路由到同一个后端服务器上。\n * 数据分片\n * 分布式存储：一致性哈希算法、虚拟哈希槽\n\n\n# 典型应用场景\n\njava 的 hashmap 工具类，其\n\n * hashmap 默认的初始大小是 16\n * 最大装载因子默认是 0.75，当 hashmap 中元素个数超过 0.75*capacity（capacity 表示哈希表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。\n * hashmap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现链表过长的情况，一旦出现链表过长，则会严重影响 hashmap 的性能。在 jdk1.8 版本中，对 hashmap 做了进一步优化：引入了红黑树。当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 hashmap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。\n\n\n# 练习\n\nleetcode 练习题：\n\n * 705. 设计哈希集合\n * 706. 设计哈希映射\n\n\n# 思考\n\n 1. 假设我们有 10 万条 url 访问日志，如何按照访问次数给 url 排序？\n 2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"图",frontmatter:{title:"图",categories:["数据结构和算法"],tags:["数据结构和算法","图"],abbrlink:"ee040603",date:"2015-03-24T15:31:13.000Z",permalink:"/pages/21529b/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/05.%E5%9B%BE.html",relativePath:"01.数据结构和算法/05.图.md",key:"v-4b0c4b95",path:"/pages/21529b/",headers:[{level:2,title:"什么是图",slug:"什么是图",normalizedTitle:"什么是图",charIndex:81},{level:2,title:"图的基本操作",slug:"图的基本操作",normalizedTitle:"图的基本操作",charIndex:1069},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1394}],headersStr:"什么是图 图的基本操作 参考资料",content:"# 图\n\n在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。\n\n\n\n\n# 什么是图\n\n * 阶（Order） - 图 G 中点集 V 的大小称作图 G 的阶。\n * 子图（Sub-Graph） - 当图 G'=(V',E')其中 V‘包含于 V，E’包含于 E，则 G'称作图 G=(V,E)的子图。每个图都是本身的子图。\n * 生成子图（Spanning Sub-Graph） - 指满足条件 V(G') = V(G)的 G 的子图 G'。\n * 导出子图（Induced Subgraph） - 以图 G 的顶点集 V 的非空子集V1 为顶点集，以两端点均在 V1 中的全体边为边集的 G 的子图，称为 V1 导出的导出子图；以图 G 的边集 E 的非空子集 E1 为边集，以 E1 中边关联的顶点的全体为顶点集的 G 的子图，称为 E1 导出的导出子图。\n * 有向图 - 如果给图的每条边规定一个方向，那么得到的图称为有向图。\n * 无向图 - 边没有方向的图称为无向图。\n * 度（Degree） - 一个顶点的度是指与该顶点相关联的边的条数，顶点 v 的度记作 d(v)。\n * 入度（In-degree）和出度（Out-degree） - 对于有向图来说，一个顶点的度可细分为入度和出度。一个顶点的入度是指与其关联的各边之中，以其为终点的边数；出度则是相对的概念，指以该顶点为起点的边数。\n * 自环（Loop） - 若一条边的两个顶点为同一顶点，则此边称作自环。\n * 路径（Path） - 从 u 到 v 的一条路径是指一个序列 v0,e1,v1,e2,v2,...ek,vk，其中 ei 的顶点为 vi 及 vi - 1，k 称作路径的长度。如果它的起止顶点相同，该路径是“闭”的，反之，则称为“开”的。一条路径称为一简单路径(simple path)，如果路径中除起始与终止顶点可以重合外，所有顶点两两不等。\n * 行迹（Trace） - 如果路径 P(u,v)中的边各不相同，则该路径称为 u 到 v 的一条行迹。闭的行迹称作回路（Circuit）。\n * 轨迹（Track） - 如果路径 P(u,v)中的顶点各不相同，则该路径称为 u 到 v 的一条轨迹。闭的轨迹称作圈（Cycle）。\n * 桥（Bridge） - 若去掉一条边，便会使得整个图不连通，该边称为桥。\n\n如果图的边没有方向性，则被成为无向图。\n\n\n\n\n# 图的基本操作\n\n * 创建一个图结构 - CreateGraph(G)\n * 检索给定顶点 - LocateVex(G,elem)\n * 获取图中某个顶点 - GetVex(G,v)\n * 为图中顶点赋值 - PutVex(G,v,value)\n * 返回第一个邻接点 - FirstAdjVex(G,v)\n * 返回下一个邻接点 - NextAdjVex(G,v,w)\n * 插入一个顶点 - InsertVex(G,v)\n * 删除一个顶点 - DeleteVex(G,v)\n * 插入一条边 - InsertEdge(G,v,w)\n * 删除一条边 - DeleteEdge(G,v,w)\n * 遍历图 - Traverse(G,v)\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# 图\n\n在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。\n\n\n\n\n# 什么是图\n\n * 阶（order） - 图 g 中点集 v 的大小称作图 g 的阶。\n * 子图（sub-graph） - 当图 g'=(v',e')其中 v‘包含于 v，e’包含于 e，则 g'称作图 g=(v,e)的子图。每个图都是本身的子图。\n * 生成子图（spanning sub-graph） - 指满足条件 v(g') = v(g)的 g 的子图 g'。\n * 导出子图（induced subgraph） - 以图 g 的顶点集 v 的非空子集v1 为顶点集，以两端点均在 v1 中的全体边为边集的 g 的子图，称为 v1 导出的导出子图；以图 g 的边集 e 的非空子集 e1 为边集，以 e1 中边关联的顶点的全体为顶点集的 g 的子图，称为 e1 导出的导出子图。\n * 有向图 - 如果给图的每条边规定一个方向，那么得到的图称为有向图。\n * 无向图 - 边没有方向的图称为无向图。\n * 度（degree） - 一个顶点的度是指与该顶点相关联的边的条数，顶点 v 的度记作 d(v)。\n * 入度（in-degree）和出度（out-degree） - 对于有向图来说，一个顶点的度可细分为入度和出度。一个顶点的入度是指与其关联的各边之中，以其为终点的边数；出度则是相对的概念，指以该顶点为起点的边数。\n * 自环（loop） - 若一条边的两个顶点为同一顶点，则此边称作自环。\n * 路径（path） - 从 u 到 v 的一条路径是指一个序列 v0,e1,v1,e2,v2,...ek,vk，其中 ei 的顶点为 vi 及 vi - 1，k 称作路径的长度。如果它的起止顶点相同，该路径是“闭”的，反之，则称为“开”的。一条路径称为一简单路径(simple path)，如果路径中除起始与终止顶点可以重合外，所有顶点两两不等。\n * 行迹（trace） - 如果路径 p(u,v)中的边各不相同，则该路径称为 u 到 v 的一条行迹。闭的行迹称作回路（circuit）。\n * 轨迹（track） - 如果路径 p(u,v)中的顶点各不相同，则该路径称为 u 到 v 的一条轨迹。闭的轨迹称作圈（cycle）。\n * 桥（bridge） - 若去掉一条边，便会使得整个图不连通，该边称为桥。\n\n如果图的边没有方向性，则被成为无向图。\n\n\n\n\n# 图的基本操作\n\n * 创建一个图结构 - creategraph(g)\n * 检索给定顶点 - locatevex(g,elem)\n * 获取图中某个顶点 - getvex(g,v)\n * 为图中顶点赋值 - putvex(g,v,value)\n * 返回第一个邻接点 - firstadjvex(g,v)\n * 返回下一个邻接点 - nextadjvex(g,v,w)\n * 插入一个顶点 - insertvex(g,v)\n * 删除一个顶点 - deletevex(g,v)\n * 插入一条边 - insertedge(g,v,w)\n * 删除一条边 - deleteedge(g,v,w)\n * 遍历图 - traverse(g,v)\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"跳表",frontmatter:{title:"跳表",categories:["数据结构和算法"],tags:["数据结构和算法","跳表"],abbrlink:"2e152a56",date:"2020-10-23T09:21:13.000Z",permalink:"/pages/62671a/"},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04.%E8%B7%B3%E8%A1%A8.html",relativePath:"01.数据结构和算法/04.跳表.md",key:"v-45abfe3e",path:"/pages/62671a/",headers:[{level:2,title:"什么是跳表",slug:"什么是跳表",normalizedTitle:"什么是跳表",charIndex:9},{level:3,title:"跳表的时间复杂度",slug:"跳表的时间复杂度",normalizedTitle:"跳表的时间复杂度",charIndex:366},{level:3,title:"跳表的空间复杂度",slug:"跳表的空间复杂度",normalizedTitle:"跳表的空间复杂度",charIndex:543},{level:2,title:"跳表的操作",slug:"跳表的操作",normalizedTitle:"跳表的操作",charIndex:988},{level:3,title:"高效的动态插入和删除",slug:"高效的动态插入和删除",normalizedTitle:"高效的动态插入和删除",charIndex:1075},{level:3,title:"跳表索引动态更新",slug:"跳表索引动态更新",normalizedTitle:"跳表索引动态更新",charIndex:1403},{level:2,title:"为什么需要跳表",slug:"为什么需要跳表",normalizedTitle:"为什么需要跳表",charIndex:1680},{level:2,title:"跳表的应用场景",slug:"跳表的应用场景",normalizedTitle:"跳表的应用场景",charIndex:1873},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2198}],headersStr:"什么是跳表 跳表的时间复杂度 跳表的空间复杂度 跳表的操作 高效的动态插入和删除 跳表索引动态更新 为什么需要跳表 跳表的应用场景 参考资料",content:"# 跳表\n\n\n# 什么是跳表\n\n对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 O(log n)。\n\n但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 O(n)。\n\n\n\n如何提高链表的查找效率呢？\n\n我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作跳表（Skip list）。\n\n\n\n随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。\n\n\n\n随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。这种链表加多级索引的结构，就是跳表。\n\n\n\n\n# 跳表的时间复杂度\n\n在一个具有多级索引的跳表中，第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2k)。所以跳表查询数据的时间复杂度就是 O(logn)。\n\n\n# 跳表的空间复杂度\n\n比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。\n\n假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。\n\n索引节点数 = n/2 + n/4 + n/8 … + 8 + 4 + 2 = n-2\n\n\n所以，跳表的空间复杂度是 O(n)。\n\n跳表的存储空间其实还有压缩空间。比如，我们增加索引节点的范围，由『每两个节点抽一个上级索引节点』改为『每五个节点抽一个上级索引节点』，可以显著节省存储空间。\n\n实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。\n\n\n# 跳表的操作\n\n跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）。\n\n\n# 高效的动态插入和删除\n\n跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。\n\n\n\n * 插入操作：对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(log n)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(log n)。\n * 删除操作：如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。\n\n\n# 跳表索引动态更新\n\n当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。\n\n\n\n如红黑树、AVL 树这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。\n\n当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？可以通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。\n\n\n# 为什么需要跳表\n\n跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。\n\n跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。\n\n\n# 跳表的应用场景\n\n经典实现：Redis 的 Sorted Set、JDK 的 ConcurrentSkipListMap 和 ConcurrentSkipListSet 都是基于跳表实现。\n\n为什么 Redis 要用跳表来实现有序集合，而不是红黑树？\n\nRedis 中的有序集合支持的核心操作主要有下面这几个：\n\n * 插入一个数据；\n * 删除一个数据；\n * 查找一个数据；\n * 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；\n * 迭代输出有序序列。\n\n其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。\n\n\n# 参考资料\n\n * 数据结构与算法之美",normalizedContent:"# 跳表\n\n\n# 什么是跳表\n\n对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 o(log n)。\n\n但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 o(n)。\n\n\n\n如何提高链表的查找效率呢？\n\n我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作跳表（skip list）。\n\n\n\n随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。\n\n\n\n随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。这种链表加多级索引的结构，就是跳表。\n\n\n\n\n# 跳表的时间复杂度\n\n在一个具有多级索引的跳表中，第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2k)。所以跳表查询数据的时间复杂度就是 o(logn)。\n\n\n# 跳表的空间复杂度\n\n比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。\n\n假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。\n\n索引节点数 = n/2 + n/4 + n/8 … + 8 + 4 + 2 = n-2\n\n\n所以，跳表的空间复杂度是 o(n)。\n\n跳表的存储空间其实还有压缩空间。比如，我们增加索引节点的范围，由『每两个节点抽一个上级索引节点』改为『每五个节点抽一个上级索引节点』，可以显著节省存储空间。\n\n实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。\n\n\n# 跳表的操作\n\n跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（red-black tree）。\n\n\n# 高效的动态插入和删除\n\n跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 o(logn)。\n\n\n\n * 插入操作：对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 o(log n)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 o(log n)。\n * 删除操作：如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。\n\n\n# 跳表索引动态更新\n\n当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。\n\n\n\n如红黑树、avl 树这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。\n\n当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？可以通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 k，那我们就将这个结点添加到第一级到第 k 级这 k 级索引中。\n\n\n# 为什么需要跳表\n\n跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 o(logn)。\n\n跳表的空间复杂度是 o(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。\n\n\n# 跳表的应用场景\n\n经典实现：redis 的 sorted set、jdk 的 concurrentskiplistmap 和 concurrentskiplistset 都是基于跳表实现。\n\n为什么 redis 要用跳表来实现有序集合，而不是红黑树？\n\nredis 中的有序集合支持的核心操作主要有下面这几个：\n\n * 插入一个数据；\n * 删除一个数据；\n * 查找一个数据；\n * 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；\n * 迭代输出有序序列。\n\n其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。\n\n\n# 参考资料\n\n * 数据结构与算法之美",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-8868cef6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-9fddd836",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"算法代码模板",frontmatter:{},regularPath:"/algorithm-template.html",relativePath:"algorithm-template.md",key:"v-cbf003be",path:"/algorithm-template.html",headers:[{level:2,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:42},{level:2,title:"DFS",slug:"dfs",normalizedTitle:"dfs",charIndex:366},{level:2,title:"BFS",slug:"bfs",normalizedTitle:"bfs",charIndex:603},{level:2,title:"二分查找",slug:"二分查找",normalizedTitle:"二分查找",charIndex:1234},{level:2,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:1541},{level:2,title:"位运算",slug:"位运算",normalizedTitle:"位运算",charIndex:1835}],headersStr:"递归 DFS BFS 二分查找 动态规划 位运算",content:"# 算法代码模板\n\n> 算法代码模板即算法的常见套路。熟练记忆，活学活用。\n\n\n# 递归\n\npublic void recursion(int level, int param1, int param2, ...) {\n    // 递归终止条件\n    if (level > MAX_LEVEL) {\n        // print\n        return;\n    }\n\n    // 当前处理逻辑\n    processData(level, param1, param2, ...);\n\n    // 递归\n    recursion(level + 1, param1, param2, ...);\n\n    // 如有必要，还原状态\n    reverseState(level, data);\n}\n\n\n\n# DFS\n\nSet<Node> visited = new HashSet<>();\n\npublic void dfs(Node node, Set<Node> visited) {\n    visited.add(node);\n    for (Node n : node.children) {\n        if (!visited.contains(n)) {\n            dfs(n, visited);\n        }\n    }\n}\n\n\n\n# BFS\n\npublic List<List<Integer>> bfs(Node root) {\n    List<List<Integer>> list = new ArrayList<>();\n    Queue<Node> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        List<Integer> levelList = new ArrayList<>();\n\n        int size = queue.size();\n        // 遍历当前层级所有节点\n        for (int i = 0; i < size; i++) {\n            Node n = queue.poll();\n\n            // 对节点 n 做逻辑处理\n            levelList.add(n.val);\n\n            // 将 n 的所有节点加入队列\n            for (Node c : n.children) {\n                queue.offer(c);\n            }\n        }\n\n        list.add(levelList);\n    }\n\n    return list;\n}\n\n\n\n# 二分查找\n\n数组的二分查找：\n\nint left = 0, right = nums.length - 1;\nwhile (left <= right) {\n    int mid = left + (right - left) / 2; // 防止数据类型溢出\n    if (nums[mid] == target) {\n        break or return result;\n    } else if (nums[mid] < target) {\n        left = mid + 1;\n    } else {\n        right = mid - 1;\n    }\n}\n\n\n\n# 动态规划\n\n// DP 状态定义\nint[][] dp = new int[m + 1][n + 1];\n\n// 初始状态\ndp[0][0] = x;\ndp[0][1] = y;\n\n// DP 状态推导\nfor (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n        // 方程根据实际场景推导\n        dp[i][j] = max or min { dp[i - 1][j], dp[i][j - 1], ... }\n    }\n}\n\n// 返回最优解\nreturn dp[m][n];\n\n\n\n# 位运算\n\n记忆常用位运算公式（无他，背就完事了）\n\n           二进制表达式            等价表达式\n判断奇偶       x & 1 == 1        x % 2 == 1\n           x & 1 == 0        x % 2 == 0\n清零最低位的 1   x = x & (x - 1)   \n得到最低位的 1   x & -x            ",normalizedContent:"# 算法代码模板\n\n> 算法代码模板即算法的常见套路。熟练记忆，活学活用。\n\n\n# 递归\n\npublic void recursion(int level, int param1, int param2, ...) {\n    // 递归终止条件\n    if (level > max_level) {\n        // print\n        return;\n    }\n\n    // 当前处理逻辑\n    processdata(level, param1, param2, ...);\n\n    // 递归\n    recursion(level + 1, param1, param2, ...);\n\n    // 如有必要，还原状态\n    reversestate(level, data);\n}\n\n\n\n# dfs\n\nset<node> visited = new hashset<>();\n\npublic void dfs(node node, set<node> visited) {\n    visited.add(node);\n    for (node n : node.children) {\n        if (!visited.contains(n)) {\n            dfs(n, visited);\n        }\n    }\n}\n\n\n\n# bfs\n\npublic list<list<integer>> bfs(node root) {\n    list<list<integer>> list = new arraylist<>();\n    queue<node> queue = new linkedlist<>();\n    queue.offer(root);\n    while (!queue.isempty()) {\n        list<integer> levellist = new arraylist<>();\n\n        int size = queue.size();\n        // 遍历当前层级所有节点\n        for (int i = 0; i < size; i++) {\n            node n = queue.poll();\n\n            // 对节点 n 做逻辑处理\n            levellist.add(n.val);\n\n            // 将 n 的所有节点加入队列\n            for (node c : n.children) {\n                queue.offer(c);\n            }\n        }\n\n        list.add(levellist);\n    }\n\n    return list;\n}\n\n\n\n# 二分查找\n\n数组的二分查找：\n\nint left = 0, right = nums.length - 1;\nwhile (left <= right) {\n    int mid = left + (right - left) / 2; // 防止数据类型溢出\n    if (nums[mid] == target) {\n        break or return result;\n    } else if (nums[mid] < target) {\n        left = mid + 1;\n    } else {\n        right = mid - 1;\n    }\n}\n\n\n\n# 动态规划\n\n// dp 状态定义\nint[][] dp = new int[m + 1][n + 1];\n\n// 初始状态\ndp[0][0] = x;\ndp[0][1] = y;\n\n// dp 状态推导\nfor (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n        // 方程根据实际场景推导\n        dp[i][j] = max or min { dp[i - 1][j], dp[i][j - 1], ... }\n    }\n}\n\n// 返回最优解\nreturn dp[m][n];\n\n\n\n# 位运算\n\n记忆常用位运算公式（无他，背就完事了）\n\n           二进制表达式            等价表达式\n判断奇偶       x & 1 == 1        x % 2 == 1\n           x & 1 == 0        x % 2 == 0\n清零最低位的 1   x = x & (x - 1)   \n得到最低位的 1   x & -x            ",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"ALGORITHM-TUTORIAL",tagline:"💾 algorithm-tutorial 是一个数据结构与算法教程。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-26618d36",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:176},{level:2,title:"💻 刷题",slug:"💻-刷题",normalizedTitle:"💻 刷题",charIndex:481},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:257},{level:3,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:260},{level:3,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:306},{level:3,title:"队列",slug:"队列",normalizedTitle:"队列",charIndex:308},{level:3,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:1055},{level:3,title:"树",slug:"树",normalizedTitle:"树",charIndex:359},{level:4,title:"二叉树",slug:"二叉树",normalizedTitle:"二叉树",charIndex:368},{level:4,title:"二叉搜索树",slug:"二叉搜索树",normalizedTitle:"二叉搜索树",charIndex:1525},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1610},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3179}],headersStr:"📖 内容 💻 刷题 数组 链表 栈 队列 字符串 树 二叉树 二叉搜索树 📚 资料 🚪 传送",content:"ALGORITHM-TUTORIAL\n\n> 💾 algorithm-tutorial 是一个数据结构与算法教程。\n> \n> 掌握数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n\n * 综合\n * 数据结构和算法指南\n * 复杂度分析 - 关键词：时间复杂度、空间复杂度、大 O 表示法、复杂度量级\n * 线性表\n   * 数组和链表 - 关键词：线性表、一维数组、多维数组、随机访问、单链表、双链表、循环链表\n   * 栈和队列 - 关键词：先进后出、后进先出、循环队列\n   * 线性表的查找\n   * 线性表的排序\n * 树\n   * 树和二叉树\n   * 堆\n   * B+树\n   * LSM 树\n   * 字典树\n   * 红黑树\n * 哈希表 - 关键词：哈希函数、装载因子、哈希冲突、开放寻址法、拉链法\n * 跳表 - 关键词：多级索引\n * 图\n\n\n# 💻 刷题\n\n\n# 数组\n\n * 三数之和\n * 两数之和\n * 二维数组\n * 删除排序数组中的重复项\n * 加一\n * 在排序数组中查找元素的第一个和最后一个位置\n * 在排序数组中查找数字 I\n * 存在重复元素\n * 对角线遍历\n * 寻找数组的中心索引\n * 将数组分成和相等的三个部分\n * 数组二分查找\n * 数组拆分 1\n * 旋转数组\n * 旋转矩阵\n * 最大连续 1 的个数\n * 杨辉三角\n * 杨辉三角 2\n * 模拟 ArrayList1\n * 模拟 ArrayList2\n * 移动零\n * 移除元素\n * 至少是其他数字两倍的最大数\n * 螺旋矩阵\n * 长度最小的子数组\n * 零矩阵\n\n\n# 链表\n\n * 两数相加\n * 二进制链表转整数\n * 删除排序链表中的重复元素\n * 单链表示例\n * 双链表示例\n * 反转链表\n * 合并 K 个排序链表\n * 合并 K 个排序链表解法 2\n * 合并两个有序链表\n * 回文链表\n * 排序链表\n * 环形链表\n * 相交链表\n * 移除重复节点\n * 移除链表元素\n * 返回倒数第 k 个节点\n * 链表的中间结点\n\n\n# 栈\n\n * 三合一\n * 基本计算器\n * 最小栈\n * 最小栈 2\n * 有效的括号\n * 栈排序\n * 棒球比赛\n * 比较含退格的字符串\n * 用栈实现队列\n * 用队列实现栈\n\n\n# 队列\n\n * 动态扩容数组实现的队列\n * 数组实现的队列\n * 最近的请求次数\n * 设计循环队列\n * 链表实现的队列\n\n\n# 字符串\n\n * 二进制求和\n * 实现 strStr()\n * 最长公共前缀\n * 反转字符串\n * 反转字符串中的单词\n * 反转字符串中的单词 III\n\n\n# 树\n\n * N 叉树的最大深度\n\n# 二叉树\n\n * 二叉树中的最大路径和\n * 二叉树的中序遍历\n * 二叉树的前序遍历\n * 二叉树的后序遍历\n * 二叉树的层次遍历\n * 二叉树的层次遍历 2\n * 二叉树的序列化与反序列化\n * 二叉树的所有路径\n * 二叉树的最大深度\n * 二叉树的最小深度\n * 二叉树的最近公共祖先\n * 二叉树的锯齿形层次遍历\n * 从先序遍历还原二叉树\n * 叶子相似的树\n * 填充每个节点的下一个右侧节点指针\n * 填充每个节点的下一个右侧节点指针 II\n * 对称二叉树\n * 平衡二叉树\n * 相同的树\n * 翻转二叉树\n * 路径总和\n\n# 二叉搜索树\n\n * 二叉搜索树中的插入操作\n * 二叉搜索树的最近公共祖先\n * 二叉搜索树节点最小距离\n * 将有序数组转换为二叉搜索树\n * 验证二叉搜索树\n\n\n# 📚 资料\n\n * 书籍\n   * 刷题必备\n     * 《剑指 offer》\n     * 《编程之美》\n     * 《编程之法:面试和算法心得》\n     * 《算法谜题》 都是思维题\n   * 基础\n     * 《编程珠玑（第 2 版）》\n     * 《编程珠玑（续）》\n     * 《数据结构与算法分析 : C++描述（第 4 版）》\n     * 《数据结构与算法分析 : C 语言描述（第 2 版）》\n     * 《数据结构与算法分析 : Java 语言描述（第 2 版）》\n     * 《算法（第 4 版）》\n   * 算法设计\n     * 《算法设计与分析基础（第 3 版）》\n     * 《Algorithm Design Manual》 - 算法设计手册 红皮书\n     * 《算法导论》 - 是一本对算法介绍比较全面的经典书籍\n     * 《Algorithms on Strings,Trees and Sequences》\n     * 《Advanced Data Structures》 - 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树 600 块\n * 学习网站\n   * https://github.com/TheAlgorithms/Java\n   * https://github.com/nonstriater/Learn-Algorithms\n   * https://github.com/trekhleb/javascript-algorithms\n   * https://github.com/wangzheng0822/algo\n   * https://github.com/kdn251/interviews/blob/master/README-zh-cn.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\n   * July 博客\n     * 《数学建模十大经典算法》\n     * 《数据挖掘领域十大经典算法》\n     * 《十道海量数据处理面试题》\n     * 《数字图像处理领域的二十四个经典算法》\n     * 《精选微软等公司经典的算法面试 100 题》\n   * The-Art-Of-Programming-By-July\n   * 微软面试 100 题\n   * 程序员编程艺术\n * 基本算法演示\n   * http://sjjg.js.zwu.edu.cn/SFXX/sf1/sfys.html\n   * http://www.cs.usfca.edu/\\~galles/visualization/Algorithms.html\n * 编程网站\n   * leetcode\n   * openjudge\n * 教程\n   * 高级数据结构和算法 北大教授张铭老师在 coursera 上的课程。完成这门课之时，你将掌握多维数组、广义表、Trie 树、AVL 树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然 coursera 上也还有很多其它算法方面的视频课程。\n   * 算法设计与分析 Design and Analysis of Algorithms 由北大教授 Wanling Qu 在 coursera 讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf 文件）以便阅读和复习。\n   * 算法面试通关 40 讲\n   * 数据结构与算法之美\n\n\n# 🚪 传送\n\n| 技术文档归档 | 算法和数据结构教程系列 |",normalizedContent:"algorithm-tutorial\n\n> 💾 algorithm-tutorial 是一个数据结构与算法教程。\n> \n> 掌握数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n\n * 综合\n * 数据结构和算法指南\n * 复杂度分析 - 关键词：时间复杂度、空间复杂度、大 o 表示法、复杂度量级\n * 线性表\n   * 数组和链表 - 关键词：线性表、一维数组、多维数组、随机访问、单链表、双链表、循环链表\n   * 栈和队列 - 关键词：先进后出、后进先出、循环队列\n   * 线性表的查找\n   * 线性表的排序\n * 树\n   * 树和二叉树\n   * 堆\n   * b+树\n   * lsm 树\n   * 字典树\n   * 红黑树\n * 哈希表 - 关键词：哈希函数、装载因子、哈希冲突、开放寻址法、拉链法\n * 跳表 - 关键词：多级索引\n * 图\n\n\n# 💻 刷题\n\n\n# 数组\n\n * 三数之和\n * 两数之和\n * 二维数组\n * 删除排序数组中的重复项\n * 加一\n * 在排序数组中查找元素的第一个和最后一个位置\n * 在排序数组中查找数字 i\n * 存在重复元素\n * 对角线遍历\n * 寻找数组的中心索引\n * 将数组分成和相等的三个部分\n * 数组二分查找\n * 数组拆分 1\n * 旋转数组\n * 旋转矩阵\n * 最大连续 1 的个数\n * 杨辉三角\n * 杨辉三角 2\n * 模拟 arraylist1\n * 模拟 arraylist2\n * 移动零\n * 移除元素\n * 至少是其他数字两倍的最大数\n * 螺旋矩阵\n * 长度最小的子数组\n * 零矩阵\n\n\n# 链表\n\n * 两数相加\n * 二进制链表转整数\n * 删除排序链表中的重复元素\n * 单链表示例\n * 双链表示例\n * 反转链表\n * 合并 k 个排序链表\n * 合并 k 个排序链表解法 2\n * 合并两个有序链表\n * 回文链表\n * 排序链表\n * 环形链表\n * 相交链表\n * 移除重复节点\n * 移除链表元素\n * 返回倒数第 k 个节点\n * 链表的中间结点\n\n\n# 栈\n\n * 三合一\n * 基本计算器\n * 最小栈\n * 最小栈 2\n * 有效的括号\n * 栈排序\n * 棒球比赛\n * 比较含退格的字符串\n * 用栈实现队列\n * 用队列实现栈\n\n\n# 队列\n\n * 动态扩容数组实现的队列\n * 数组实现的队列\n * 最近的请求次数\n * 设计循环队列\n * 链表实现的队列\n\n\n# 字符串\n\n * 二进制求和\n * 实现 strstr()\n * 最长公共前缀\n * 反转字符串\n * 反转字符串中的单词\n * 反转字符串中的单词 iii\n\n\n# 树\n\n * n 叉树的最大深度\n\n# 二叉树\n\n * 二叉树中的最大路径和\n * 二叉树的中序遍历\n * 二叉树的前序遍历\n * 二叉树的后序遍历\n * 二叉树的层次遍历\n * 二叉树的层次遍历 2\n * 二叉树的序列化与反序列化\n * 二叉树的所有路径\n * 二叉树的最大深度\n * 二叉树的最小深度\n * 二叉树的最近公共祖先\n * 二叉树的锯齿形层次遍历\n * 从先序遍历还原二叉树\n * 叶子相似的树\n * 填充每个节点的下一个右侧节点指针\n * 填充每个节点的下一个右侧节点指针 ii\n * 对称二叉树\n * 平衡二叉树\n * 相同的树\n * 翻转二叉树\n * 路径总和\n\n# 二叉搜索树\n\n * 二叉搜索树中的插入操作\n * 二叉搜索树的最近公共祖先\n * 二叉搜索树节点最小距离\n * 将有序数组转换为二叉搜索树\n * 验证二叉搜索树\n\n\n# 📚 资料\n\n * 书籍\n   * 刷题必备\n     * 《剑指 offer》\n     * 《编程之美》\n     * 《编程之法:面试和算法心得》\n     * 《算法谜题》 都是思维题\n   * 基础\n     * 《编程珠玑（第 2 版）》\n     * 《编程珠玑（续）》\n     * 《数据结构与算法分析 : c++描述（第 4 版）》\n     * 《数据结构与算法分析 : c 语言描述（第 2 版）》\n     * 《数据结构与算法分析 : java 语言描述（第 2 版）》\n     * 《算法（第 4 版）》\n   * 算法设计\n     * 《算法设计与分析基础（第 3 版）》\n     * 《algorithm design manual》 - 算法设计手册 红皮书\n     * 《算法导论》 - 是一本对算法介绍比较全面的经典书籍\n     * 《algorithms on strings,trees and sequences》\n     * 《advanced data structures》 - 各种诡异高级的数据结构和算法 如元胞自动机、斐波纳契堆、线段树 600 块\n * 学习网站\n   * https://github.com/thealgorithms/java\n   * https://github.com/nonstriater/learn-algorithms\n   * https://github.com/trekhleb/javascript-algorithms\n   * https://github.com/wangzheng0822/algo\n   * https://github.com/kdn251/interviews/blob/master/readme-zh-cn.md#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84\n   * july 博客\n     * 《数学建模十大经典算法》\n     * 《数据挖掘领域十大经典算法》\n     * 《十道海量数据处理面试题》\n     * 《数字图像处理领域的二十四个经典算法》\n     * 《精选微软等公司经典的算法面试 100 题》\n   * the-art-of-programming-by-july\n   * 微软面试 100 题\n   * 程序员编程艺术\n * 基本算法演示\n   * http://sjjg.js.zwu.edu.cn/sfxx/sf1/sfys.html\n   * http://www.cs.usfca.edu/\\~galles/visualization/algorithms.html\n * 编程网站\n   * leetcode\n   * openjudge\n * 教程\n   * 高级数据结构和算法 北大教授张铭老师在 coursera 上的课程。完成这门课之时，你将掌握多维数组、广义表、trie 树、avl 树、伸展树等高级数据结构，并结合内排序、外排序、检索、索引有关的算法，高效地解决现实生活中一些比较复杂的应用问题。当然 coursera 上也还有很多其它算法方面的视频课程。\n   * 算法设计与分析 design and analysis of algorithms 由北大教授 wanling qu 在 coursera 讲授的一门算法课程。首先介绍一些与算法有关的基础知识，然后阐述经典的算法设计思想和分析技术，主要涉及的算法设计技术是：分治策略、动态规划、贪心法、回溯与分支限界等。每个视频都配有相应的讲义（pdf 文件）以便阅读和复习。\n   * 算法面试通关 40 讲\n   * 数据结构与算法之美\n\n\n# 🚪 传送\n\n| 技术文档归档 | 算法和数据结构教程系列 |",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"Hash 表的查找",frontmatter:{},regularPath:"/hash-search.html",relativePath:"hash-search.md",key:"v-72ca5905",path:"/hash-search.html",headers:[{level:2,title:"要点",slug:"要点",normalizedTitle:"要点",charIndex:16},{level:3,title:"哈希表和哈希函数",slug:"哈希表和哈希函数",normalizedTitle:"哈希表和哈希函数",charIndex:23},{level:3,title:"冲突",slug:"冲突",normalizedTitle:"冲突",charIndex:247},{level:2,title:"构造哈希表",slug:"构造哈希表",normalizedTitle:"构造哈希表",charIndex:389},{level:3,title:"直接定址法",slug:"直接定址法",normalizedTitle:"直接定址法",charIndex:514},{level:3,title:"数字分析法",slug:"数字分析法",normalizedTitle:"数字分析法",charIndex:581},{level:3,title:"平方取中法",slug:"平方取中法",normalizedTitle:"平方取中法",charIndex:691},{level:3,title:"除留余数法",slug:"除留余数法",normalizedTitle:"除留余数法",charIndex:813},{level:3,title:"随机数法",slug:"随机数法",normalizedTitle:"随机数法",charIndex:983},{level:2,title:"解决冲突",slug:"解决冲突",normalizedTitle:"解决冲突",charIndex:1073},{level:3,title:"开放定址法",slug:"开放定址法",normalizedTitle:"开放定址法",charIndex:1131},{level:3,title:"拉链法",slug:"拉链法",normalizedTitle:"拉链法",charIndex:1606},{level:2,title:"实现一个哈希表",slug:"实现一个哈希表",normalizedTitle:"实现一个哈希表",charIndex:1752},{level:3,title:"完整示例",slug:"完整示例",normalizedTitle:"完整示例",charIndex:4238},{level:2,title:"资源",slug:"资源",normalizedTitle:"资源",charIndex:4253}],headersStr:"要点 哈希表和哈希函数 冲突 构造哈希表 直接定址法 数字分析法 平方取中法 除留余数法 随机数法 解决冲突 开放定址法 拉链法 实现一个哈希表 完整示例 资源",content:"# Hash 表的查找\n\n\n# 要点\n\n\n# 哈希表和哈希函数\n\n在记录的存储位置和它的关键字之间是建立一个确定的对应关系（映射函数），使每个关键字和一个存储位置能唯一对应。这个映射函数称为哈希函数，根据这个原则建立的表称为哈希表(Hash Table)，也叫哈希表。\n\n以上描述，如果通过数学形式来描述就是：\n\n若查找关键字为 key，则其值存放在 f(key) 的存储位置上。由此，不需比较便可直接取得所查记录。\n\n注：哈希查找与线性表查找和树表查找最大的区别在于，不用数值比较。\n\n\n# 冲突\n\n若 key1 ≠ key2 ，而 f(key1) = f(key2)，这种情况称为冲突(Collision)。\n\n根据哈希函数f(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这一映射过程称为构造哈希表。\n\n构造哈希表这个场景就像汽车找停车位，如果车位被人占了，只能找空的地方停。\n\n\n\n\n# 构造哈希表\n\n由以上内容可知，哈希查找本身其实不费吹灰之力，问题的关键在于如何构造哈希表和处理冲突。\n\n常见的构造哈希表的方法有 5 种：\n\n\n# 直接定址法\n\n说白了，就是小学时学过的一元一次方程。\n\n即 f(key) = a * key + b。其中，a和b 是常数。\n\n\n# 数字分析法\n\n假设关键字是R进制数（如十进制）。并且哈希表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成哈希地址。\n\n选取的原则是使得到的哈希地址尽量避免冲突，即所选数位上的数字尽可能是随机的。\n\n\n# 平方取中法\n\n取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，仅取其中的几位为地址不一定合适；\n\n而一个数平方后的中间几位数和数的每一位都相关， 由此得到的哈希地址随机性更大。取的位数由表长决定。\n\n\n# 除留余数法\n\n取关键字被某个不大于哈希表表长 m 的数 p 除后所得的余数为哈希地址。\n\n即 f(key) = key % p (p ≤ m)\n\n这是一种最简单、最常用的方法，它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。\n\n注意：p的选择很重要，如果选的不好，容易产生冲突。根据经验，一般情况下可以选p为素数。\n\n\n# 随机数法\n\n选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 f(key) = random(key)。\n\n通常，在关键字长度不等时采用此法构造哈希函数较为恰当。\n\n\n# 解决冲突\n\n设计合理的哈希函数可以减少冲突，但不能完全避免冲突。\n\n所以需要有解决冲突的方法，常见有两类：\n\n\n# 开放定址法\n\n如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。 当程序查找哈希表时，如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，或者遇到一个空的表项。\n\n示例\n\n若要将一组关键字序列 {1, 9, 25, 11, 12, 35, 17, 29} 存放到哈希表中。\n\n采用除留余数法构造哈希表；采用开放定址法处理冲突。\n\n不妨设选取的p和m为13，由 f(key) = key % 13 可以得到下表。\n\n\n\n需要注意的是，在上图中有两个关键字的探查次数为 2 ，其他都是1。\n\n这个过程是这样的：\n\na. 12 % 13 结果是12，而它的前面有个 25 ，25 % 13 也是12，存在冲突。\n\n我们使用开放定址法 (12 + 1) % 13 = 0，没有冲突，完成。\n\nb. 35 % 13 结果是 9，而它的前面有个 9，9 % 13也是 9，存在冲突。\n\n我们使用开放定址法 (9 + 1) % 13 = 10，没有冲突，完成。\n\n\n# 拉链法\n\n将哈希值相同的数据元素存放在一个链表中，在查找哈希表的过程中，当查找到这个链表时，必须采用线性查找方法。\n\n在这种方法中，哈希表中每个单元存放的不再是记录本身，而是相应同义词单链表的头指针。\n\n示例\n\n如果对开放定址法示例中提到的序列使用拉链法，得到的结果如下图所示：\n\n\n\n\n# 实现一个哈希表\n\n假设要实现一个哈希表，要求\n\na. 哈希函数采用除留余数法，即 f(key) = key % p (p ≤ m)\n\nb. 解决冲突采用开放定址法，即 f2(key) = (f(key)+i) % size (p ≤ m)\n\n（1）定义哈希表的数据结构\n\nclass HashTable {\n    public int key = 0; // 关键字\n    public int data = 0; // 数值\n    public int count = 0; // 探查次数\n}\n\n\n（2）在哈希表中查找关键字key\n\n根据设定的哈希函数，计算哈希地址。如果出现地址冲突，则按设定的处理冲突的方法寻找下一个地址。\n\n如此反复，直到不冲突为止（查找成功）或某个地址为空（查找失败）。\n\n/**\n * 查找哈希表\n * 构造哈希表采用除留取余法，即f(key) = key mod p (p ≤ size)\n * 解决冲突采用开放定址法，即f2(key) = (f(key) + i) mod p (1 ≤ i ≤ size-1)\n * ha为哈希表，p为模，size为哈希表大小，key为要查找的关键字\n */\npublic int searchHashTable(HashTable[] ha, int p, int size, int key) {\n    int addr = key % p; // 采用除留取余法找哈希地址\n\n    // 若发生冲突，用开放定址法找下一个哈希地址\n    while (ha[addr].key != NULLKEY && ha[addr].key != key) {\n        addr = (addr + 1) % size;\n    }\n\n    if (ha[addr].key == key) {\n        return addr; // 查找成功\n    } else {\n        return FAILED; // 查找失败\n    }\n}\n\n\n（3）删除关键字为key的记录\n\n在采用开放定址法处理冲突的哈希表上执行删除操作，只能在被删记录上做删除标记，而不能真正删除记录。\n\n找到要删除的记录，将关键字置为删除标记DELKEY。\n\npublic int deleteHashTable(HashTable[] ha, int p, int size, int key) {\n    int addr = 0;\n    addr = searchHashTable(ha, p, size, key);\n    if (FAILED != addr) { // 找到记录\n        ha[addr].key = DELKEY; // 将该位置的关键字置为DELKEY\n        return SUCCESS;\n    } else {\n        return NULLKEY; // 查找不到记录，直接返回NULLKEY\n    }\n}\n\n\n（4）插入关键字为key的记录\n\n将待插入的关键字key插入哈希表 先调用查找算法，若在表中找到待插入的关键字，则插入失败； 若在表中找到一个开放地址，则将待插入的结点插入到其中，则插入成功。\n\npublic void insertHashTable(HashTable[] ha, int p, int size, int key) {\n    int i = 1;\n    int addr = 0;\n    addr = key % p; // 通过哈希函数获取哈希地址\n    if (ha[addr].key == NULLKEY || ha[addr].key == DELKEY) { // 如果没有冲突，直接插入\n        ha[addr].key = key;\n        ha[addr].count = 1;\n    } else { // 如果有冲突，使用开放定址法处理冲突\n        do {\n            addr = (addr + 1) % size; // 寻找下一个哈希地址\n            i++;\n        } while (ha[addr].key != NULLKEY && ha[addr].key != DELKEY);\n\n        ha[addr].key = key;\n        ha[addr].count = i;\n    }\n}\n\n\n（5）建立哈希表\n\n先将哈希表中各关键字清空，使其地址为开放的，然后调用插入算法将给定的关键字序列依次插入。\n\npublic void insertHashTable(HashTable[] ha, int p, int size, int key) {\n    int i = 1;\n    int addr = 0;\n    addr = key % p; // 通过哈希函数获取哈希地址\n    if (ha[addr].key == NULLKEY || ha[addr].key == DELKEY) { // 如果没有冲突，直接插入\n        ha[addr].key = key;\n        ha[addr].count = 1;\n    } else { // 如果有冲突，使用开放定址法处理冲突\n        do {\n            addr = (addr + 1) % size; // 寻找下一个哈希地址\n            i++;\n        } while (ha[addr].key != NULLKEY && ha[addr].key != DELKEY);\n\n        ha[addr].key = key;\n        ha[addr].count = i;\n    }\n}\n\n\n\n# 完整示例\n\n示例代码\n\n\n# 资源\n\n《数据结构习题与解析》（B级第3版）",normalizedContent:"# hash 表的查找\n\n\n# 要点\n\n\n# 哈希表和哈希函数\n\n在记录的存储位置和它的关键字之间是建立一个确定的对应关系（映射函数），使每个关键字和一个存储位置能唯一对应。这个映射函数称为哈希函数，根据这个原则建立的表称为哈希表(hash table)，也叫哈希表。\n\n以上描述，如果通过数学形式来描述就是：\n\n若查找关键字为 key，则其值存放在 f(key) 的存储位置上。由此，不需比较便可直接取得所查记录。\n\n注：哈希查找与线性表查找和树表查找最大的区别在于，不用数值比较。\n\n\n# 冲突\n\n若 key1 = key2 ，而 f(key1) = f(key2)，这种情况称为冲突(collision)。\n\n根据哈希函数f(key)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这一映射过程称为构造哈希表。\n\n构造哈希表这个场景就像汽车找停车位，如果车位被人占了，只能找空的地方停。\n\n\n\n\n# 构造哈希表\n\n由以上内容可知，哈希查找本身其实不费吹灰之力，问题的关键在于如何构造哈希表和处理冲突。\n\n常见的构造哈希表的方法有 5 种：\n\n\n# 直接定址法\n\n说白了，就是小学时学过的一元一次方程。\n\n即 f(key) = a * key + b。其中，a和b 是常数。\n\n\n# 数字分析法\n\n假设关键字是r进制数（如十进制）。并且哈希表中可能出现的关键字都是事先知道的，则可选取关键字的若干数位组成哈希地址。\n\n选取的原则是使得到的哈希地址尽量避免冲突，即所选数位上的数字尽可能是随机的。\n\n\n# 平方取中法\n\n取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，仅取其中的几位为地址不一定合适；\n\n而一个数平方后的中间几位数和数的每一位都相关， 由此得到的哈希地址随机性更大。取的位数由表长决定。\n\n\n# 除留余数法\n\n取关键字被某个不大于哈希表表长 m 的数 p 除后所得的余数为哈希地址。\n\n即 f(key) = key % p (p ≤ m)\n\n这是一种最简单、最常用的方法，它不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。\n\n注意：p的选择很重要，如果选的不好，容易产生冲突。根据经验，一般情况下可以选p为素数。\n\n\n# 随机数法\n\n选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 f(key) = random(key)。\n\n通常，在关键字长度不等时采用此法构造哈希函数较为恰当。\n\n\n# 解决冲突\n\n设计合理的哈希函数可以减少冲突，但不能完全避免冲突。\n\n所以需要有解决冲突的方法，常见有两类：\n\n\n# 开放定址法\n\n如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。 当程序查找哈希表时，如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，或者遇到一个空的表项。\n\n示例\n\n若要将一组关键字序列 {1, 9, 25, 11, 12, 35, 17, 29} 存放到哈希表中。\n\n采用除留余数法构造哈希表；采用开放定址法处理冲突。\n\n不妨设选取的p和m为13，由 f(key) = key % 13 可以得到下表。\n\n\n\n需要注意的是，在上图中有两个关键字的探查次数为 2 ，其他都是1。\n\n这个过程是这样的：\n\na. 12 % 13 结果是12，而它的前面有个 25 ，25 % 13 也是12，存在冲突。\n\n我们使用开放定址法 (12 + 1) % 13 = 0，没有冲突，完成。\n\nb. 35 % 13 结果是 9，而它的前面有个 9，9 % 13也是 9，存在冲突。\n\n我们使用开放定址法 (9 + 1) % 13 = 10，没有冲突，完成。\n\n\n# 拉链法\n\n将哈希值相同的数据元素存放在一个链表中，在查找哈希表的过程中，当查找到这个链表时，必须采用线性查找方法。\n\n在这种方法中，哈希表中每个单元存放的不再是记录本身，而是相应同义词单链表的头指针。\n\n示例\n\n如果对开放定址法示例中提到的序列使用拉链法，得到的结果如下图所示：\n\n\n\n\n# 实现一个哈希表\n\n假设要实现一个哈希表，要求\n\na. 哈希函数采用除留余数法，即 f(key) = key % p (p ≤ m)\n\nb. 解决冲突采用开放定址法，即 f2(key) = (f(key)+i) % size (p ≤ m)\n\n（1）定义哈希表的数据结构\n\nclass hashtable {\n    public int key = 0; // 关键字\n    public int data = 0; // 数值\n    public int count = 0; // 探查次数\n}\n\n\n（2）在哈希表中查找关键字key\n\n根据设定的哈希函数，计算哈希地址。如果出现地址冲突，则按设定的处理冲突的方法寻找下一个地址。\n\n如此反复，直到不冲突为止（查找成功）或某个地址为空（查找失败）。\n\n/**\n * 查找哈希表\n * 构造哈希表采用除留取余法，即f(key) = key mod p (p ≤ size)\n * 解决冲突采用开放定址法，即f2(key) = (f(key) + i) mod p (1 ≤ i ≤ size-1)\n * ha为哈希表，p为模，size为哈希表大小，key为要查找的关键字\n */\npublic int searchhashtable(hashtable[] ha, int p, int size, int key) {\n    int addr = key % p; // 采用除留取余法找哈希地址\n\n    // 若发生冲突，用开放定址法找下一个哈希地址\n    while (ha[addr].key != nullkey && ha[addr].key != key) {\n        addr = (addr + 1) % size;\n    }\n\n    if (ha[addr].key == key) {\n        return addr; // 查找成功\n    } else {\n        return failed; // 查找失败\n    }\n}\n\n\n（3）删除关键字为key的记录\n\n在采用开放定址法处理冲突的哈希表上执行删除操作，只能在被删记录上做删除标记，而不能真正删除记录。\n\n找到要删除的记录，将关键字置为删除标记delkey。\n\npublic int deletehashtable(hashtable[] ha, int p, int size, int key) {\n    int addr = 0;\n    addr = searchhashtable(ha, p, size, key);\n    if (failed != addr) { // 找到记录\n        ha[addr].key = delkey; // 将该位置的关键字置为delkey\n        return success;\n    } else {\n        return nullkey; // 查找不到记录，直接返回nullkey\n    }\n}\n\n\n（4）插入关键字为key的记录\n\n将待插入的关键字key插入哈希表 先调用查找算法，若在表中找到待插入的关键字，则插入失败； 若在表中找到一个开放地址，则将待插入的结点插入到其中，则插入成功。\n\npublic void inserthashtable(hashtable[] ha, int p, int size, int key) {\n    int i = 1;\n    int addr = 0;\n    addr = key % p; // 通过哈希函数获取哈希地址\n    if (ha[addr].key == nullkey || ha[addr].key == delkey) { // 如果没有冲突，直接插入\n        ha[addr].key = key;\n        ha[addr].count = 1;\n    } else { // 如果有冲突，使用开放定址法处理冲突\n        do {\n            addr = (addr + 1) % size; // 寻找下一个哈希地址\n            i++;\n        } while (ha[addr].key != nullkey && ha[addr].key != delkey);\n\n        ha[addr].key = key;\n        ha[addr].count = i;\n    }\n}\n\n\n（5）建立哈希表\n\n先将哈希表中各关键字清空，使其地址为开放的，然后调用插入算法将给定的关键字序列依次插入。\n\npublic void inserthashtable(hashtable[] ha, int p, int size, int key) {\n    int i = 1;\n    int addr = 0;\n    addr = key % p; // 通过哈希函数获取哈希地址\n    if (ha[addr].key == nullkey || ha[addr].key == delkey) { // 如果没有冲突，直接插入\n        ha[addr].key = key;\n        ha[addr].count = 1;\n    } else { // 如果有冲突，使用开放定址法处理冲突\n        do {\n            addr = (addr + 1) % size; // 寻找下一个哈希地址\n            i++;\n        } while (ha[addr].key != nullkey && ha[addr].key != delkey);\n\n        ha[addr].key = key;\n        ha[addr].count = i;\n    }\n}\n\n\n\n# 完整示例\n\n示例代码\n\n\n# 资源\n\n《数据结构习题与解析》（b级第3版）",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"算法思路",frontmatter:{},regularPath:"/%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html",relativePath:"算法思路.md",key:"v-2b1e259c",path:"/%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html",headers:[{level:2,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:11},{level:3,title:"使用递归的条件",slug:"使用递归的条件",normalizedTitle:"使用递归的条件",charIndex:18},{level:3,title:"递归代码要警惕堆栈溢出",slug:"递归代码要警惕堆栈溢出",normalizedTitle:"递归代码要警惕堆栈溢出",charIndex:113},{level:2,title:"贪心算法",slug:"贪心算法",normalizedTitle:"贪心算法",charIndex:293},{level:3,title:"贪心算法思路",slug:"贪心算法思路",normalizedTitle:"贪心算法思路",charIndex:302},{level:3,title:"贪心算法的应用",slug:"贪心算法的应用",normalizedTitle:"贪心算法的应用",charIndex:524},{level:2,title:"分治算法",slug:"分治算法",normalizedTitle:"分治算法",charIndex:602},{level:2,title:"回溯算法",slug:"回溯算法",normalizedTitle:"回溯算法",charIndex:1047},{level:3,title:"回溯算法思路",slug:"回溯算法思路",normalizedTitle:"回溯算法思路",charIndex:1056},{level:3,title:"回溯算法应用",slug:"回溯算法应用",normalizedTitle:"回溯算法应用",charIndex:1587},{level:2,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:922},{level:3,title:"动态规划思路",slug:"动态规划思路",normalizedTitle:"动态规划思路",charIndex:1709},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1772}],headersStr:"递归 使用递归的条件 递归代码要警惕堆栈溢出 贪心算法 贪心算法思路 贪心算法的应用 分治算法 回溯算法 回溯算法思路 回溯算法应用 动态规划 动态规划思路 参考资料",content:"# 算法思路\n\n\n# 递归\n\n\n# 使用递归的条件\n\n递归需要满足的三个条件\n\n * 一个问题的解可以分解为几个子问题的解\n * 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样\n * 存在递归终止条件\n\n\n# 递归代码要警惕堆栈溢出\n\n函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。\n\n那么，如何避免出现堆栈溢出呢？\n\n我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题\n\n\n# 贪心算法\n\n\n# 贪心算法思路\n\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择，就能得到问题的答案。贪心算法需要充分挖掘题目中条件，没有固定的模式，解决有贪心算法需要一定的直觉和经验。\n\n贪心算法不是对所有问题都能得到整体最优解。能使用贪心算法解决的问题具有「贪心选择性质」。「贪心选择性质」严格意义上需要数学证明。能使用贪心算法解决的问题必须具备「无后效性」，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。\n\n\n# 贪心算法的应用\n\n霍夫曼编码（Huffman Coding）\n\nPrim 和 Kruskal 最小生成树算法\n\nDijkstra 单源最短路径算法\n\n\n# 分治算法\n\n分治算法的核心就是分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，分别解决这些子问题，然后再合并其结果，得到原问题的解。\n\n分治算法是一种处理问题的思想，递归是一种编程技巧。分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：\n\n * 分解：将原问题分解成一系列子问题；\n * 解决：递归地求解各个子问题，若子问题足够小，则直接求解；\n * 合并：将子问题的结果合并成原问题。\n\n分治算法能解决的问题，一般需要满足下面这几个条件：\n\n * 原问题与分解成的小问题具有相同的模式；\n * 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；\n * 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；\n * 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。\n\n\n# 回溯算法\n\n\n# 回溯算法思路\n\n回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n * 找到一个可能存在的正确的答案；\n\n * 在尝试了所有可能的分步方法后宣告该问题没有答案。\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程。\n\n * 路径：也就是已经做出的选择。\n * 选择列表：也就是你当前可以做的选择。\n * 结束条件：也就是到达决策树底层，无法再做选择的条件。\n\n回溯算法的骨架：\n\nresult = []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」\n\n\n# 回溯算法应用\n\n回溯算法典型问题：\n\n * 46. 全排列（中等）\n * 47. 全排列 II（中等）\n * N 皇后（困难）\n\n 37. 解数独（困难）\n\n> 知乎：回溯算法套路详解 - labuladong的文章\n\n\n# 动态规划\n\n\n# 动态规划思路\n\n动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。\n\n动态规划的应用\n\n买卖股票的最佳时机\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * 回溯\n * 知乎：回溯算法套路详解 - labuladong的文章",normalizedContent:"# 算法思路\n\n\n# 递归\n\n\n# 使用递归的条件\n\n递归需要满足的三个条件\n\n * 一个问题的解可以分解为几个子问题的解\n * 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样\n * 存在递归终止条件\n\n\n# 递归代码要警惕堆栈溢出\n\n函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。\n\n那么，如何避免出现堆栈溢出呢？\n\n我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题\n\n\n# 贪心算法\n\n\n# 贪心算法思路\n\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择，就能得到问题的答案。贪心算法需要充分挖掘题目中条件，没有固定的模式，解决有贪心算法需要一定的直觉和经验。\n\n贪心算法不是对所有问题都能得到整体最优解。能使用贪心算法解决的问题具有「贪心选择性质」。「贪心选择性质」严格意义上需要数学证明。能使用贪心算法解决的问题必须具备「无后效性」，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。\n\n\n# 贪心算法的应用\n\n霍夫曼编码（huffman coding）\n\nprim 和 kruskal 最小生成树算法\n\ndijkstra 单源最短路径算法\n\n\n# 分治算法\n\n分治算法的核心就是分而治之，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，分别解决这些子问题，然后再合并其结果，得到原问题的解。\n\n分治算法是一种处理问题的思想，递归是一种编程技巧。分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：\n\n * 分解：将原问题分解成一系列子问题；\n * 解决：递归地求解各个子问题，若子问题足够小，则直接求解；\n * 合并：将子问题的结果合并成原问题。\n\n分治算法能解决的问题，一般需要满足下面这几个条件：\n\n * 原问题与分解成的小问题具有相同的模式；\n * 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；\n * 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；\n * 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。\n\n\n# 回溯算法\n\n\n# 回溯算法思路\n\n回溯法 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：\n\n * 找到一个可能存在的正确的答案；\n\n * 在尝试了所有可能的分步方法后宣告该问题没有答案。\n\n解决一个回溯问题，实际上就是一个决策树的遍历过程。\n\n * 路径：也就是已经做出的选择。\n * 选择列表：也就是你当前可以做的选择。\n * 结束条件：也就是到达决策树底层，无法再做选择的条件。\n\n回溯算法的骨架：\n\nresult = []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」\n\n\n# 回溯算法应用\n\n回溯算法典型问题：\n\n * 46. 全排列（中等）\n * 47. 全排列 ii（中等）\n * n 皇后（困难）\n\n 37. 解数独（困难）\n\n> 知乎：回溯算法套路详解 - labuladong的文章\n\n\n# 动态规划\n\n\n# 动态规划思路\n\n动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。\n\n动态规划的应用\n\n买卖股票的最佳时机\n\n\n# 参考资料\n\n * 数据结构与算法之美\n * 回溯\n * 知乎：回溯算法套路详解 - labuladong的文章",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"数据结构 - 树",frontmatter:{},regularPath:"/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%A0%91.html",relativePath:"算法练习-树.md",key:"v-212cfc36",path:"/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E6%A0%91.html",headers:[{level:2,title:"二叉树经典题",slug:"二叉树经典题",normalizedTitle:"二叉树经典题",charIndex:15},{level:3,title:"深度优先搜索（DFS）",slug:"深度优先搜索-dfs",normalizedTitle:"深度优先搜索（dfs）",charIndex:26},{level:3,title:"宽度优先搜索（BFS）",slug:"宽度优先搜索-bfs",normalizedTitle:"宽度优先搜索（bfs）",charIndex:181},{level:3,title:"二叉树和递归",slug:"二叉树和递归",normalizedTitle:"二叉树和递归",charIndex:252},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:293},{level:2,title:"二叉搜索树经典题",slug:"二叉搜索树经典题",normalizedTitle:"二叉搜索树经典题",charIndex:656}],headersStr:"二叉树经典题 深度优先搜索（DFS） 宽度优先搜索（BFS） 二叉树和递归 其他 二叉搜索树经典题",content:"# 数据结构 - 树\n\n\n# 二叉树经典题\n\n\n# 深度优先搜索（DFS）\n\n在这个策略中，我们采用 深度 作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n\n * 二叉树的前序遍历\n * 二叉树的中序遍历\n * 二叉树的后序遍历\n\n\n# 宽度优先搜索（BFS）\n\n我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n\n * 二叉树的层序遍历\n\n\n# 二叉树和递归\n\n * 二叉树的最大深度\n * 对称二叉树\n * 路径总和\n\n\n# 其他\n\n * [ ] maximum-depth-of-binary-tree\n * [ ] balanced-binary-tree\n * [ ] binary-tree-maximum-path-sum\n * [ ] lowest-common-ancestor-of-a-binary-tree\n * [ ] binary-tree-level-order-traversal\n * [ ] binary-tree-level-order-traversal-ii\n * [ ] binary-tree-zigzag-level-order-traversal\n * [ ] validate-binary-search-tree\n * [ ] insert-into-a-binary-search-tree\n\n\n# 二叉搜索树经典题\n\n * [ ] validate-binary-search-tree\n * [ ] insert-into-a-binary-search-tree\n * [ ] delete-node-in-a-bst\n * [ ] balanced-binary-tree",normalizedContent:"# 数据结构 - 树\n\n\n# 二叉树经典题\n\n\n# 深度优先搜索（dfs）\n\n在这个策略中，我们采用 深度 作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回到达另一个分支。深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n\n * 二叉树的前序遍历\n * 二叉树的中序遍历\n * 二叉树的后序遍历\n\n\n# 宽度优先搜索（bfs）\n\n我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n\n * 二叉树的层序遍历\n\n\n# 二叉树和递归\n\n * 二叉树的最大深度\n * 对称二叉树\n * 路径总和\n\n\n# 其他\n\n * [ ] maximum-depth-of-binary-tree\n * [ ] balanced-binary-tree\n * [ ] binary-tree-maximum-path-sum\n * [ ] lowest-common-ancestor-of-a-binary-tree\n * [ ] binary-tree-level-order-traversal\n * [ ] binary-tree-level-order-traversal-ii\n * [ ] binary-tree-zigzag-level-order-traversal\n * [ ] validate-binary-search-tree\n * [ ] insert-into-a-binary-search-tree\n\n\n# 二叉搜索树经典题\n\n * [ ] validate-binary-search-tree\n * [ ] insert-into-a-binary-search-tree\n * [ ] delete-node-in-a-bst\n * [ ] balanced-binary-tree",charsets:{cjk:!0},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-4a8dfe05",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/10/23, 06:46:22",lastUpdatedTimestamp:1761173182e3}],themeConfig:{nav:[],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/master/common/dunwu-logo.png",repo:"dunwu/algorithm-tutorial",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/01.数据结构和算法/":[{title:"综合",collapsable:!1,children:[["00.综合/01.数据结构和算法指南.md","数据结构和算法指南","/pages/8b1bd0/"],["00.综合/02.复杂度分析.md","复杂度分析","/pages/2a4131/"]]},{title:"线性表",collapsable:!1,children:[["01.线性表/01.数组和链表.md","数组和链表","/pages/5a9bff/"],["01.线性表/02.栈和队列.md","栈和队列","/pages/1f15c3/"],["01.线性表/11.线性表的查找.md","线性表的查找","/pages/4b1ed0/"],["01.线性表/12.线性表的排序.md","线性表的排序","/pages/21c5f2/"]]},{title:"树",collapsable:!1,children:[["02.树/01.树和二叉树.md","树和二叉树","/pages/92e4c1/"],["02.树/02.堆.md","堆","/pages/ce297c/"],["02.树/03.B+树.md","B+树","/pages/3fd76e/"],["02.树/04.LSM树.md","LSM树","/pages/4a217d/"],["02.树/05.字典树.md","字典树","/pages/0a4984/"],["02.树/06.红黑树.md","红黑树","/pages/0a4414/"]]},["03.哈希表.md","哈希表","/pages/b501c7/"],["04.跳表.md","跳表","/pages/62671a/"],["05.图.md","图","/pages/21529b/"]],catalogue:{}},updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{pageB:'\n  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ',windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};var wl=t(123),kl=t(124),El=t(21);var Tl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(El.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(El.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(El.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,i=n.length;r<i;r++){const{frontmatter:{categories:i,tags:o}}=n[r];"array"===Object(El.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(El.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Wt.component(wl.default),Wt.component(kl.default);function Ol(n){return n.toString().padStart(2,"0")}t(276);Wt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,385))),Wt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,123))),Wt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,124)));t(277);var jl=[({Vue:n,options:e,router:t,siteData:r})=>{try{document&&function(n){const e=document.createElement("link");e.href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css",e.rel="stylesheet",document.body.appendChild(e);const t=document.createElement("script");function r(n){let e=document.getElementById("gitalk-container");e||(e=document.createElement("div"),e.id="gitalk-container",e.classList.add("content"));const t=document.querySelector(".page");t&&(t.appendChild(e),"undefined"!=typeof Gitalk&&Gitalk instanceof Function&&function(n){console.info(n);new Gitalk({clientID:"8772d9c11ed3dc0b8922",clientSecret:"7c6d2d583ff9437f5405bf9479e08db63d3a75fb",repo:"blog",owner:"dunwu",admin:["dunwu"],id:"comment",distractionFreeMode:!1,language:"zh-CN"}).render("gitalk-container")}(n.fullPath))}t.src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js",document.body.appendChild(t),n.afterEach(n=>{t.onload?r(n):t.onload=()=>{r(n)}})}(t)}catch(n){console.error(n.message)}},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Ol(n.getUTCMonth()+1)}-${Ol(n.getUTCDate())} ${Ol(n.getUTCHours())}:${Ol(n.getUTCMinutes())}:${Ol(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Tl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",i.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<i.length;t++)i[t].alpha<=0?(e.body.removeChild(i[t].el),i.splice(t,1)):(i[t].y--,i[t].scale+=.004,i[t].alpha-=.013,i[t].el.style.cssText="left:"+i[t].x+"px;top:"+i[t].y+"px;opacity:"+i[t].alpha+";transform:scale("+i[t].scale+","+i[t].scale+") rotate(45deg);background:"+i[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],Sl=[];class Cl extends class{constructor(){this.store=new Wt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Wt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Cl.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:us});var Il={install(n){const e=new Cl;n.$vuepress=e,n.prototype.$vuepress=e}};function Al(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var zl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Wt.component(e)||Wt.component(e,ss(e)),Wt.component(e)?n(e):n("")}},$l={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ll={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Pl=(t(278),t(279),Object(yl.a)(Ll,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Bl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Wt.config.productionTip=!1,Wt.use(Va),Wt.use(Il),Wt.mixin(function(n,e,t=Wt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},_l)),Wt.component("Content",zl),Wt.component("ContentSlotsDistributor",$l),Wt.component("OutboundLink",Pl),Wt.component("ClientOnly",Bl),Wt.component("Layout",ls("Layout")),Wt.component("NotFound",ls("NotFound")),Wt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"538fa27"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:_l.routerBase||_l.base,t=new Va({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Wt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Al(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Al(n,t)?r(t):r()}else r();else{const t=e.path+"/",i=e.path+".html";Al(n,i)?r(i):Al(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(jl.filter(n=>"function"==typeof n).map(e=>e({Vue:Wt,options:r,router:t,siteData:_l,isServer:n})))}catch(n){console.error(n)}return{app:new Wt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Sl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);